(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/webextension-polyfill/dist/browser-polyfill.js
  var require_browser_polyfill = __commonJS({
    "node_modules/webextension-polyfill/dist/browser-polyfill.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define("webextension-polyfill", ["module"], factory);
        } else if (typeof exports !== "undefined") {
          factory(module);
        } else {
          var mod = {
            exports: {}
          };
          factory(mod);
          global2.browser = mod.exports;
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(module2) {
        "use strict";
        if (!globalThis.chrome?.runtime?.id) {
          throw new Error("This script should only be loaded in a browser extension.");
        }
        if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
          const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
          const wrapAPIs = (extensionAPIs) => {
            const apiMetadata = {
              "alarms": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "clearAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "bookmarks": {
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getChildren": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getRecent": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getSubTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTree": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeTree": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "browserAction": {
                "disable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "enable": {
                  "minArgs": 0,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "getBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "openPopup": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setBadgeBackgroundColor": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setBadgeText": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "browsingData": {
                "remove": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "removeCache": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCookies": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeDownloads": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFormData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeHistory": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeLocalStorage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePasswords": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removePluginData": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "settings": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "commands": {
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "contextMenus": {
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "cookies": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAllCookieStores": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "devtools": {
                "inspectedWindow": {
                  "eval": {
                    "minArgs": 1,
                    "maxArgs": 2,
                    "singleCallbackArg": false
                  }
                },
                "panels": {
                  "create": {
                    "minArgs": 3,
                    "maxArgs": 3,
                    "singleCallbackArg": true
                  },
                  "elements": {
                    "createSidebarPane": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  }
                }
              },
              "downloads": {
                "cancel": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "download": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "erase": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFileIcon": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "open": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "pause": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeFile": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "resume": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "extension": {
                "isAllowedFileSchemeAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "isAllowedIncognitoAccess": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "history": {
                "addUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "deleteRange": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "deleteUrl": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getVisits": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "search": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "i18n": {
                "detectLanguage": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAcceptLanguages": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "identity": {
                "launchWebAuthFlow": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "idle": {
                "queryState": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "management": {
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getSelf": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "setEnabled": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "uninstallSelf": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "notifications": {
                "clear": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPermissionLevel": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              },
              "pageAction": {
                "getPopup": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getTitle": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "hide": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setIcon": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "setPopup": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "setTitle": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                },
                "show": {
                  "minArgs": 1,
                  "maxArgs": 1,
                  "fallbackToNoCallback": true
                }
              },
              "permissions": {
                "contains": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "request": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "runtime": {
                "getBackgroundPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getPlatformInfo": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "openOptionsPage": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "requestUpdateCheck": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "sendMessage": {
                  "minArgs": 1,
                  "maxArgs": 3
                },
                "sendNativeMessage": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "setUninstallURL": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "sessions": {
                "getDevices": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getRecentlyClosed": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "restore": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "storage": {
                "local": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                },
                "managed": {
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  }
                },
                "sync": {
                  "clear": {
                    "minArgs": 0,
                    "maxArgs": 0
                  },
                  "get": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "getBytesInUse": {
                    "minArgs": 0,
                    "maxArgs": 1
                  },
                  "remove": {
                    "minArgs": 1,
                    "maxArgs": 1
                  },
                  "set": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              },
              "tabs": {
                "captureVisibleTab": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "create": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "detectLanguage": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "discard": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "duplicate": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "executeScript": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "getZoom": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getZoomSettings": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goBack": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "goForward": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "highlight": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "insertCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "move": {
                  "minArgs": 2,
                  "maxArgs": 2
                },
                "query": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "reload": {
                  "minArgs": 0,
                  "maxArgs": 2
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "removeCSS": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "sendMessage": {
                  "minArgs": 2,
                  "maxArgs": 3
                },
                "setZoom": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "setZoomSettings": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "update": {
                  "minArgs": 1,
                  "maxArgs": 2
                }
              },
              "topSites": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "webNavigation": {
                "getAllFrames": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "getFrame": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "webRequest": {
                "handlerBehaviorChanged": {
                  "minArgs": 0,
                  "maxArgs": 0
                }
              },
              "windows": {
                "create": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "get": {
                  "minArgs": 1,
                  "maxArgs": 2
                },
                "getAll": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getCurrent": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getLastFocused": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "update": {
                  "minArgs": 2,
                  "maxArgs": 2
                }
              }
            };
            if (Object.keys(apiMetadata).length === 0) {
              throw new Error("api-metadata.json has not been included in browser-polyfill");
            }
            class DefaultWeakMap extends WeakMap {
              constructor(createItem, items = void 0) {
                super(items);
                this.createItem = createItem;
              }
              get(key) {
                if (!this.has(key)) {
                  this.set(key, this.createItem(key));
                }
                return super.get(key);
              }
            }
            const isThenable = (value) => {
              return value && typeof value === "object" && typeof value.then === "function";
            };
            const makeCallback = (promise, metadata) => {
              return (...callbackArgs) => {
                if (extensionAPIs.runtime.lastError) {
                  promise.reject(new Error(extensionAPIs.runtime.lastError.message));
                } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                  promise.resolve(callbackArgs[0]);
                } else {
                  promise.resolve(callbackArgs);
                }
              };
            };
            const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
            const wrapAsyncFunction = (name, metadata) => {
              return function asyncFunctionWrapper(target, ...args) {
                if (args.length < metadata.minArgs) {
                  throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                }
                if (args.length > metadata.maxArgs) {
                  throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                }
                return new Promise((resolve, reject) => {
                  if (metadata.fallbackToNoCallback) {
                    try {
                      target[name](...args, makeCallback({
                        resolve,
                        reject
                      }, metadata));
                    } catch (cbError) {
                      console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                      target[name](...args);
                      metadata.fallbackToNoCallback = false;
                      metadata.noCallback = true;
                      resolve();
                    }
                  } else if (metadata.noCallback) {
                    target[name](...args);
                    resolve();
                  } else {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  }
                });
              };
            };
            const wrapMethod = (target, method, wrapper) => {
              return new Proxy(method, {
                apply(targetMethod, thisObj, args) {
                  return wrapper.call(thisObj, target, ...args);
                }
              });
            };
            let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
            const wrapObject = (target, wrappers = {}, metadata = {}) => {
              let cache2 = /* @__PURE__ */ Object.create(null);
              let handlers = {
                has(proxyTarget2, prop) {
                  return prop in target || prop in cache2;
                },
                get(proxyTarget2, prop, receiver) {
                  if (prop in cache2) {
                    return cache2[prop];
                  }
                  if (!(prop in target)) {
                    return void 0;
                  }
                  let value = target[prop];
                  if (typeof value === "function") {
                    if (typeof wrappers[prop] === "function") {
                      value = wrapMethod(target, target[prop], wrappers[prop]);
                    } else if (hasOwnProperty(metadata, prop)) {
                      let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                      value = wrapMethod(target, target[prop], wrapper);
                    } else {
                      value = value.bind(target);
                    }
                  } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
                    value = wrapObject(value, wrappers[prop], metadata[prop]);
                  } else if (hasOwnProperty(metadata, "*")) {
                    value = wrapObject(value, wrappers[prop], metadata["*"]);
                  } else {
                    Object.defineProperty(cache2, prop, {
                      configurable: true,
                      enumerable: true,
                      get() {
                        return target[prop];
                      },
                      set(value2) {
                        target[prop] = value2;
                      }
                    });
                    return value;
                  }
                  cache2[prop] = value;
                  return value;
                },
                set(proxyTarget2, prop, value, receiver) {
                  if (prop in cache2) {
                    cache2[prop] = value;
                  } else {
                    target[prop] = value;
                  }
                  return true;
                },
                defineProperty(proxyTarget2, prop, desc) {
                  return Reflect.defineProperty(cache2, prop, desc);
                },
                deleteProperty(proxyTarget2, prop) {
                  return Reflect.deleteProperty(cache2, prop);
                }
              };
              let proxyTarget = Object.create(target);
              return new Proxy(proxyTarget, handlers);
            };
            const wrapEvent = (wrapperMap) => ({
              addListener(target, listener, ...args) {
                target.addListener(wrapperMap.get(listener), ...args);
              },
              hasListener(target, listener) {
                return target.hasListener(wrapperMap.get(listener));
              },
              removeListener(target, listener) {
                target.removeListener(wrapperMap.get(listener));
              }
            });
            const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onRequestFinished(req) {
                const wrappedReq = wrapObject(
                  req,
                  {},
                  {
                    getContent: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  }
                );
                listener(wrappedReq);
              };
            });
            const onMessageWrappers = new DefaultWeakMap((listener) => {
              if (typeof listener !== "function") {
                return listener;
              }
              return function onMessage(message, sender, sendResponse) {
                let didCallSendResponse = false;
                let wrappedSendResponse;
                let sendResponsePromise = new Promise((resolve) => {
                  wrappedSendResponse = function(response) {
                    didCallSendResponse = true;
                    resolve(response);
                  };
                });
                let result;
                try {
                  result = listener(message, sender, wrappedSendResponse);
                } catch (err) {
                  result = Promise.reject(err);
                }
                const isResultThenable = result !== true && isThenable(result);
                if (result !== true && !isResultThenable && !didCallSendResponse) {
                  return false;
                }
                const sendPromisedResult = (promise) => {
                  promise.then((msg) => {
                    sendResponse(msg);
                  }, (error) => {
                    let message2;
                    if (error && (error instanceof Error || typeof error.message === "string")) {
                      message2 = error.message;
                    } else {
                      message2 = "An unexpected error occurred";
                    }
                    sendResponse({
                      __mozWebExtensionPolyfillReject__: true,
                      message: message2
                    });
                  }).catch((err) => {
                    console.error("Failed to send onMessage rejected reply", err);
                  });
                };
                if (isResultThenable) {
                  sendPromisedResult(result);
                } else {
                  sendPromisedResult(sendResponsePromise);
                }
                return true;
              };
            });
            const wrappedSendMessageCallback = ({
              reject,
              resolve
            }, reply) => {
              if (extensionAPIs.runtime.lastError) {
                if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                  resolve();
                } else {
                  reject(new Error(extensionAPIs.runtime.lastError.message));
                }
              } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
                reject(new Error(reply.message));
              } else {
                resolve(reply);
              }
            };
            const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                const wrappedCb = wrappedSendMessageCallback.bind(null, {
                  resolve,
                  reject
                });
                args.push(wrappedCb);
                apiNamespaceObj.sendMessage(...args);
              });
            };
            const staticWrappers = {
              devtools: {
                network: {
                  onRequestFinished: wrapEvent(onRequestFinishedWrappers)
                }
              },
              runtime: {
                onMessage: wrapEvent(onMessageWrappers),
                onMessageExternal: wrapEvent(onMessageWrappers),
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 1,
                  maxArgs: 3
                })
              },
              tabs: {
                sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                  minArgs: 2,
                  maxArgs: 3
                })
              }
            };
            const settingMetadata = {
              clear: {
                minArgs: 1,
                maxArgs: 1
              },
              get: {
                minArgs: 1,
                maxArgs: 1
              },
              set: {
                minArgs: 1,
                maxArgs: 1
              }
            };
            apiMetadata.privacy = {
              network: {
                "*": settingMetadata
              },
              services: {
                "*": settingMetadata
              },
              websites: {
                "*": settingMetadata
              }
            };
            return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
          };
          module2.exports = wrapAPIs(chrome);
        } else {
          module2.exports = globalThis.browser;
        }
      });
    }
  });

  // node_modules/p-defer/index.js
  var require_p_defer = __commonJS({
    "node_modules/p-defer/index.js"(exports, module) {
      "use strict";
      module.exports = () => {
        const ret = {};
        ret.promise = new Promise((resolve, reject) => {
          ret.resolve = resolve;
          ret.reject = reject;
        });
        return ret;
      };
    }
  });

  // node_modules/map-age-cleaner/dist/index.js
  var require_dist = __commonJS({
    "node_modules/map-age-cleaner/dist/index.js"(exports, module) {
      "use strict";
      var pDefer = require_p_defer();
      function mapAgeCleaner(map, property = "maxAge") {
        let processingKey;
        let processingTimer;
        let processingDeferred;
        const cleanup = async () => {
          if (processingKey !== void 0) {
            return;
          }
          const setupTimer = async (item) => {
            processingDeferred = pDefer();
            const delay = item[1][property] - Date.now();
            if (delay <= 0) {
              map.delete(item[0]);
              processingDeferred.resolve();
              return;
            }
            processingKey = item[0];
            processingTimer = setTimeout(() => {
              map.delete(item[0]);
              if (processingDeferred) {
                processingDeferred.resolve();
              }
            }, delay);
            if (typeof processingTimer.unref === "function") {
              processingTimer.unref();
            }
            return processingDeferred.promise;
          };
          try {
            for (const entry of map) {
              await setupTimer(entry);
            }
          } catch (_a) {
          }
          processingKey = void 0;
        };
        const reset = () => {
          processingKey = void 0;
          if (processingTimer !== void 0) {
            clearTimeout(processingTimer);
            processingTimer = void 0;
          }
          if (processingDeferred !== void 0) {
            processingDeferred.reject(void 0);
            processingDeferred = void 0;
          }
        };
        const originalSet = map.set.bind(map);
        map.set = (key, value) => {
          if (map.has(key)) {
            map.delete(key);
          }
          const result = originalSet(key, value);
          if (processingKey && processingKey === key) {
            reset();
          }
          cleanup();
          return result;
        };
        cleanup();
        return map;
      }
      module.exports = mapAgeCleaner;
    }
  });

  // node_modules/expiry-map/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/expiry-map/dist/index.js"(exports, module) {
      "use strict";
      var mapAgeCleaner = require_dist();
      var ExpiryMap2 = class {
        constructor(maxAge, data) {
          this.maxAge = maxAge;
          this[Symbol.toStringTag] = "Map";
          this.data = /* @__PURE__ */ new Map();
          mapAgeCleaner(this.data);
          if (data) {
            for (const [key, value] of data) {
              this.set(key, value);
            }
          }
        }
        get size() {
          return this.data.size;
        }
        clear() {
          this.data.clear();
        }
        delete(key) {
          return this.data.delete(key);
        }
        has(key) {
          return this.data.has(key);
        }
        get(key) {
          const value = this.data.get(key);
          if (value) {
            return value.data;
          }
          return;
        }
        set(key, value) {
          this.data.set(key, {
            maxAge: Date.now() + this.maxAge,
            data: value
          });
          return this;
        }
        values() {
          return this.createIterator((item) => item[1].data);
        }
        keys() {
          return this.data.keys();
        }
        entries() {
          return this.createIterator((item) => [item[0], item[1].data]);
        }
        forEach(callbackfn, thisArg) {
          for (const [key, value] of this.entries()) {
            callbackfn.apply(thisArg, [value, key, this]);
          }
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        *createIterator(projection) {
          for (const item of this.data.entries()) {
            yield projection(item);
          }
        }
      };
      module.exports = ExpiryMap2;
    }
  });

  // node_modules/core-js/library/modules/_global.js
  var require_global = __commonJS({
    "node_modules/core-js/library/modules/_global.js"(exports, module) {
      var global2 = module.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
      if (typeof __g == "number")
        __g = global2;
    }
  });

  // node_modules/core-js/library/modules/_has.js
  var require_has = __commonJS({
    "node_modules/core-js/library/modules/_has.js"(exports, module) {
      var hasOwnProperty = {}.hasOwnProperty;
      module.exports = function(it, key) {
        return hasOwnProperty.call(it, key);
      };
    }
  });

  // node_modules/core-js/library/modules/_fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/library/modules/_fails.js"(exports, module) {
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/library/modules/_descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/library/modules/_descriptors.js"(exports, module) {
      module.exports = !require_fails()(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }
  });

  // node_modules/core-js/library/modules/_core.js
  var require_core = __commonJS({
    "node_modules/core-js/library/modules/_core.js"(exports, module) {
      var core = module.exports = { version: "2.6.12" };
      if (typeof __e == "number")
        __e = core;
    }
  });

  // node_modules/core-js/library/modules/_a-function.js
  var require_a_function = __commonJS({
    "node_modules/core-js/library/modules/_a-function.js"(exports, module) {
      module.exports = function(it) {
        if (typeof it != "function")
          throw TypeError(it + " is not a function!");
        return it;
      };
    }
  });

  // node_modules/core-js/library/modules/_ctx.js
  var require_ctx = __commonJS({
    "node_modules/core-js/library/modules/_ctx.js"(exports, module) {
      var aFunction = require_a_function();
      module.exports = function(fn, that, length) {
        aFunction(fn);
        if (that === void 0)
          return fn;
        switch (length) {
          case 1:
            return function(a) {
              return fn.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function(a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/library/modules/_is-object.js"(exports, module) {
      module.exports = function(it) {
        return typeof it === "object" ? it !== null : typeof it === "function";
      };
    }
  });

  // node_modules/core-js/library/modules/_an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/library/modules/_an-object.js"(exports, module) {
      var isObject = require_is_object();
      module.exports = function(it) {
        if (!isObject(it))
          throw TypeError(it + " is not an object!");
        return it;
      };
    }
  });

  // node_modules/core-js/library/modules/_dom-create.js
  var require_dom_create = __commonJS({
    "node_modules/core-js/library/modules/_dom-create.js"(exports, module) {
      var isObject = require_is_object();
      var document2 = require_global().document;
      var is = isObject(document2) && isObject(document2.createElement);
      module.exports = function(it) {
        return is ? document2.createElement(it) : {};
      };
    }
  });

  // node_modules/core-js/library/modules/_ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/library/modules/_ie8-dom-define.js"(exports, module) {
      module.exports = !require_descriptors() && !require_fails()(function() {
        return Object.defineProperty(require_dom_create()("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
    }
  });

  // node_modules/core-js/library/modules/_to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/library/modules/_to-primitive.js"(exports, module) {
      var isObject = require_is_object();
      module.exports = function(it, S) {
        if (!isObject(it))
          return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
          return val;
        if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
          return val;
        if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
          return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }
  });

  // node_modules/core-js/library/modules/_object-dp.js
  var require_object_dp = __commonJS({
    "node_modules/core-js/library/modules/_object-dp.js"(exports) {
      var anObject = require_an_object();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var toPrimitive = require_to_primitive();
      var dP = Object.defineProperty;
      exports.f = require_descriptors() ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return dP(O, P, Attributes);
          } catch (e) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw TypeError("Accessors not supported!");
        if ("value" in Attributes)
          O[P] = Attributes.value;
        return O;
      };
    }
  });

  // node_modules/core-js/library/modules/_property-desc.js
  var require_property_desc = __commonJS({
    "node_modules/core-js/library/modules/_property-desc.js"(exports, module) {
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_hide.js
  var require_hide = __commonJS({
    "node_modules/core-js/library/modules/_hide.js"(exports, module) {
      var dP = require_object_dp();
      var createDesc = require_property_desc();
      module.exports = require_descriptors() ? function(object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  });

  // node_modules/core-js/library/modules/_export.js
  var require_export = __commonJS({
    "node_modules/core-js/library/modules/_export.js"(exports, module) {
      var global2 = require_global();
      var core = require_core();
      var ctx = require_ctx();
      var hide = require_hide();
      var has = require_has();
      var PROTOTYPE = "prototype";
      var $export = function(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var IS_WRAP = type & $export.W;
        var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = exports2[PROTOTYPE];
        var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
        var key, own, out;
        if (IS_GLOBAL)
          source = name;
        for (key in source) {
          own = !IS_FORCED && target && target[key] !== void 0;
          if (own && has(exports2, key))
            continue;
          out = own ? target[key] : source[key];
          exports2[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C) {
            var F = function(a, b, c) {
              if (this instanceof C) {
                switch (arguments.length) {
                  case 0:
                    return new C();
                  case 1:
                    return new C(a);
                  case 2:
                    return new C(a, b);
                }
                return new C(a, b, c);
              }
              return C.apply(this, arguments);
            };
            F[PROTOTYPE] = C[PROTOTYPE];
            return F;
          }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
          if (IS_PROTO) {
            (exports2.virtual || (exports2.virtual = {}))[key] = out;
            if (type & $export.R && expProto && !expProto[key])
              hide(expProto, key, out);
          }
        }
      };
      $export.F = 1;
      $export.G = 2;
      $export.S = 4;
      $export.P = 8;
      $export.B = 16;
      $export.W = 32;
      $export.U = 64;
      $export.R = 128;
      module.exports = $export;
    }
  });

  // node_modules/core-js/library/modules/_redefine.js
  var require_redefine = __commonJS({
    "node_modules/core-js/library/modules/_redefine.js"(exports, module) {
      module.exports = require_hide();
    }
  });

  // node_modules/core-js/library/modules/_uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/library/modules/_uid.js"(exports, module) {
      var id = 0;
      var px = Math.random();
      module.exports = function(key) {
        return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
      };
    }
  });

  // node_modules/core-js/library/modules/_meta.js
  var require_meta = __commonJS({
    "node_modules/core-js/library/modules/_meta.js"(exports, module) {
      var META = require_uid()("meta");
      var isObject = require_is_object();
      var has = require_has();
      var setDesc = require_object_dp().f;
      var id = 0;
      var isExtensible = Object.isExtensible || function() {
        return true;
      };
      var FREEZE = !require_fails()(function() {
        return isExtensible(Object.preventExtensions({}));
      });
      var setMeta = function(it) {
        setDesc(it, META, { value: {
          i: "O" + ++id,
          // object ID
          w: {}
          // weak collections IDs
        } });
      };
      var fastKey = function(it, create) {
        if (!isObject(it))
          return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
        if (!has(it, META)) {
          if (!isExtensible(it))
            return "F";
          if (!create)
            return "E";
          setMeta(it);
        }
        return it[META].i;
      };
      var getWeak = function(it, create) {
        if (!has(it, META)) {
          if (!isExtensible(it))
            return true;
          if (!create)
            return false;
          setMeta(it);
        }
        return it[META].w;
      };
      var onFreeze = function(it) {
        if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
          setMeta(it);
        return it;
      };
      var meta = module.exports = {
        KEY: META,
        NEED: false,
        fastKey,
        getWeak,
        onFreeze
      };
    }
  });

  // node_modules/core-js/library/modules/_library.js
  var require_library = __commonJS({
    "node_modules/core-js/library/modules/_library.js"(exports, module) {
      module.exports = true;
    }
  });

  // node_modules/core-js/library/modules/_shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/library/modules/_shared.js"(exports, module) {
      var core = require_core();
      var global2 = require_global();
      var SHARED = "__core-js_shared__";
      var store = global2[SHARED] || (global2[SHARED] = {});
      (module.exports = function(key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: core.version,
        mode: require_library() ? "pure" : "global",
        copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
      });
    }
  });

  // node_modules/core-js/library/modules/_wks.js
  var require_wks = __commonJS({
    "node_modules/core-js/library/modules/_wks.js"(exports, module) {
      var store = require_shared()("wks");
      var uid = require_uid();
      var Symbol2 = require_global().Symbol;
      var USE_SYMBOL = typeof Symbol2 == "function";
      var $exports = module.exports = function(name) {
        return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
      };
      $exports.store = store;
    }
  });

  // node_modules/core-js/library/modules/_set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/library/modules/_set-to-string-tag.js"(exports, module) {
      var def = require_object_dp().f;
      var has = require_has();
      var TAG = require_wks()("toStringTag");
      module.exports = function(it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG))
          def(it, TAG, { configurable: true, value: tag });
      };
    }
  });

  // node_modules/core-js/library/modules/_wks-ext.js
  var require_wks_ext = __commonJS({
    "node_modules/core-js/library/modules/_wks-ext.js"(exports) {
      exports.f = require_wks();
    }
  });

  // node_modules/core-js/library/modules/_wks-define.js
  var require_wks_define = __commonJS({
    "node_modules/core-js/library/modules/_wks-define.js"(exports, module) {
      var global2 = require_global();
      var core = require_core();
      var LIBRARY = require_library();
      var wksExt = require_wks_ext();
      var defineProperty = require_object_dp().f;
      module.exports = function(name) {
        var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global2.Symbol || {});
        if (name.charAt(0) != "_" && !(name in $Symbol))
          defineProperty($Symbol, name, { value: wksExt.f(name) });
      };
    }
  });

  // node_modules/core-js/library/modules/_cof.js
  var require_cof = __commonJS({
    "node_modules/core-js/library/modules/_cof.js"(exports, module) {
      var toString = {}.toString;
      module.exports = function(it) {
        return toString.call(it).slice(8, -1);
      };
    }
  });

  // node_modules/core-js/library/modules/_iobject.js
  var require_iobject = __commonJS({
    "node_modules/core-js/library/modules/_iobject.js"(exports, module) {
      var cof = require_cof();
      module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
        return cof(it) == "String" ? it.split("") : Object(it);
      };
    }
  });

  // node_modules/core-js/library/modules/_defined.js
  var require_defined = __commonJS({
    "node_modules/core-js/library/modules/_defined.js"(exports, module) {
      module.exports = function(it) {
        if (it == void 0)
          throw TypeError("Can't call method on  " + it);
        return it;
      };
    }
  });

  // node_modules/core-js/library/modules/_to-iobject.js
  var require_to_iobject = __commonJS({
    "node_modules/core-js/library/modules/_to-iobject.js"(exports, module) {
      var IObject = require_iobject();
      var defined = require_defined();
      module.exports = function(it) {
        return IObject(defined(it));
      };
    }
  });

  // node_modules/core-js/library/modules/_to-integer.js
  var require_to_integer = __commonJS({
    "node_modules/core-js/library/modules/_to-integer.js"(exports, module) {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = function(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }
  });

  // node_modules/core-js/library/modules/_to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/library/modules/_to-length.js"(exports, module) {
      var toInteger = require_to_integer();
      var min = Math.min;
      module.exports = function(it) {
        return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
      };
    }
  });

  // node_modules/core-js/library/modules/_to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/library/modules/_to-absolute-index.js"(exports, module) {
      var toInteger = require_to_integer();
      var max = Math.max;
      var min = Math.min;
      module.exports = function(index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }
  });

  // node_modules/core-js/library/modules/_array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/library/modules/_array-includes.js"(exports, module) {
      var toIObject = require_to_iobject();
      var toLength = require_to_length();
      var toAbsoluteIndex = require_to_absolute_index();
      module.exports = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIObject($this);
          var length = toLength(O.length);
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el != el)
            while (length > index) {
              value = O[index++];
              if (value != value)
                return true;
            }
          else
            for (; length > index; index++)
              if (IS_INCLUDES || index in O) {
                if (O[index] === el)
                  return IS_INCLUDES || index || 0;
              }
          return !IS_INCLUDES && -1;
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/library/modules/_shared-key.js"(exports, module) {
      var shared = require_shared()("keys");
      var uid = require_uid();
      module.exports = function(key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }
  });

  // node_modules/core-js/library/modules/_object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/library/modules/_object-keys-internal.js"(exports, module) {
      var has = require_has();
      var toIObject = require_to_iobject();
      var arrayIndexOf = require_array_includes()(false);
      var IE_PROTO = require_shared_key()("IE_PROTO");
      module.exports = function(object, names) {
        var O = toIObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O)
          if (key != IE_PROTO)
            has(O, key) && result.push(key);
        while (names.length > i)
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        return result;
      };
    }
  });

  // node_modules/core-js/library/modules/_enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/library/modules/_enum-bug-keys.js"(exports, module) {
      module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }
  });

  // node_modules/core-js/library/modules/_object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/library/modules/_object-keys.js"(exports, module) {
      var $keys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }
  });

  // node_modules/core-js/library/modules/_object-gops.js
  var require_object_gops = __commonJS({
    "node_modules/core-js/library/modules/_object-gops.js"(exports) {
      exports.f = Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/library/modules/_object-pie.js
  var require_object_pie = __commonJS({
    "node_modules/core-js/library/modules/_object-pie.js"(exports) {
      exports.f = {}.propertyIsEnumerable;
    }
  });

  // node_modules/core-js/library/modules/_enum-keys.js
  var require_enum_keys = __commonJS({
    "node_modules/core-js/library/modules/_enum-keys.js"(exports, module) {
      var getKeys = require_object_keys();
      var gOPS = require_object_gops();
      var pIE = require_object_pie();
      module.exports = function(it) {
        var result = getKeys(it);
        var getSymbols = gOPS.f;
        if (getSymbols) {
          var symbols = getSymbols(it);
          var isEnum = pIE.f;
          var i = 0;
          var key;
          while (symbols.length > i)
            if (isEnum.call(it, key = symbols[i++]))
              result.push(key);
        }
        return result;
      };
    }
  });

  // node_modules/core-js/library/modules/_is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/library/modules/_is-array.js"(exports, module) {
      var cof = require_cof();
      module.exports = Array.isArray || function isArray(arg) {
        return cof(arg) == "Array";
      };
    }
  });

  // node_modules/core-js/library/modules/_to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/library/modules/_to-object.js"(exports, module) {
      var defined = require_defined();
      module.exports = function(it) {
        return Object(defined(it));
      };
    }
  });

  // node_modules/core-js/library/modules/_object-dps.js
  var require_object_dps = __commonJS({
    "node_modules/core-js/library/modules/_object-dps.js"(exports, module) {
      var dP = require_object_dp();
      var anObject = require_an_object();
      var getKeys = require_object_keys();
      module.exports = require_descriptors() ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;
        while (length > i)
          dP.f(O, P = keys[i++], Properties[P]);
        return O;
      };
    }
  });

  // node_modules/core-js/library/modules/_html.js
  var require_html = __commonJS({
    "node_modules/core-js/library/modules/_html.js"(exports, module) {
      var document2 = require_global().document;
      module.exports = document2 && document2.documentElement;
    }
  });

  // node_modules/core-js/library/modules/_object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/library/modules/_object-create.js"(exports, module) {
      var anObject = require_an_object();
      var dPs = require_object_dps();
      var enumBugKeys = require_enum_bug_keys();
      var IE_PROTO = require_shared_key()("IE_PROTO");
      var Empty = function() {
      };
      var PROTOTYPE = "prototype";
      var createDict = function() {
        var iframe = require_dom_create()("iframe");
        var i = enumBugKeys.length;
        var lt = "<";
        var gt = ">";
        var iframeDocument;
        iframe.style.display = "none";
        require_html().appendChild(iframe);
        iframe.src = "javascript:";
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
        iframeDocument.close();
        createDict = iframeDocument.F;
        while (i--)
          delete createDict[PROTOTYPE][enumBugKeys[i]];
        return createDict();
      };
      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else
          result = createDict();
        return Properties === void 0 ? result : dPs(result, Properties);
      };
    }
  });

  // node_modules/core-js/library/modules/_object-gopn.js
  var require_object_gopn = __commonJS({
    "node_modules/core-js/library/modules/_object-gopn.js"(exports) {
      var $keys = require_object_keys_internal();
      var hiddenKeys = require_enum_bug_keys().concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return $keys(O, hiddenKeys);
      };
    }
  });

  // node_modules/core-js/library/modules/_object-gopn-ext.js
  var require_object_gopn_ext = __commonJS({
    "node_modules/core-js/library/modules/_object-gopn-ext.js"(exports, module) {
      var toIObject = require_to_iobject();
      var gOPN = require_object_gopn().f;
      var toString = {}.toString;
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return gOPN(it);
        } catch (e) {
          return windowNames.slice();
        }
      };
      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
      };
    }
  });

  // node_modules/core-js/library/modules/_object-gopd.js
  var require_object_gopd = __commonJS({
    "node_modules/core-js/library/modules/_object-gopd.js"(exports) {
      var pIE = require_object_pie();
      var createDesc = require_property_desc();
      var toIObject = require_to_iobject();
      var toPrimitive = require_to_primitive();
      var has = require_has();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var gOPD = Object.getOwnPropertyDescriptor;
      exports.f = require_descriptors() ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = toIObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE)
          try {
            return gOPD(O, P);
          } catch (e) {
          }
        if (has(O, P))
          return createDesc(!pIE.f.call(O, P), O[P]);
      };
    }
  });

  // node_modules/core-js/library/modules/es6.symbol.js
  var require_es6_symbol = __commonJS({
    "node_modules/core-js/library/modules/es6.symbol.js"() {
      "use strict";
      var global2 = require_global();
      var has = require_has();
      var DESCRIPTORS = require_descriptors();
      var $export = require_export();
      var redefine = require_redefine();
      var META = require_meta().KEY;
      var $fails = require_fails();
      var shared = require_shared();
      var setToStringTag = require_set_to_string_tag();
      var uid = require_uid();
      var wks = require_wks();
      var wksExt = require_wks_ext();
      var wksDefine = require_wks_define();
      var enumKeys = require_enum_keys();
      var isArray = require_is_array();
      var anObject = require_an_object();
      var isObject = require_is_object();
      var toObject = require_to_object();
      var toIObject = require_to_iobject();
      var toPrimitive = require_to_primitive();
      var createDesc = require_property_desc();
      var _create = require_object_create();
      var gOPNExt = require_object_gopn_ext();
      var $GOPD = require_object_gopd();
      var $GOPS = require_object_gops();
      var $DP = require_object_dp();
      var $keys = require_object_keys();
      var gOPD = $GOPD.f;
      var dP = $DP.f;
      var gOPN = gOPNExt.f;
      var $Symbol = global2.Symbol;
      var $JSON = global2.JSON;
      var _stringify = $JSON && $JSON.stringify;
      var PROTOTYPE = "prototype";
      var HIDDEN = wks("_hidden");
      var TO_PRIMITIVE = wks("toPrimitive");
      var isEnum = {}.propertyIsEnumerable;
      var SymbolRegistry = shared("symbol-registry");
      var AllSymbols = shared("symbols");
      var OPSymbols = shared("op-symbols");
      var ObjectProto = Object[PROTOTYPE];
      var USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f;
      var QObject = global2.QObject;
      var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var setSymbolDesc = DESCRIPTORS && $fails(function() {
        return _create(dP({}, "a", {
          get: function() {
            return dP(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(it, key, D) {
        var protoDesc = gOPD(ObjectProto, key);
        if (protoDesc)
          delete ObjectProto[key];
        dP(it, key, D);
        if (protoDesc && it !== ObjectProto)
          dP(ObjectProto, key, protoDesc);
      } : dP;
      var wrap = function(tag) {
        var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
        sym._k = tag;
        return sym;
      };
      var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        return it instanceof $Symbol;
      };
      var $defineProperty = function defineProperty(it, key, D) {
        if (it === ObjectProto)
          $defineProperty(OPSymbols, key, D);
        anObject(it);
        key = toPrimitive(key, true);
        anObject(D);
        if (has(AllSymbols, key)) {
          if (!D.enumerable) {
            if (!has(it, HIDDEN))
              dP(it, HIDDEN, createDesc(1, {}));
            it[HIDDEN][key] = true;
          } else {
            if (has(it, HIDDEN) && it[HIDDEN][key])
              it[HIDDEN][key] = false;
            D = _create(D, { enumerable: createDesc(0, false) });
          }
          return setSymbolDesc(it, key, D);
        }
        return dP(it, key, D);
      };
      var $defineProperties = function defineProperties(it, P) {
        anObject(it);
        var keys = enumKeys(P = toIObject(P));
        var i = 0;
        var l = keys.length;
        var key;
        while (l > i)
          $defineProperty(it, key = keys[i++], P[key]);
        return it;
      };
      var $create = function create(it, P) {
        return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(key) {
        var E = isEnum.call(this, key = toPrimitive(key, true));
        if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
          return false;
        return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
        it = toIObject(it);
        key = toPrimitive(key, true);
        if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
          return;
        var D = gOPD(it, key);
        if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
          D.enumerable = true;
        return D;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(it) {
        var names = gOPN(toIObject(it));
        var result = [];
        var i = 0;
        var key;
        while (names.length > i) {
          if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
            result.push(key);
        }
        return result;
      };
      var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
        var IS_OP = it === ObjectProto;
        var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
        var result = [];
        var i = 0;
        var key;
        while (names.length > i) {
          if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
            result.push(AllSymbols[key]);
        }
        return result;
      };
      if (!USE_NATIVE) {
        $Symbol = function Symbol2() {
          if (this instanceof $Symbol)
            throw TypeError("Symbol is not a constructor!");
          var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
          var $set = function(value) {
            if (this === ObjectProto)
              $set.call(OPSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag))
              this[HIDDEN][tag] = false;
            setSymbolDesc(this, tag, createDesc(1, value));
          };
          if (DESCRIPTORS && setter)
            setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
          return wrap(tag);
        };
        redefine($Symbol[PROTOTYPE], "toString", function toString() {
          return this._k;
        });
        $GOPD.f = $getOwnPropertyDescriptor;
        $DP.f = $defineProperty;
        require_object_gopn().f = gOPNExt.f = $getOwnPropertyNames;
        require_object_pie().f = $propertyIsEnumerable;
        $GOPS.f = $getOwnPropertySymbols;
        if (DESCRIPTORS && !require_library()) {
          redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
        }
        wksExt.f = function(name) {
          return wrap(wks(name));
        };
      }
      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
      for (es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
      "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
        wks(es6Symbols[j++]);
      var es6Symbols;
      var j;
      for (wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; )
        wksDefine(wellKnownSymbols[k++]);
      var wellKnownSymbols;
      var k;
      $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
        // 19.4.2.1 Symbol.for(key)
        "for": function(key) {
          return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym))
            throw TypeError(sym + " is not a symbol!");
          for (var key in SymbolRegistry)
            if (SymbolRegistry[key] === sym)
              return key;
        },
        useSetter: function() {
          setter = true;
        },
        useSimple: function() {
          setter = false;
        }
      });
      $export($export.S + $export.F * !USE_NATIVE, "Object", {
        // 19.1.2.2 Object.create(O [, Properties])
        create: $create,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: $defineProperty,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: $defineProperties,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: $getOwnPropertyNames,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: $getOwnPropertySymbols
      });
      var FAILS_ON_PRIMITIVES = $fails(function() {
        $GOPS.f(1);
      });
      $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          return $GOPS.f(toObject(it));
        }
      });
      $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
        var S = $Symbol();
        return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
      })), "JSON", {
        stringify: function stringify(it) {
          var args = [it];
          var i = 1;
          var replacer, $replacer;
          while (arguments.length > i)
            args.push(arguments[i++]);
          $replacer = replacer = args[1];
          if (!isObject(replacer) && it === void 0 || isSymbol(it))
            return;
          if (!isArray(replacer))
            replacer = function(key, value) {
              if (typeof $replacer == "function")
                value = $replacer.call(this, key, value);
              if (!isSymbol(value))
                return value;
            };
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        }
      });
      $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
      setToStringTag($Symbol, "Symbol");
      setToStringTag(Math, "Math", true);
      setToStringTag(global2.JSON, "JSON", true);
    }
  });

  // node_modules/core-js/library/modules/es6.object.to-string.js
  var require_es6_object_to_string = __commonJS({
    "node_modules/core-js/library/modules/es6.object.to-string.js"() {
    }
  });

  // node_modules/core-js/library/modules/es7.symbol.async-iterator.js
  var require_es7_symbol_async_iterator = __commonJS({
    "node_modules/core-js/library/modules/es7.symbol.async-iterator.js"() {
      require_wks_define()("asyncIterator");
    }
  });

  // node_modules/core-js/library/modules/es7.symbol.observable.js
  var require_es7_symbol_observable = __commonJS({
    "node_modules/core-js/library/modules/es7.symbol.observable.js"() {
      require_wks_define()("observable");
    }
  });

  // node_modules/core-js/library/fn/symbol/index.js
  var require_symbol = __commonJS({
    "node_modules/core-js/library/fn/symbol/index.js"(exports, module) {
      require_es6_symbol();
      require_es6_object_to_string();
      require_es7_symbol_async_iterator();
      require_es7_symbol_observable();
      module.exports = require_core().Symbol;
    }
  });

  // node_modules/core-js/library/modules/_string-at.js
  var require_string_at = __commonJS({
    "node_modules/core-js/library/modules/_string-at.js"(exports, module) {
      var toInteger = require_to_integer();
      var defined = require_defined();
      module.exports = function(TO_STRING) {
        return function(that, pos) {
          var s = String(defined(that));
          var i = toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l)
            return TO_STRING ? "" : void 0;
          a = s.charCodeAt(i);
          return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/library/modules/_iterators.js"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/core-js/library/modules/_iter-create.js
  var require_iter_create = __commonJS({
    "node_modules/core-js/library/modules/_iter-create.js"(exports, module) {
      "use strict";
      var create = require_object_create();
      var descriptor = require_property_desc();
      var setToStringTag = require_set_to_string_tag();
      var IteratorPrototype = {};
      require_hide()(IteratorPrototype, require_wks()("iterator"), function() {
        return this;
      });
      module.exports = function(Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
        setToStringTag(Constructor, NAME + " Iterator");
      };
    }
  });

  // node_modules/core-js/library/modules/_object-gpo.js
  var require_object_gpo = __commonJS({
    "node_modules/core-js/library/modules/_object-gpo.js"(exports, module) {
      var has = require_has();
      var toObject = require_to_object();
      var IE_PROTO = require_shared_key()("IE_PROTO");
      var ObjectProto = Object.prototype;
      module.exports = Object.getPrototypeOf || function(O) {
        O = toObject(O);
        if (has(O, IE_PROTO))
          return O[IE_PROTO];
        if (typeof O.constructor == "function" && O instanceof O.constructor) {
          return O.constructor.prototype;
        }
        return O instanceof Object ? ObjectProto : null;
      };
    }
  });

  // node_modules/core-js/library/modules/_iter-define.js
  var require_iter_define = __commonJS({
    "node_modules/core-js/library/modules/_iter-define.js"(exports, module) {
      "use strict";
      var LIBRARY = require_library();
      var $export = require_export();
      var redefine = require_redefine();
      var hide = require_hide();
      var Iterators = require_iterators();
      var $iterCreate = require_iter_create();
      var setToStringTag = require_set_to_string_tag();
      var getPrototypeOf = require_object_gpo();
      var ITERATOR = require_wks()("iterator");
      var BUGGY = !([].keys && "next" in [].keys());
      var FF_ITERATOR = "@@iterator";
      var KEYS = "keys";
      var VALUES = "values";
      var returnThis = function() {
        return this;
      };
      module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);
        var getMethod = function(kind) {
          if (!BUGGY && kind in proto)
            return proto[kind];
          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };
            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }
          return function entries() {
            return new Constructor(this, kind);
          };
        };
        var TAG = NAME + " Iterator";
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
        var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
        var methods, key, IteratorPrototype;
        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            setToStringTag(IteratorPrototype, TAG, true);
            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
              hide(IteratorPrototype, ITERATOR, returnThis);
          }
        }
        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;
          $default = function values() {
            return $native.call(this);
          };
        }
        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        }
        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;
        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED)
            for (key in methods) {
              if (!(key in proto))
                redefine(proto, key, methods[key]);
            }
          else
            $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }
        return methods;
      };
    }
  });

  // node_modules/core-js/library/modules/es6.string.iterator.js
  var require_es6_string_iterator = __commonJS({
    "node_modules/core-js/library/modules/es6.string.iterator.js"() {
      "use strict";
      var $at = require_string_at()(true);
      require_iter_define()(String, "String", function(iterated) {
        this._t = String(iterated);
        this._i = 0;
      }, function() {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length)
          return { value: void 0, done: true };
        point = $at(O, index);
        this._i += point.length;
        return { value: point, done: false };
      });
    }
  });

  // node_modules/core-js/library/modules/_add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/library/modules/_add-to-unscopables.js"(exports, module) {
      module.exports = function() {
      };
    }
  });

  // node_modules/core-js/library/modules/_iter-step.js
  var require_iter_step = __commonJS({
    "node_modules/core-js/library/modules/_iter-step.js"(exports, module) {
      module.exports = function(done, value) {
        return { value, done: !!done };
      };
    }
  });

  // node_modules/core-js/library/modules/es6.array.iterator.js
  var require_es6_array_iterator = __commonJS({
    "node_modules/core-js/library/modules/es6.array.iterator.js"(exports, module) {
      "use strict";
      var addToUnscopables = require_add_to_unscopables();
      var step = require_iter_step();
      var Iterators = require_iterators();
      var toIObject = require_to_iobject();
      module.exports = require_iter_define()(Array, "Array", function(iterated, kind) {
        this._t = toIObject(iterated);
        this._i = 0;
        this._k = kind;
      }, function() {
        var O = this._t;
        var kind = this._k;
        var index = this._i++;
        if (!O || index >= O.length) {
          this._t = void 0;
          return step(1);
        }
        if (kind == "keys")
          return step(0, index);
        if (kind == "values")
          return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, "values");
      Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
    }
  });

  // node_modules/core-js/library/modules/web.dom.iterable.js
  var require_web_dom_iterable = __commonJS({
    "node_modules/core-js/library/modules/web.dom.iterable.js"() {
      require_es6_array_iterator();
      var global2 = require_global();
      var hide = require_hide();
      var Iterators = require_iterators();
      var TO_STRING_TAG = require_wks()("toStringTag");
      var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
      for (i = 0; i < DOMIterables.length; i++) {
        NAME = DOMIterables[i];
        Collection = global2[NAME];
        proto = Collection && Collection.prototype;
        if (proto && !proto[TO_STRING_TAG])
          hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = Iterators.Array;
      }
      var NAME;
      var Collection;
      var proto;
      var i;
    }
  });

  // node_modules/core-js/library/fn/symbol/iterator.js
  var require_iterator = __commonJS({
    "node_modules/core-js/library/fn/symbol/iterator.js"(exports, module) {
      require_es6_string_iterator();
      require_web_dom_iterable();
      module.exports = require_wks_ext().f("iterator");
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/typeof.js"(exports, module) {
      var _Symbol = require_symbol();
      var _Symbol$iterator = require_iterator();
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof _Symbol && obj2.constructor === _Symbol && obj2 !== _Symbol.prototype ? "symbol" : typeof obj2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
      }
      module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/core-js/library/modules/es6.object.define-property.js
  var require_es6_object_define_property = __commonJS({
    "node_modules/core-js/library/modules/es6.object.define-property.js"() {
      var $export = require_export();
      $export($export.S + $export.F * !require_descriptors(), "Object", { defineProperty: require_object_dp().f });
    }
  });

  // node_modules/core-js/library/fn/object/define-property.js
  var require_define_property = __commonJS({
    "node_modules/core-js/library/fn/object/define-property.js"(exports, module) {
      require_es6_object_define_property();
      var $Object = require_core().Object;
      module.exports = function defineProperty(it, key, desc) {
        return $Object.defineProperty(it, key, desc);
      };
    }
  });

  // node_modules/core-js/library/modules/es6.object.create.js
  var require_es6_object_create = __commonJS({
    "node_modules/core-js/library/modules/es6.object.create.js"() {
      var $export = require_export();
      $export($export.S, "Object", { create: require_object_create() });
    }
  });

  // node_modules/core-js/library/fn/object/create.js
  var require_create = __commonJS({
    "node_modules/core-js/library/fn/object/create.js"(exports, module) {
      require_es6_object_create();
      var $Object = require_core().Object;
      module.exports = function create(P, D) {
        return $Object.create(P, D);
      };
    }
  });

  // node_modules/core-js/library/modules/_object-sap.js
  var require_object_sap = __commonJS({
    "node_modules/core-js/library/modules/_object-sap.js"(exports, module) {
      var $export = require_export();
      var core = require_core();
      var fails = require_fails();
      module.exports = function(KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY];
        var exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function() {
          fn(1);
        }), "Object", exp);
      };
    }
  });

  // node_modules/core-js/library/modules/es6.object.get-prototype-of.js
  var require_es6_object_get_prototype_of = __commonJS({
    "node_modules/core-js/library/modules/es6.object.get-prototype-of.js"() {
      var toObject = require_to_object();
      var $getPrototypeOf = require_object_gpo();
      require_object_sap()("getPrototypeOf", function() {
        return function getPrototypeOf(it) {
          return $getPrototypeOf(toObject(it));
        };
      });
    }
  });

  // node_modules/core-js/library/fn/object/get-prototype-of.js
  var require_get_prototype_of = __commonJS({
    "node_modules/core-js/library/fn/object/get-prototype-of.js"(exports, module) {
      require_es6_object_get_prototype_of();
      module.exports = require_core().Object.getPrototypeOf;
    }
  });

  // node_modules/core-js/library/modules/_set-proto.js
  var require_set_proto = __commonJS({
    "node_modules/core-js/library/modules/_set-proto.js"(exports, module) {
      var isObject = require_is_object();
      var anObject = require_an_object();
      var check = function(O, proto) {
        anObject(O);
        if (!isObject(proto) && proto !== null)
          throw TypeError(proto + ": can't set as prototype!");
      };
      module.exports = {
        set: Object.setPrototypeOf || ("__proto__" in {} ? (
          // eslint-disable-line
          function(test, buggy, set) {
            try {
              set = require_ctx()(Function.call, require_object_gopd().f(Object.prototype, "__proto__").set, 2);
              set(test, []);
              buggy = !(test instanceof Array);
            } catch (e) {
              buggy = true;
            }
            return function setPrototypeOf(O, proto) {
              check(O, proto);
              if (buggy)
                O.__proto__ = proto;
              else
                set(O, proto);
              return O;
            };
          }({}, false)
        ) : void 0),
        check
      };
    }
  });

  // node_modules/core-js/library/modules/es6.object.set-prototype-of.js
  var require_es6_object_set_prototype_of = __commonJS({
    "node_modules/core-js/library/modules/es6.object.set-prototype-of.js"() {
      var $export = require_export();
      $export($export.S, "Object", { setPrototypeOf: require_set_proto().set });
    }
  });

  // node_modules/core-js/library/fn/object/set-prototype-of.js
  var require_set_prototype_of = __commonJS({
    "node_modules/core-js/library/fn/object/set-prototype-of.js"(exports, module) {
      require_es6_object_set_prototype_of();
      module.exports = require_core().Object.setPrototypeOf;
    }
  });

  // node_modules/core-js/library/modules/_classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/library/modules/_classof.js"(exports, module) {
      var cof = require_cof();
      var TAG = require_wks()("toStringTag");
      var ARG = cof(function() {
        return arguments;
      }()) == "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (e) {
        }
      };
      module.exports = function(it) {
        var O, T, B;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
      };
    }
  });

  // node_modules/core-js/library/modules/_an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/library/modules/_an-instance.js"(exports, module) {
      module.exports = function(it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
          throw TypeError(name + ": incorrect invocation!");
        }
        return it;
      };
    }
  });

  // node_modules/core-js/library/modules/_iter-call.js
  var require_iter_call = __commonJS({
    "node_modules/core-js/library/modules/_iter-call.js"(exports, module) {
      var anObject = require_an_object();
      module.exports = function(iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value);
        } catch (e) {
          var ret = iterator["return"];
          if (ret !== void 0)
            anObject(ret.call(iterator));
          throw e;
        }
      };
    }
  });

  // node_modules/core-js/library/modules/_is-array-iter.js
  var require_is_array_iter = __commonJS({
    "node_modules/core-js/library/modules/_is-array-iter.js"(exports, module) {
      var Iterators = require_iterators();
      var ITERATOR = require_wks()("iterator");
      var ArrayProto = Array.prototype;
      module.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }
  });

  // node_modules/core-js/library/modules/core.get-iterator-method.js
  var require_core_get_iterator_method = __commonJS({
    "node_modules/core-js/library/modules/core.get-iterator-method.js"(exports, module) {
      var classof = require_classof();
      var ITERATOR = require_wks()("iterator");
      var Iterators = require_iterators();
      module.exports = require_core().getIteratorMethod = function(it) {
        if (it != void 0)
          return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
      };
    }
  });

  // node_modules/core-js/library/modules/_for-of.js
  var require_for_of = __commonJS({
    "node_modules/core-js/library/modules/_for-of.js"(exports, module) {
      var ctx = require_ctx();
      var call = require_iter_call();
      var isArrayIter = require_is_array_iter();
      var anObject = require_an_object();
      var toLength = require_to_length();
      var getIterFn = require_core_get_iterator_method();
      var BREAK = {};
      var RETURN = {};
      var exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
        var iterFn = ITERATOR ? function() {
          return iterable;
        } : getIterFn(iterable);
        var f = ctx(fn, that, entries ? 2 : 1);
        var index = 0;
        var length, step, iterator, result;
        if (typeof iterFn != "function")
          throw TypeError(iterable + " is not iterable!");
        if (isArrayIter(iterFn))
          for (length = toLength(iterable.length); length > index; index++) {
            result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
            if (result === BREAK || result === RETURN)
              return result;
          }
        else
          for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
            result = call(iterator, f, step.value, entries);
            if (result === BREAK || result === RETURN)
              return result;
          }
      };
      exports.BREAK = BREAK;
      exports.RETURN = RETURN;
    }
  });

  // node_modules/core-js/library/modules/_species-constructor.js
  var require_species_constructor = __commonJS({
    "node_modules/core-js/library/modules/_species-constructor.js"(exports, module) {
      var anObject = require_an_object();
      var aFunction = require_a_function();
      var SPECIES = require_wks()("species");
      module.exports = function(O, D) {
        var C = anObject(O).constructor;
        var S;
        return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
      };
    }
  });

  // node_modules/core-js/library/modules/_invoke.js
  var require_invoke = __commonJS({
    "node_modules/core-js/library/modules/_invoke.js"(exports, module) {
      module.exports = function(fn, args, that) {
        var un = that === void 0;
        switch (args.length) {
          case 0:
            return un ? fn() : fn.call(that);
          case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);
          case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
          case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
          case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
        }
        return fn.apply(that, args);
      };
    }
  });

  // node_modules/core-js/library/modules/_task.js
  var require_task = __commonJS({
    "node_modules/core-js/library/modules/_task.js"(exports, module) {
      var ctx = require_ctx();
      var invoke = require_invoke();
      var html = require_html();
      var cel = require_dom_create();
      var global2 = require_global();
      var process = global2.process;
      var setTask = global2.setImmediate;
      var clearTask = global2.clearImmediate;
      var MessageChannel = global2.MessageChannel;
      var Dispatch = global2.Dispatch;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var defer;
      var channel;
      var port;
      var run = function() {
        var id = +this;
        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var listener = function(event) {
        run.call(event.data);
      };
      if (!setTask || !clearTask) {
        setTask = function setImmediate(fn) {
          var args = [];
          var i = 1;
          while (arguments.length > i)
            args.push(arguments[i++]);
          queue[++counter] = function() {
            invoke(typeof fn == "function" ? fn : Function(fn), args);
          };
          defer(counter);
          return counter;
        };
        clearTask = function clearImmediate(id) {
          delete queue[id];
        };
        if (require_cof()(process) == "process") {
          defer = function(id) {
            process.nextTick(ctx(run, id, 1));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function(id) {
            Dispatch.now(ctx(run, id, 1));
          };
        } else if (MessageChannel) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = ctx(port.postMessage, port, 1);
        } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
          defer = function(id) {
            global2.postMessage(id + "", "*");
          };
          global2.addEventListener("message", listener, false);
        } else if (ONREADYSTATECHANGE in cel("script")) {
          defer = function(id) {
            html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run.call(id);
            };
          };
        } else {
          defer = function(id) {
            setTimeout(ctx(run, id, 1), 0);
          };
        }
      }
      module.exports = {
        set: setTask,
        clear: clearTask
      };
    }
  });

  // node_modules/core-js/library/modules/_microtask.js
  var require_microtask = __commonJS({
    "node_modules/core-js/library/modules/_microtask.js"(exports, module) {
      var global2 = require_global();
      var macrotask = require_task().set;
      var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
      var process = global2.process;
      var Promise2 = global2.Promise;
      var isNode = require_cof()(process) == "process";
      module.exports = function() {
        var head, last, notify;
        var flush = function() {
          var parent, fn;
          if (isNode && (parent = process.domain))
            parent.exit();
          while (head) {
            fn = head.fn;
            head = head.next;
            try {
              fn();
            } catch (e) {
              if (head)
                notify();
              else
                last = void 0;
              throw e;
            }
          }
          last = void 0;
          if (parent)
            parent.enter();
        };
        if (isNode) {
          notify = function() {
            process.nextTick(flush);
          };
        } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
          var toggle = true;
          var node = document.createTextNode("");
          new Observer(flush).observe(node, { characterData: true });
          notify = function() {
            node.data = toggle = !toggle;
          };
        } else if (Promise2 && Promise2.resolve) {
          var promise = Promise2.resolve(void 0);
          notify = function() {
            promise.then(flush);
          };
        } else {
          notify = function() {
            macrotask.call(global2, flush);
          };
        }
        return function(fn) {
          var task = { fn, next: void 0 };
          if (last)
            last.next = task;
          if (!head) {
            head = task;
            notify();
          }
          last = task;
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_new-promise-capability.js
  var require_new_promise_capability = __commonJS({
    "node_modules/core-js/library/modules/_new-promise-capability.js"(exports, module) {
      "use strict";
      var aFunction = require_a_function();
      function PromiseCapability(C) {
        var resolve, reject;
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0)
            throw TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      }
      module.exports.f = function(C) {
        return new PromiseCapability(C);
      };
    }
  });

  // node_modules/core-js/library/modules/_perform.js
  var require_perform = __commonJS({
    "node_modules/core-js/library/modules/_perform.js"(exports, module) {
      module.exports = function(exec) {
        try {
          return { e: false, v: exec() };
        } catch (e) {
          return { e: true, v: e };
        }
      };
    }
  });

  // node_modules/core-js/library/modules/_user-agent.js
  var require_user_agent = __commonJS({
    "node_modules/core-js/library/modules/_user-agent.js"(exports, module) {
      var global2 = require_global();
      var navigator2 = global2.navigator;
      module.exports = navigator2 && navigator2.userAgent || "";
    }
  });

  // node_modules/core-js/library/modules/_promise-resolve.js
  var require_promise_resolve = __commonJS({
    "node_modules/core-js/library/modules/_promise-resolve.js"(exports, module) {
      var anObject = require_an_object();
      var isObject = require_is_object();
      var newPromiseCapability = require_new_promise_capability();
      module.exports = function(C, x) {
        anObject(C);
        if (isObject(x) && x.constructor === C)
          return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }
  });

  // node_modules/core-js/library/modules/_redefine-all.js
  var require_redefine_all = __commonJS({
    "node_modules/core-js/library/modules/_redefine-all.js"(exports, module) {
      var hide = require_hide();
      module.exports = function(target, src, safe) {
        for (var key in src) {
          if (safe && target[key])
            target[key] = src[key];
          else
            hide(target, key, src[key]);
        }
        return target;
      };
    }
  });

  // node_modules/core-js/library/modules/_set-species.js
  var require_set_species = __commonJS({
    "node_modules/core-js/library/modules/_set-species.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var core = require_core();
      var dP = require_object_dp();
      var DESCRIPTORS = require_descriptors();
      var SPECIES = require_wks()("species");
      module.exports = function(KEY) {
        var C = typeof core[KEY] == "function" ? core[KEY] : global2[KEY];
        if (DESCRIPTORS && C && !C[SPECIES])
          dP.f(C, SPECIES, {
            configurable: true,
            get: function() {
              return this;
            }
          });
      };
    }
  });

  // node_modules/core-js/library/modules/_iter-detect.js
  var require_iter_detect = __commonJS({
    "node_modules/core-js/library/modules/_iter-detect.js"(exports, module) {
      var ITERATOR = require_wks()("iterator");
      var SAFE_CLOSING = false;
      try {
        riter = [7][ITERATOR]();
        riter["return"] = function() {
          SAFE_CLOSING = true;
        };
        Array.from(riter, function() {
          throw 2;
        });
      } catch (e) {
      }
      var riter;
      module.exports = function(exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING)
          return false;
        var safe = false;
        try {
          var arr = [7];
          var iter = arr[ITERATOR]();
          iter.next = function() {
            return { done: safe = true };
          };
          arr[ITERATOR] = function() {
            return iter;
          };
          exec(arr);
        } catch (e) {
        }
        return safe;
      };
    }
  });

  // node_modules/core-js/library/modules/es6.promise.js
  var require_es6_promise = __commonJS({
    "node_modules/core-js/library/modules/es6.promise.js"() {
      "use strict";
      var LIBRARY = require_library();
      var global2 = require_global();
      var ctx = require_ctx();
      var classof = require_classof();
      var $export = require_export();
      var isObject = require_is_object();
      var aFunction = require_a_function();
      var anInstance = require_an_instance();
      var forOf = require_for_of();
      var speciesConstructor = require_species_constructor();
      var task = require_task().set;
      var microtask = require_microtask()();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var userAgent = require_user_agent();
      var promiseResolve = require_promise_resolve();
      var PROMISE = "Promise";
      var TypeError2 = global2.TypeError;
      var process = global2.process;
      var versions = process && process.versions;
      var v8 = versions && versions.v8 || "";
      var $Promise = global2[PROMISE];
      var isNode = classof(process) == "process";
      var empty = function() {
      };
      var Internal;
      var newGenericPromiseCapability;
      var OwnPromiseCapability;
      var Wrapper;
      var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
      var USE_NATIVE = !!function() {
        try {
          var promise = $Promise.resolve(1);
          var FakePromise = (promise.constructor = {})[require_wks()("species")] = function(exec) {
            exec(empty, empty);
          };
          return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
        } catch (e) {
        }
      }();
      var isThenable = function(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == "function" ? then : false;
      };
      var notify = function(promise, isReject) {
        if (promise._n)
          return;
        promise._n = true;
        var chain = promise._c;
        microtask(function() {
          var value = promise._v;
          var ok = promise._s == 1;
          var i = 0;
          var run = function(reaction) {
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;
            try {
              if (handler) {
                if (!ok) {
                  if (promise._h == 2)
                    onHandleUnhandled(promise);
                  promise._h = 1;
                }
                if (handler === true)
                  result = value;
                else {
                  if (domain)
                    domain.enter();
                  result = handler(value);
                  if (domain) {
                    domain.exit();
                    exited = true;
                  }
                }
                if (result === reaction.promise) {
                  reject(TypeError2("Promise-chain cycle"));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else
                  resolve(result);
              } else
                reject(value);
            } catch (e) {
              if (domain && !exited)
                domain.exit();
              reject(e);
            }
          };
          while (chain.length > i)
            run(chain[i++]);
          promise._c = [];
          promise._n = false;
          if (isReject && !promise._h)
            onUnhandled(promise);
        });
      };
      var onUnhandled = function(promise) {
        task.call(global2, function() {
          var value = promise._v;
          var unhandled = isUnhandled(promise);
          var result, handler, console2;
          if (unhandled) {
            result = perform(function() {
              if (isNode) {
                process.emit("unhandledRejection", value, promise);
              } else if (handler = global2.onunhandledrejection) {
                handler({ promise, reason: value });
              } else if ((console2 = global2.console) && console2.error) {
                console2.error("Unhandled promise rejection", value);
              }
            });
            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
          }
          promise._a = void 0;
          if (unhandled && result.e)
            throw result.v;
        });
      };
      var isUnhandled = function(promise) {
        return promise._h !== 1 && (promise._a || promise._c).length === 0;
      };
      var onHandleUnhandled = function(promise) {
        task.call(global2, function() {
          var handler;
          if (isNode) {
            process.emit("rejectionHandled", promise);
          } else if (handler = global2.onrejectionhandled) {
            handler({ promise, reason: promise._v });
          }
        });
      };
      var $reject = function(value) {
        var promise = this;
        if (promise._d)
          return;
        promise._d = true;
        promise = promise._w || promise;
        promise._v = value;
        promise._s = 2;
        if (!promise._a)
          promise._a = promise._c.slice();
        notify(promise, true);
      };
      var $resolve = function(value) {
        var promise = this;
        var then;
        if (promise._d)
          return;
        promise._d = true;
        promise = promise._w || promise;
        try {
          if (promise === value)
            throw TypeError2("Promise can't be resolved itself");
          if (then = isThenable(value)) {
            microtask(function() {
              var wrapper = { _w: promise, _d: false };
              try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
              } catch (e) {
                $reject.call(wrapper, e);
              }
            });
          } else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
          }
        } catch (e) {
          $reject.call({ _w: promise, _d: false }, e);
        }
      };
      if (!USE_NATIVE) {
        $Promise = function Promise2(executor) {
          anInstance(this, $Promise, PROMISE, "_h");
          aFunction(executor);
          Internal.call(this);
          try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
          } catch (err) {
            $reject.call(this, err);
          }
        };
        Internal = function Promise2(executor) {
          this._c = [];
          this._a = void 0;
          this._s = 0;
          this._d = false;
          this._v = void 0;
          this._h = 0;
          this._n = false;
        };
        Internal.prototype = require_redefine_all()($Promise.prototype, {
          // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
          then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
            reaction.fail = typeof onRejected == "function" && onRejected;
            reaction.domain = isNode ? process.domain : void 0;
            this._c.push(reaction);
            if (this._a)
              this._a.push(reaction);
            if (this._s)
              notify(this, false);
            return reaction.promise;
          },
          // 25.4.5.1 Promise.prototype.catch(onRejected)
          "catch": function(onRejected) {
            return this.then(void 0, onRejected);
          }
        });
        OwnPromiseCapability = function() {
          var promise = new Internal();
          this.promise = promise;
          this.resolve = ctx($resolve, promise, 1);
          this.reject = ctx($reject, promise, 1);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
          return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
      }
      $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
      require_set_to_string_tag()($Promise, PROMISE);
      require_set_species()(PROMISE);
      Wrapper = require_core()[PROMISE];
      $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
        // 25.4.4.5 Promise.reject(r)
        reject: function reject(r) {
          var capability = newPromiseCapability(this);
          var $$reject = capability.reject;
          $$reject(r);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function resolve(x) {
          return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
        }
      });
      $export($export.S + $export.F * !(USE_NATIVE && require_iter_detect()(function(iter) {
        $Promise.all(iter)["catch"](empty);
      })), PROMISE, {
        // 25.4.4.1 Promise.all(iterable)
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var values = [];
            var index = 0;
            var remaining = 1;
            forOf(iterable, false, function(promise) {
              var $index = index++;
              var alreadyCalled = false;
              values.push(void 0);
              remaining++;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[$index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.e)
            reject(result.v);
          return capability.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var reject = capability.reject;
          var result = perform(function() {
            forOf(iterable, false, function(promise) {
              C.resolve(promise).then(capability.resolve, reject);
            });
          });
          if (result.e)
            reject(result.v);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/library/modules/es7.promise.finally.js
  var require_es7_promise_finally = __commonJS({
    "node_modules/core-js/library/modules/es7.promise.finally.js"() {
      "use strict";
      var $export = require_export();
      var core = require_core();
      var global2 = require_global();
      var speciesConstructor = require_species_constructor();
      var promiseResolve = require_promise_resolve();
      $export($export.P + $export.R, "Promise", { "finally": function(onFinally) {
        var C = speciesConstructor(this, core.Promise || global2.Promise);
        var isFunction = typeof onFinally == "function";
        return this.then(
          isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
              return x;
            });
          } : onFinally,
          isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
              throw e;
            });
          } : onFinally
        );
      } });
    }
  });

  // node_modules/core-js/library/modules/es7.promise.try.js
  var require_es7_promise_try = __commonJS({
    "node_modules/core-js/library/modules/es7.promise.try.js"() {
      "use strict";
      var $export = require_export();
      var newPromiseCapability = require_new_promise_capability();
      var perform = require_perform();
      $export($export.S, "Promise", { "try": function(callbackfn) {
        var promiseCapability = newPromiseCapability.f(this);
        var result = perform(callbackfn);
        (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
        return promiseCapability.promise;
      } });
    }
  });

  // node_modules/core-js/library/fn/promise.js
  var require_promise = __commonJS({
    "node_modules/core-js/library/fn/promise.js"(exports, module) {
      require_es6_object_to_string();
      require_es6_string_iterator();
      require_web_dom_iterable();
      require_es6_promise();
      require_es7_promise_finally();
      require_es7_promise_try();
      module.exports = require_core().Promise;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/regeneratorRuntime.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      var _Object$defineProperty = require_define_property();
      var _Symbol = require_symbol();
      var _Object$create = require_create();
      var _Object$getPrototypeOf = require_get_prototype_of();
      var _Object$setPrototypeOf = require_set_prototype_of();
      var _Promise = require_promise();
      function _regeneratorRuntime() {
        "use strict";
        module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
          return exports2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = _Object$defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        }, $Symbol = "function" == typeof _Symbol ? _Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key, value) {
          return _Object$defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          }), obj[key];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function define3(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = _Object$create(protoGenerator.prototype), context = new Context(tryLocsList || []);
          return defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self2, context)
          }), generator;
        }
        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }
        exports2.wrap = wrap;
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define2(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = _Object$getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = _Object$create(IteratorPrototype);
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define2(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
              var result = record.arg, value = result.value;
              return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
            reject(record.arg);
          }
          var previousPromise;
          defineProperty(this, "_invoke", {
            value: function value(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
          });
        }
        function makeInvokeMethod(innerFn, self2, context) {
          var state = "suspendedStart";
          return function(method, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method)
                throw arg;
              return doneResult();
            }
            for (context.method = method, context.arg = arg; ; ) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context.method)
                context.sent = context._sent = context.arg;
              else if ("throw" === context.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else
                "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self2, context);
              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                  continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }
              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method, method = delegate.iterator[methodName];
          if (void 0 === method)
            return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
          var record = tryCatch(method, delegate.iterator, context.arg);
          if ("throw" === record.type)
            return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
          var info = record.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal", delete record.arg, entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
        }
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod)
              return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next)
              return iterable;
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                for (; ++i < iterable.length; )
                  if (hasOwn.call(iterable, i))
                    return next2.value = iterable[i], next2.done = false, next2;
                return next2.value = void 0, next2.done = true, next2;
              };
              return next.next = next;
            }
          }
          return {
            next: doneResult
          };
        }
        function doneResult() {
          return {
            value: void 0,
            done: true
          };
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: true
        }), defineProperty(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: true
        }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports2.mark = function(genFun) {
          return _Object$setPrototypeOf ? _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = _Object$create(Gp), genFun;
        }, exports2.awrap = function(arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = _Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
          return this;
        }), define2(Gp, "toString", function() {
          return "[object Generator]";
        }), exports2.keys = function(val) {
          var object = Object(val), keys = [];
          for (var key in object)
            keys.push(key);
          return keys.reverse(), function next() {
            for (; keys.length; ) {
              var key2 = keys.pop();
              if (key2 in object)
                return next.value = key2, next.done = false, next;
            }
            return next.done = true, next;
          };
        }, exports2.values = values, Context.prototype = {
          constructor: Context,
          reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
              for (var name in this)
                "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          },
          stop: function stop() {
            this.done = true;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type)
              throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done)
              throw exception;
            var context = this;
            function handle(loc, caught) {
              return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i], record = entry.completion;
              if ("root" === entry.tryLoc)
                return handle("end");
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                } else {
                  if (!hasFinally)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
          },
          complete: function complete(record, afterLoc) {
            if ("throw" === record.type)
              throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc)
                return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if ("throw" === record.type) {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
          }
        }, exports2;
      }
      module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/regenerator/index.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime-corejs2/regenerator/index.js"(exports, module) {
      var runtime = require_regeneratorRuntime()();
      module.exports = runtime;
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/core-js/library/modules/es6.object.keys.js
  var require_es6_object_keys = __commonJS({
    "node_modules/core-js/library/modules/es6.object.keys.js"() {
      var toObject = require_to_object();
      var $keys = require_object_keys();
      require_object_sap()("keys", function() {
        return function keys(it) {
          return $keys(toObject(it));
        };
      });
    }
  });

  // node_modules/core-js/library/fn/object/keys.js
  var require_keys = __commonJS({
    "node_modules/core-js/library/fn/object/keys.js"(exports, module) {
      require_es6_object_keys();
      module.exports = require_core().Object.keys;
    }
  });

  // node_modules/core-js/library/fn/object/get-own-property-symbols.js
  var require_get_own_property_symbols = __commonJS({
    "node_modules/core-js/library/fn/object/get-own-property-symbols.js"(exports, module) {
      require_es6_symbol();
      module.exports = require_core().Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js
  var require_es6_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js"() {
      var toIObject = require_to_iobject();
      var $getOwnPropertyDescriptor = require_object_gopd().f;
      require_object_sap()("getOwnPropertyDescriptor", function() {
        return function getOwnPropertyDescriptor(it, key) {
          return $getOwnPropertyDescriptor(toIObject(it), key);
        };
      });
    }
  });

  // node_modules/core-js/library/fn/object/get-own-property-descriptor.js
  var require_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/library/fn/object/get-own-property-descriptor.js"(exports, module) {
      require_es6_object_get_own_property_descriptor();
      var $Object = require_core().Object;
      module.exports = function getOwnPropertyDescriptor(it, key) {
        return $Object.getOwnPropertyDescriptor(it, key);
      };
    }
  });

  // node_modules/core-js/library/fn/symbol/to-primitive.js
  var require_to_primitive2 = __commonJS({
    "node_modules/core-js/library/fn/symbol/to-primitive.js"(exports, module) {
      module.exports = require_wks_ext().f("toPrimitive");
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/toPrimitive.js"(exports, module) {
      var _Symbol$toPrimitive = require_to_primitive2();
      var _typeof = require_typeof()["default"];
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null)
          return input;
        var prim = input[_Symbol$toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object")
            return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/toPropertyKey.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      var toPrimitive = require_toPrimitive();
      function _toPropertyKey(arg) {
        var key = toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/defineProperty.js"(exports, module) {
      var _Object$defineProperty = require_define_property();
      var toPropertyKey = require_toPropertyKey();
      function _defineProperty(obj, key, value) {
        key = toPropertyKey(key);
        if (key in obj) {
          _Object$defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/objectSpread.js
  var require_objectSpread = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/objectSpread.js"(exports, module) {
      var _Object$keys = require_keys();
      var _Object$getOwnPropertySymbols = require_get_own_property_symbols();
      var _Object$getOwnPropertyDescriptor = require_get_own_property_descriptor();
      var defineProperty = require_defineProperty();
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? Object(arguments[i]) : {};
          var ownKeys = _Object$keys(source);
          if (typeof _Object$getOwnPropertySymbols === "function") {
            ownKeys.push.apply(ownKeys, _Object$getOwnPropertySymbols(source).filter(function(sym) {
              return _Object$getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys.forEach(function(key) {
            defineProperty(target, key, source[key]);
          });
        }
        return target;
      }
      module.exports = _objectSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/objectWithoutPropertiesLoose.js
  var require_objectWithoutPropertiesLoose = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
      var _Object$keys = require_keys();
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = _Object$keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/objectWithoutProperties.js
  var require_objectWithoutProperties = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/objectWithoutProperties.js"(exports, module) {
      var _Object$getOwnPropertySymbols = require_get_own_property_symbols();
      var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = objectWithoutPropertiesLoose(source, excluded);
        var key, i;
        if (_Object$getOwnPropertySymbols) {
          var sourceSymbolKeys = _Object$getOwnPropertySymbols(source);
          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js
  var require_asyncToGenerator = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js"(exports, module) {
      var _Promise = require_promise();
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          _Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new _Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/url/node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "node_modules/url/node_modules/punycode/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw RangeError(errors[type]);
        }
        function map(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i, w = 1, k = base; ; k += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error("overflow");
              }
              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return ucs2encode(output);
        }
        function encode(input) {
          var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n) {
                for (q = delta, k = base; ; k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(
                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                  );
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        }
        punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "1.3.2",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode;
          } else {
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          root.punycode = punycode;
        }
      })(exports);
    }
  });

  // node_modules/url/util.js
  var require_util = __commonJS({
    "node_modules/url/util.js"(exports, module) {
      "use strict";
      module.exports = {
        isString: function(arg) {
          return typeof arg === "string";
        },
        isObject: function(arg) {
          return typeof arg === "object" && arg !== null;
        },
        isNull: function(arg) {
          return arg === null;
        },
        isNullOrUndefined: function(arg) {
          return arg == null;
        }
      };
    }
  });

  // node_modules/querystring/decode.js
  var require_decode = __commonJS({
    "node_modules/querystring/decode.js"(exports, module) {
      "use strict";
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      module.exports = function(qs, sep, eq, options) {
        sep = sep || "&";
        eq = eq || "=";
        var obj = {};
        if (typeof qs !== "string" || qs.length === 0) {
          return obj;
        }
        var regexp = /\+/g;
        qs = qs.split(sep);
        var maxKeys = 1e3;
        if (options && typeof options.maxKeys === "number") {
          maxKeys = options.maxKeys;
        }
        var len = qs.length;
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }
        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = "";
          }
          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);
          if (!hasOwnProperty(obj, k)) {
            obj[k] = v;
          } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }
        return obj;
      };
    }
  });

  // node_modules/querystring/encode.js
  var require_encode = __commonJS({
    "node_modules/querystring/encode.js"(exports, module) {
      "use strict";
      var stringifyPrimitive = function(v) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "true" : "false";
          case "number":
            return isFinite(v) ? v : "";
          default:
            return "";
        }
      };
      module.exports = function(obj, sep, eq, name) {
        sep = sep || "&";
        eq = eq || "=";
        if (obj === null) {
          obj = void 0;
        }
        if (typeof obj === "object") {
          return Object.keys(obj).map(function(k) {
            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
            if (Array.isArray(obj[k])) {
              return obj[k].map(function(v) {
                return ks + encodeURIComponent(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
        }
        if (!name)
          return "";
        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
      };
    }
  });

  // node_modules/querystring/index.js
  var require_querystring = __commonJS({
    "node_modules/querystring/index.js"(exports) {
      "use strict";
      exports.decode = exports.parse = require_decode();
      exports.encode = exports.stringify = require_encode();
    }
  });

  // node_modules/url/url.js
  var require_url = __commonJS({
    "node_modules/url/url.js"(exports) {
      "use strict";
      var punycode = require_punycode();
      var util = require_util();
      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;
      exports.Url = Url;
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i;
      var portPattern = /:[0-9]*$/;
      var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
      var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
      var autoEscape = ["'"].concat(unwise);
      var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
      var hostEndingChars = ["/", "?", "#"];
      var hostnameMaxLen = 255;
      var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
      var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      var unsafeProtocol = {
        "javascript": true,
        "javascript:": true
      };
      var hostlessProtocol = {
        "javascript": true,
        "javascript:": true
      };
      var slashedProtocol = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      var querystring = require_querystring();
      function urlParse(url, parseQueryString, slashesDenoteHost) {
        if (url && util.isObject(url) && url instanceof Url)
          return url;
        var u = new Url();
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
      }
      Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
        if (!util.isString(url)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url = uSplit.join(splitter);
        var rest = url;
        rest = rest.trim();
        if (!slashesDenoteHost && url.split("#").length === 1) {
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            return this;
          }
        }
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars.length; i++) {
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (var i = 0; i < nonHostChars.length; i++) {
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          if (hostEnd === -1)
            hostEnd = rest.length;
          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost();
          this.hostname = this.hostname || "";
          var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part)
                continue;
              if (!part.match(hostnamePartPattern)) {
                var newpart = "";
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            this.hostname = punycode.toASCII(this.hostname);
          }
          var p = this.port ? ":" + this.port : "";
          var h = this.hostname || "";
          this.host = h + p;
          this.href += this.host;
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol[lowerProto]) {
          for (var i = 0, l = autoEscape.length; i < l; i++) {
            var ae = autoEscape[i];
            if (rest.indexOf(ae) === -1)
              continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash = rest.indexOf("#");
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        if (rest)
          this.pathname = rest;
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          var p = this.pathname || "";
          var s = this.search || "";
          this.path = p + s;
        }
        this.href = this.format();
        return this;
      };
      function urlFormat(obj) {
        if (util.isString(obj))
          obj = urlParse(obj);
        if (!(obj instanceof Url))
          return Url.prototype.format.call(obj);
        return obj.format();
      }
      Url.prototype.format = function() {
        var auth = this.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }
        var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
          query = querystring.stringify(this.query);
        }
        var search = this.search || query && "?" + query || "";
        if (protocol && protocol.substr(-1) !== ":")
          protocol += ":";
        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/")
            pathname = "/" + pathname;
        } else if (!host) {
          host = "";
        }
        if (hash && hash.charAt(0) !== "#")
          hash = "#" + hash;
        if (search && search.charAt(0) !== "?")
          search = "?" + search;
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");
        return protocol + host + pathname + search + hash;
      };
      function urlResolve(source, relative) {
        return urlParse(source, false, true).resolve(relative);
      }
      Url.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };
      function urlResolveObject(source, relative) {
        if (!source)
          return relative;
        return urlParse(source, false, true).resolveObject(relative);
      }
      Url.prototype.resolveObject = function(relative) {
        if (util.isString(relative)) {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result[rkey] = relative[rkey];
          }
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
              var k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()))
              ;
            if (!relative.host)
              relative.host = "";
            if (!relative.hostname)
              relative.hostname = "";
            if (relPath[0] !== "")
              relPath.unshift("");
            if (relPath.length < 2)
              relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "")
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "")
                relPath[0] = relative.host;
              else
                relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util.isNullOrUndefined(relative.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host)
          this.hostname = host;
      };
    }
  });

  // node_modules/@postlight/parser/node_modules/jquery/dist/jquery.min.js
  var require_jquery_min = __commonJS({
    "node_modules/@postlight/parser/node_modules/jquery/dist/jquery.min.js"(exports, module) {
      !function(e, t) {
        "use strict";
        "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, true) : function(e2) {
          if (!e2.document)
            throw new Error("jQuery requires a window with a document");
          return t(e2);
        } : t(e);
      }("undefined" != typeof window ? window : exports, function(C, e) {
        "use strict";
        var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function(e2) {
          return t.flat.call(e2);
        } : function(e2) {
          return t.concat.apply([], e2);
        }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function(e2) {
          return "function" == typeof e2 && "number" != typeof e2.nodeType && "function" != typeof e2.item;
        }, x = function(e2) {
          return null != e2 && e2 === e2.window;
        }, E = C.document, c = { type: true, src: true, nonce: true, noModule: true };
        function b(e2, t2, n2) {
          var r2, i2, o2 = (n2 = n2 || E).createElement("script");
          if (o2.text = e2, t2)
            for (r2 in c)
              (i2 = t2[r2] || t2.getAttribute && t2.getAttribute(r2)) && o2.setAttribute(r2, i2);
          n2.head.appendChild(o2).parentNode.removeChild(o2);
        }
        function w(e2) {
          return null == e2 ? e2 + "" : "object" == typeof e2 || "function" == typeof e2 ? n[o.call(e2)] || "object" : typeof e2;
        }
        var f = "3.6.0", S = function(e2, t2) {
          return new S.fn.init(e2, t2);
        };
        function p(e2) {
          var t2 = !!e2 && "length" in e2 && e2.length, n2 = w(e2);
          return !m(e2) && !x(e2) && ("array" === n2 || 0 === t2 || "number" == typeof t2 && 0 < t2 && t2 - 1 in e2);
        }
        S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function() {
          return s.call(this);
        }, get: function(e2) {
          return null == e2 ? s.call(this) : e2 < 0 ? this[e2 + this.length] : this[e2];
        }, pushStack: function(e2) {
          var t2 = S.merge(this.constructor(), e2);
          return t2.prevObject = this, t2;
        }, each: function(e2) {
          return S.each(this, e2);
        }, map: function(n2) {
          return this.pushStack(S.map(this, function(e2, t2) {
            return n2.call(e2, t2, e2);
          }));
        }, slice: function() {
          return this.pushStack(s.apply(this, arguments));
        }, first: function() {
          return this.eq(0);
        }, last: function() {
          return this.eq(-1);
        }, even: function() {
          return this.pushStack(S.grep(this, function(e2, t2) {
            return (t2 + 1) % 2;
          }));
        }, odd: function() {
          return this.pushStack(S.grep(this, function(e2, t2) {
            return t2 % 2;
          }));
        }, eq: function(e2) {
          var t2 = this.length, n2 = +e2 + (e2 < 0 ? t2 : 0);
          return this.pushStack(0 <= n2 && n2 < t2 ? [this[n2]] : []);
        }, end: function() {
          return this.prevObject || this.constructor();
        }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function() {
          var e2, t2, n2, r2, i2, o2, a2 = arguments[0] || {}, s2 = 1, u2 = arguments.length, l2 = false;
          for ("boolean" == typeof a2 && (l2 = a2, a2 = arguments[s2] || {}, s2++), "object" == typeof a2 || m(a2) || (a2 = {}), s2 === u2 && (a2 = this, s2--); s2 < u2; s2++)
            if (null != (e2 = arguments[s2]))
              for (t2 in e2)
                r2 = e2[t2], "__proto__" !== t2 && a2 !== r2 && (l2 && r2 && (S.isPlainObject(r2) || (i2 = Array.isArray(r2))) ? (n2 = a2[t2], o2 = i2 && !Array.isArray(n2) ? [] : i2 || S.isPlainObject(n2) ? n2 : {}, i2 = false, a2[t2] = S.extend(l2, o2, r2)) : void 0 !== r2 && (a2[t2] = r2));
          return a2;
        }, S.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: true, error: function(e2) {
          throw new Error(e2);
        }, noop: function() {
        }, isPlainObject: function(e2) {
          var t2, n2;
          return !(!e2 || "[object Object]" !== o.call(e2)) && (!(t2 = r(e2)) || "function" == typeof (n2 = v.call(t2, "constructor") && t2.constructor) && a.call(n2) === l);
        }, isEmptyObject: function(e2) {
          var t2;
          for (t2 in e2)
            return false;
          return true;
        }, globalEval: function(e2, t2, n2) {
          b(e2, { nonce: t2 && t2.nonce }, n2);
        }, each: function(e2, t2) {
          var n2, r2 = 0;
          if (p(e2)) {
            for (n2 = e2.length; r2 < n2; r2++)
              if (false === t2.call(e2[r2], r2, e2[r2]))
                break;
          } else
            for (r2 in e2)
              if (false === t2.call(e2[r2], r2, e2[r2]))
                break;
          return e2;
        }, makeArray: function(e2, t2) {
          var n2 = t2 || [];
          return null != e2 && (p(Object(e2)) ? S.merge(n2, "string" == typeof e2 ? [e2] : e2) : u.call(n2, e2)), n2;
        }, inArray: function(e2, t2, n2) {
          return null == t2 ? -1 : i.call(t2, e2, n2);
        }, merge: function(e2, t2) {
          for (var n2 = +t2.length, r2 = 0, i2 = e2.length; r2 < n2; r2++)
            e2[i2++] = t2[r2];
          return e2.length = i2, e2;
        }, grep: function(e2, t2, n2) {
          for (var r2 = [], i2 = 0, o2 = e2.length, a2 = !n2; i2 < o2; i2++)
            !t2(e2[i2], i2) !== a2 && r2.push(e2[i2]);
          return r2;
        }, map: function(e2, t2, n2) {
          var r2, i2, o2 = 0, a2 = [];
          if (p(e2))
            for (r2 = e2.length; o2 < r2; o2++)
              null != (i2 = t2(e2[o2], o2, n2)) && a2.push(i2);
          else
            for (o2 in e2)
              null != (i2 = t2(e2[o2], o2, n2)) && a2.push(i2);
          return g(a2);
        }, guid: 1, support: y }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e2, t2) {
          n["[object " + t2 + "]"] = t2.toLowerCase();
        });
        var d = function(n2) {
          var e2, d2, b2, o2, i2, h2, f2, g2, w2, u2, l2, T2, C2, a2, E2, v2, s2, c2, y2, S2 = "sizzle" + 1 * /* @__PURE__ */ new Date(), p2 = n2.document, k2 = 0, r2 = 0, m2 = ue2(), x2 = ue2(), A2 = ue2(), N2 = ue2(), j2 = function(e3, t3) {
            return e3 === t3 && (l2 = true), 0;
          }, D2 = {}.hasOwnProperty, t2 = [], q2 = t2.pop, L2 = t2.push, H2 = t2.push, O2 = t2.slice, P2 = function(e3, t3) {
            for (var n3 = 0, r3 = e3.length; n3 < r3; n3++)
              if (e3[n3] === t3)
                return n3;
            return -1;
          }, R2 = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M2 = "[\\x20\\t\\r\\n\\f]", I2 = "(?:\\\\[\\da-fA-F]{1,6}" + M2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W2 = "\\[" + M2 + "*(" + I2 + ")(?:" + M2 + "*([*^$|!~]?=)" + M2 + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + I2 + "))|)" + M2 + "*\\]", F2 = ":(" + I2 + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + W2 + ")*)|.*)\\)|)", B2 = new RegExp(M2 + "+", "g"), $3 = new RegExp("^" + M2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M2 + "+$", "g"), _2 = new RegExp("^" + M2 + "*," + M2 + "*"), z2 = new RegExp("^" + M2 + "*([>+~]|" + M2 + ")" + M2 + "*"), U2 = new RegExp(M2 + "|>"), X2 = new RegExp(F2), V2 = new RegExp("^" + I2 + "$"), G2 = { ID: new RegExp("^#(" + I2 + ")"), CLASS: new RegExp("^\\.(" + I2 + ")"), TAG: new RegExp("^(" + I2 + "|[*])"), ATTR: new RegExp("^" + W2), PSEUDO: new RegExp("^" + F2), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M2 + "*(even|odd|(([+-]|)(\\d*)n|)" + M2 + "*(?:([+-]|)" + M2 + "*(\\d+)|))" + M2 + "*\\)|)", "i"), bool: new RegExp("^(?:" + R2 + ")$", "i"), needsContext: new RegExp("^" + M2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M2 + "*((?:-\\d)?\\d*)" + M2 + "*\\)|)(?=[^-]|$)", "i") }, Y2 = /HTML$/i, Q2 = /^(?:input|select|textarea|button)$/i, J2 = /^h\d$/i, K2 = /^[^{]+\{\s*\[native \w/, Z2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee2 = /[+~]/, te2 = new RegExp("\\\\[\\da-fA-F]{1,6}" + M2 + "?|\\\\([^\\r\\n\\f])", "g"), ne2 = function(e3, t3) {
            var n3 = "0x" + e3.slice(1) - 65536;
            return t3 || (n3 < 0 ? String.fromCharCode(n3 + 65536) : String.fromCharCode(n3 >> 10 | 55296, 1023 & n3 | 56320));
          }, re2 = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie2 = function(e3, t3) {
            return t3 ? "\0" === e3 ? "\uFFFD" : e3.slice(0, -1) + "\\" + e3.charCodeAt(e3.length - 1).toString(16) + " " : "\\" + e3;
          }, oe2 = function() {
            T2();
          }, ae2 = be2(function(e3) {
            return true === e3.disabled && "fieldset" === e3.nodeName.toLowerCase();
          }, { dir: "parentNode", next: "legend" });
          try {
            H2.apply(t2 = O2.call(p2.childNodes), p2.childNodes), t2[p2.childNodes.length].nodeType;
          } catch (e3) {
            H2 = { apply: t2.length ? function(e4, t3) {
              L2.apply(e4, O2.call(t3));
            } : function(e4, t3) {
              var n3 = e4.length, r3 = 0;
              while (e4[n3++] = t3[r3++])
                ;
              e4.length = n3 - 1;
            } };
          }
          function se2(t3, e3, n3, r3) {
            var i3, o3, a3, s3, u3, l3, c3, f3 = e3 && e3.ownerDocument, p3 = e3 ? e3.nodeType : 9;
            if (n3 = n3 || [], "string" != typeof t3 || !t3 || 1 !== p3 && 9 !== p3 && 11 !== p3)
              return n3;
            if (!r3 && (T2(e3), e3 = e3 || C2, E2)) {
              if (11 !== p3 && (u3 = Z2.exec(t3)))
                if (i3 = u3[1]) {
                  if (9 === p3) {
                    if (!(a3 = e3.getElementById(i3)))
                      return n3;
                    if (a3.id === i3)
                      return n3.push(a3), n3;
                  } else if (f3 && (a3 = f3.getElementById(i3)) && y2(e3, a3) && a3.id === i3)
                    return n3.push(a3), n3;
                } else {
                  if (u3[2])
                    return H2.apply(n3, e3.getElementsByTagName(t3)), n3;
                  if ((i3 = u3[3]) && d2.getElementsByClassName && e3.getElementsByClassName)
                    return H2.apply(n3, e3.getElementsByClassName(i3)), n3;
                }
              if (d2.qsa && !N2[t3 + " "] && (!v2 || !v2.test(t3)) && (1 !== p3 || "object" !== e3.nodeName.toLowerCase())) {
                if (c3 = t3, f3 = e3, 1 === p3 && (U2.test(t3) || z2.test(t3))) {
                  (f3 = ee2.test(t3) && ye2(e3.parentNode) || e3) === e3 && d2.scope || ((s3 = e3.getAttribute("id")) ? s3 = s3.replace(re2, ie2) : e3.setAttribute("id", s3 = S2)), o3 = (l3 = h2(t3)).length;
                  while (o3--)
                    l3[o3] = (s3 ? "#" + s3 : ":scope") + " " + xe2(l3[o3]);
                  c3 = l3.join(",");
                }
                try {
                  return H2.apply(n3, f3.querySelectorAll(c3)), n3;
                } catch (e4) {
                  N2(t3, true);
                } finally {
                  s3 === S2 && e3.removeAttribute("id");
                }
              }
            }
            return g2(t3.replace($3, "$1"), e3, n3, r3);
          }
          function ue2() {
            var r3 = [];
            return function e3(t3, n3) {
              return r3.push(t3 + " ") > b2.cacheLength && delete e3[r3.shift()], e3[t3 + " "] = n3;
            };
          }
          function le2(e3) {
            return e3[S2] = true, e3;
          }
          function ce2(e3) {
            var t3 = C2.createElement("fieldset");
            try {
              return !!e3(t3);
            } catch (e4) {
              return false;
            } finally {
              t3.parentNode && t3.parentNode.removeChild(t3), t3 = null;
            }
          }
          function fe2(e3, t3) {
            var n3 = e3.split("|"), r3 = n3.length;
            while (r3--)
              b2.attrHandle[n3[r3]] = t3;
          }
          function pe2(e3, t3) {
            var n3 = t3 && e3, r3 = n3 && 1 === e3.nodeType && 1 === t3.nodeType && e3.sourceIndex - t3.sourceIndex;
            if (r3)
              return r3;
            if (n3) {
              while (n3 = n3.nextSibling)
                if (n3 === t3)
                  return -1;
            }
            return e3 ? 1 : -1;
          }
          function de2(t3) {
            return function(e3) {
              return "input" === e3.nodeName.toLowerCase() && e3.type === t3;
            };
          }
          function he2(n3) {
            return function(e3) {
              var t3 = e3.nodeName.toLowerCase();
              return ("input" === t3 || "button" === t3) && e3.type === n3;
            };
          }
          function ge2(t3) {
            return function(e3) {
              return "form" in e3 ? e3.parentNode && false === e3.disabled ? "label" in e3 ? "label" in e3.parentNode ? e3.parentNode.disabled === t3 : e3.disabled === t3 : e3.isDisabled === t3 || e3.isDisabled !== !t3 && ae2(e3) === t3 : e3.disabled === t3 : "label" in e3 && e3.disabled === t3;
            };
          }
          function ve2(a3) {
            return le2(function(o3) {
              return o3 = +o3, le2(function(e3, t3) {
                var n3, r3 = a3([], e3.length, o3), i3 = r3.length;
                while (i3--)
                  e3[n3 = r3[i3]] && (e3[n3] = !(t3[n3] = e3[n3]));
              });
            });
          }
          function ye2(e3) {
            return e3 && "undefined" != typeof e3.getElementsByTagName && e3;
          }
          for (e2 in d2 = se2.support = {}, i2 = se2.isXML = function(e3) {
            var t3 = e3 && e3.namespaceURI, n3 = e3 && (e3.ownerDocument || e3).documentElement;
            return !Y2.test(t3 || n3 && n3.nodeName || "HTML");
          }, T2 = se2.setDocument = function(e3) {
            var t3, n3, r3 = e3 ? e3.ownerDocument || e3 : p2;
            return r3 != C2 && 9 === r3.nodeType && r3.documentElement && (a2 = (C2 = r3).documentElement, E2 = !i2(C2), p2 != C2 && (n3 = C2.defaultView) && n3.top !== n3 && (n3.addEventListener ? n3.addEventListener("unload", oe2, false) : n3.attachEvent && n3.attachEvent("onunload", oe2)), d2.scope = ce2(function(e4) {
              return a2.appendChild(e4).appendChild(C2.createElement("div")), "undefined" != typeof e4.querySelectorAll && !e4.querySelectorAll(":scope fieldset div").length;
            }), d2.attributes = ce2(function(e4) {
              return e4.className = "i", !e4.getAttribute("className");
            }), d2.getElementsByTagName = ce2(function(e4) {
              return e4.appendChild(C2.createComment("")), !e4.getElementsByTagName("*").length;
            }), d2.getElementsByClassName = K2.test(C2.getElementsByClassName), d2.getById = ce2(function(e4) {
              return a2.appendChild(e4).id = S2, !C2.getElementsByName || !C2.getElementsByName(S2).length;
            }), d2.getById ? (b2.filter.ID = function(e4) {
              var t4 = e4.replace(te2, ne2);
              return function(e5) {
                return e5.getAttribute("id") === t4;
              };
            }, b2.find.ID = function(e4, t4) {
              if ("undefined" != typeof t4.getElementById && E2) {
                var n4 = t4.getElementById(e4);
                return n4 ? [n4] : [];
              }
            }) : (b2.filter.ID = function(e4) {
              var n4 = e4.replace(te2, ne2);
              return function(e5) {
                var t4 = "undefined" != typeof e5.getAttributeNode && e5.getAttributeNode("id");
                return t4 && t4.value === n4;
              };
            }, b2.find.ID = function(e4, t4) {
              if ("undefined" != typeof t4.getElementById && E2) {
                var n4, r4, i3, o3 = t4.getElementById(e4);
                if (o3) {
                  if ((n4 = o3.getAttributeNode("id")) && n4.value === e4)
                    return [o3];
                  i3 = t4.getElementsByName(e4), r4 = 0;
                  while (o3 = i3[r4++])
                    if ((n4 = o3.getAttributeNode("id")) && n4.value === e4)
                      return [o3];
                }
                return [];
              }
            }), b2.find.TAG = d2.getElementsByTagName ? function(e4, t4) {
              return "undefined" != typeof t4.getElementsByTagName ? t4.getElementsByTagName(e4) : d2.qsa ? t4.querySelectorAll(e4) : void 0;
            } : function(e4, t4) {
              var n4, r4 = [], i3 = 0, o3 = t4.getElementsByTagName(e4);
              if ("*" === e4) {
                while (n4 = o3[i3++])
                  1 === n4.nodeType && r4.push(n4);
                return r4;
              }
              return o3;
            }, b2.find.CLASS = d2.getElementsByClassName && function(e4, t4) {
              if ("undefined" != typeof t4.getElementsByClassName && E2)
                return t4.getElementsByClassName(e4);
            }, s2 = [], v2 = [], (d2.qsa = K2.test(C2.querySelectorAll)) && (ce2(function(e4) {
              var t4;
              a2.appendChild(e4).innerHTML = "<a id='" + S2 + "'></a><select id='" + S2 + "-\r\\' msallowcapture=''><option selected=''></option></select>", e4.querySelectorAll("[msallowcapture^='']").length && v2.push("[*^$]=" + M2 + `*(?:''|"")`), e4.querySelectorAll("[selected]").length || v2.push("\\[" + M2 + "*(?:value|" + R2 + ")"), e4.querySelectorAll("[id~=" + S2 + "-]").length || v2.push("~="), (t4 = C2.createElement("input")).setAttribute("name", ""), e4.appendChild(t4), e4.querySelectorAll("[name='']").length || v2.push("\\[" + M2 + "*name" + M2 + "*=" + M2 + `*(?:''|"")`), e4.querySelectorAll(":checked").length || v2.push(":checked"), e4.querySelectorAll("a#" + S2 + "+*").length || v2.push(".#.+[+~]"), e4.querySelectorAll("\\\f"), v2.push("[\\r\\n\\f]");
            }), ce2(function(e4) {
              e4.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var t4 = C2.createElement("input");
              t4.setAttribute("type", "hidden"), e4.appendChild(t4).setAttribute("name", "D"), e4.querySelectorAll("[name=d]").length && v2.push("name" + M2 + "*[*^$|!~]?="), 2 !== e4.querySelectorAll(":enabled").length && v2.push(":enabled", ":disabled"), a2.appendChild(e4).disabled = true, 2 !== e4.querySelectorAll(":disabled").length && v2.push(":enabled", ":disabled"), e4.querySelectorAll("*,:x"), v2.push(",.*:");
            })), (d2.matchesSelector = K2.test(c2 = a2.matches || a2.webkitMatchesSelector || a2.mozMatchesSelector || a2.oMatchesSelector || a2.msMatchesSelector)) && ce2(function(e4) {
              d2.disconnectedMatch = c2.call(e4, "*"), c2.call(e4, "[s!='']:x"), s2.push("!=", F2);
            }), v2 = v2.length && new RegExp(v2.join("|")), s2 = s2.length && new RegExp(s2.join("|")), t3 = K2.test(a2.compareDocumentPosition), y2 = t3 || K2.test(a2.contains) ? function(e4, t4) {
              var n4 = 9 === e4.nodeType ? e4.documentElement : e4, r4 = t4 && t4.parentNode;
              return e4 === r4 || !(!r4 || 1 !== r4.nodeType || !(n4.contains ? n4.contains(r4) : e4.compareDocumentPosition && 16 & e4.compareDocumentPosition(r4)));
            } : function(e4, t4) {
              if (t4) {
                while (t4 = t4.parentNode)
                  if (t4 === e4)
                    return true;
              }
              return false;
            }, j2 = t3 ? function(e4, t4) {
              if (e4 === t4)
                return l2 = true, 0;
              var n4 = !e4.compareDocumentPosition - !t4.compareDocumentPosition;
              return n4 || (1 & (n4 = (e4.ownerDocument || e4) == (t4.ownerDocument || t4) ? e4.compareDocumentPosition(t4) : 1) || !d2.sortDetached && t4.compareDocumentPosition(e4) === n4 ? e4 == C2 || e4.ownerDocument == p2 && y2(p2, e4) ? -1 : t4 == C2 || t4.ownerDocument == p2 && y2(p2, t4) ? 1 : u2 ? P2(u2, e4) - P2(u2, t4) : 0 : 4 & n4 ? -1 : 1);
            } : function(e4, t4) {
              if (e4 === t4)
                return l2 = true, 0;
              var n4, r4 = 0, i3 = e4.parentNode, o3 = t4.parentNode, a3 = [e4], s3 = [t4];
              if (!i3 || !o3)
                return e4 == C2 ? -1 : t4 == C2 ? 1 : i3 ? -1 : o3 ? 1 : u2 ? P2(u2, e4) - P2(u2, t4) : 0;
              if (i3 === o3)
                return pe2(e4, t4);
              n4 = e4;
              while (n4 = n4.parentNode)
                a3.unshift(n4);
              n4 = t4;
              while (n4 = n4.parentNode)
                s3.unshift(n4);
              while (a3[r4] === s3[r4])
                r4++;
              return r4 ? pe2(a3[r4], s3[r4]) : a3[r4] == p2 ? -1 : s3[r4] == p2 ? 1 : 0;
            }), C2;
          }, se2.matches = function(e3, t3) {
            return se2(e3, null, null, t3);
          }, se2.matchesSelector = function(e3, t3) {
            if (T2(e3), d2.matchesSelector && E2 && !N2[t3 + " "] && (!s2 || !s2.test(t3)) && (!v2 || !v2.test(t3)))
              try {
                var n3 = c2.call(e3, t3);
                if (n3 || d2.disconnectedMatch || e3.document && 11 !== e3.document.nodeType)
                  return n3;
              } catch (e4) {
                N2(t3, true);
              }
            return 0 < se2(t3, C2, null, [e3]).length;
          }, se2.contains = function(e3, t3) {
            return (e3.ownerDocument || e3) != C2 && T2(e3), y2(e3, t3);
          }, se2.attr = function(e3, t3) {
            (e3.ownerDocument || e3) != C2 && T2(e3);
            var n3 = b2.attrHandle[t3.toLowerCase()], r3 = n3 && D2.call(b2.attrHandle, t3.toLowerCase()) ? n3(e3, t3, !E2) : void 0;
            return void 0 !== r3 ? r3 : d2.attributes || !E2 ? e3.getAttribute(t3) : (r3 = e3.getAttributeNode(t3)) && r3.specified ? r3.value : null;
          }, se2.escape = function(e3) {
            return (e3 + "").replace(re2, ie2);
          }, se2.error = function(e3) {
            throw new Error("Syntax error, unrecognized expression: " + e3);
          }, se2.uniqueSort = function(e3) {
            var t3, n3 = [], r3 = 0, i3 = 0;
            if (l2 = !d2.detectDuplicates, u2 = !d2.sortStable && e3.slice(0), e3.sort(j2), l2) {
              while (t3 = e3[i3++])
                t3 === e3[i3] && (r3 = n3.push(i3));
              while (r3--)
                e3.splice(n3[r3], 1);
            }
            return u2 = null, e3;
          }, o2 = se2.getText = function(e3) {
            var t3, n3 = "", r3 = 0, i3 = e3.nodeType;
            if (i3) {
              if (1 === i3 || 9 === i3 || 11 === i3) {
                if ("string" == typeof e3.textContent)
                  return e3.textContent;
                for (e3 = e3.firstChild; e3; e3 = e3.nextSibling)
                  n3 += o2(e3);
              } else if (3 === i3 || 4 === i3)
                return e3.nodeValue;
            } else
              while (t3 = e3[r3++])
                n3 += o2(t3);
            return n3;
          }, (b2 = se2.selectors = { cacheLength: 50, createPseudo: le2, match: G2, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: true }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: true }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function(e3) {
            return e3[1] = e3[1].replace(te2, ne2), e3[3] = (e3[3] || e3[4] || e3[5] || "").replace(te2, ne2), "~=" === e3[2] && (e3[3] = " " + e3[3] + " "), e3.slice(0, 4);
          }, CHILD: function(e3) {
            return e3[1] = e3[1].toLowerCase(), "nth" === e3[1].slice(0, 3) ? (e3[3] || se2.error(e3[0]), e3[4] = +(e3[4] ? e3[5] + (e3[6] || 1) : 2 * ("even" === e3[3] || "odd" === e3[3])), e3[5] = +(e3[7] + e3[8] || "odd" === e3[3])) : e3[3] && se2.error(e3[0]), e3;
          }, PSEUDO: function(e3) {
            var t3, n3 = !e3[6] && e3[2];
            return G2.CHILD.test(e3[0]) ? null : (e3[3] ? e3[2] = e3[4] || e3[5] || "" : n3 && X2.test(n3) && (t3 = h2(n3, true)) && (t3 = n3.indexOf(")", n3.length - t3) - n3.length) && (e3[0] = e3[0].slice(0, t3), e3[2] = n3.slice(0, t3)), e3.slice(0, 3));
          } }, filter: { TAG: function(e3) {
            var t3 = e3.replace(te2, ne2).toLowerCase();
            return "*" === e3 ? function() {
              return true;
            } : function(e4) {
              return e4.nodeName && e4.nodeName.toLowerCase() === t3;
            };
          }, CLASS: function(e3) {
            var t3 = m2[e3 + " "];
            return t3 || (t3 = new RegExp("(^|" + M2 + ")" + e3 + "(" + M2 + "|$)")) && m2(e3, function(e4) {
              return t3.test("string" == typeof e4.className && e4.className || "undefined" != typeof e4.getAttribute && e4.getAttribute("class") || "");
            });
          }, ATTR: function(n3, r3, i3) {
            return function(e3) {
              var t3 = se2.attr(e3, n3);
              return null == t3 ? "!=" === r3 : !r3 || (t3 += "", "=" === r3 ? t3 === i3 : "!=" === r3 ? t3 !== i3 : "^=" === r3 ? i3 && 0 === t3.indexOf(i3) : "*=" === r3 ? i3 && -1 < t3.indexOf(i3) : "$=" === r3 ? i3 && t3.slice(-i3.length) === i3 : "~=" === r3 ? -1 < (" " + t3.replace(B2, " ") + " ").indexOf(i3) : "|=" === r3 && (t3 === i3 || t3.slice(0, i3.length + 1) === i3 + "-"));
            };
          }, CHILD: function(h3, e3, t3, g3, v3) {
            var y3 = "nth" !== h3.slice(0, 3), m3 = "last" !== h3.slice(-4), x3 = "of-type" === e3;
            return 1 === g3 && 0 === v3 ? function(e4) {
              return !!e4.parentNode;
            } : function(e4, t4, n3) {
              var r3, i3, o3, a3, s3, u3, l3 = y3 !== m3 ? "nextSibling" : "previousSibling", c3 = e4.parentNode, f3 = x3 && e4.nodeName.toLowerCase(), p3 = !n3 && !x3, d3 = false;
              if (c3) {
                if (y3) {
                  while (l3) {
                    a3 = e4;
                    while (a3 = a3[l3])
                      if (x3 ? a3.nodeName.toLowerCase() === f3 : 1 === a3.nodeType)
                        return false;
                    u3 = l3 = "only" === h3 && !u3 && "nextSibling";
                  }
                  return true;
                }
                if (u3 = [m3 ? c3.firstChild : c3.lastChild], m3 && p3) {
                  d3 = (s3 = (r3 = (i3 = (o3 = (a3 = c3)[S2] || (a3[S2] = {}))[a3.uniqueID] || (o3[a3.uniqueID] = {}))[h3] || [])[0] === k2 && r3[1]) && r3[2], a3 = s3 && c3.childNodes[s3];
                  while (a3 = ++s3 && a3 && a3[l3] || (d3 = s3 = 0) || u3.pop())
                    if (1 === a3.nodeType && ++d3 && a3 === e4) {
                      i3[h3] = [k2, s3, d3];
                      break;
                    }
                } else if (p3 && (d3 = s3 = (r3 = (i3 = (o3 = (a3 = e4)[S2] || (a3[S2] = {}))[a3.uniqueID] || (o3[a3.uniqueID] = {}))[h3] || [])[0] === k2 && r3[1]), false === d3) {
                  while (a3 = ++s3 && a3 && a3[l3] || (d3 = s3 = 0) || u3.pop())
                    if ((x3 ? a3.nodeName.toLowerCase() === f3 : 1 === a3.nodeType) && ++d3 && (p3 && ((i3 = (o3 = a3[S2] || (a3[S2] = {}))[a3.uniqueID] || (o3[a3.uniqueID] = {}))[h3] = [k2, d3]), a3 === e4))
                      break;
                }
                return (d3 -= v3) === g3 || d3 % g3 == 0 && 0 <= d3 / g3;
              }
            };
          }, PSEUDO: function(e3, o3) {
            var t3, a3 = b2.pseudos[e3] || b2.setFilters[e3.toLowerCase()] || se2.error("unsupported pseudo: " + e3);
            return a3[S2] ? a3(o3) : 1 < a3.length ? (t3 = [e3, e3, "", o3], b2.setFilters.hasOwnProperty(e3.toLowerCase()) ? le2(function(e4, t4) {
              var n3, r3 = a3(e4, o3), i3 = r3.length;
              while (i3--)
                e4[n3 = P2(e4, r3[i3])] = !(t4[n3] = r3[i3]);
            }) : function(e4) {
              return a3(e4, 0, t3);
            }) : a3;
          } }, pseudos: { not: le2(function(e3) {
            var r3 = [], i3 = [], s3 = f2(e3.replace($3, "$1"));
            return s3[S2] ? le2(function(e4, t3, n3, r4) {
              var i4, o3 = s3(e4, null, r4, []), a3 = e4.length;
              while (a3--)
                (i4 = o3[a3]) && (e4[a3] = !(t3[a3] = i4));
            }) : function(e4, t3, n3) {
              return r3[0] = e4, s3(r3, null, n3, i3), r3[0] = null, !i3.pop();
            };
          }), has: le2(function(t3) {
            return function(e3) {
              return 0 < se2(t3, e3).length;
            };
          }), contains: le2(function(t3) {
            return t3 = t3.replace(te2, ne2), function(e3) {
              return -1 < (e3.textContent || o2(e3)).indexOf(t3);
            };
          }), lang: le2(function(n3) {
            return V2.test(n3 || "") || se2.error("unsupported lang: " + n3), n3 = n3.replace(te2, ne2).toLowerCase(), function(e3) {
              var t3;
              do {
                if (t3 = E2 ? e3.lang : e3.getAttribute("xml:lang") || e3.getAttribute("lang"))
                  return (t3 = t3.toLowerCase()) === n3 || 0 === t3.indexOf(n3 + "-");
              } while ((e3 = e3.parentNode) && 1 === e3.nodeType);
              return false;
            };
          }), target: function(e3) {
            var t3 = n2.location && n2.location.hash;
            return t3 && t3.slice(1) === e3.id;
          }, root: function(e3) {
            return e3 === a2;
          }, focus: function(e3) {
            return e3 === C2.activeElement && (!C2.hasFocus || C2.hasFocus()) && !!(e3.type || e3.href || ~e3.tabIndex);
          }, enabled: ge2(false), disabled: ge2(true), checked: function(e3) {
            var t3 = e3.nodeName.toLowerCase();
            return "input" === t3 && !!e3.checked || "option" === t3 && !!e3.selected;
          }, selected: function(e3) {
            return e3.parentNode && e3.parentNode.selectedIndex, true === e3.selected;
          }, empty: function(e3) {
            for (e3 = e3.firstChild; e3; e3 = e3.nextSibling)
              if (e3.nodeType < 6)
                return false;
            return true;
          }, parent: function(e3) {
            return !b2.pseudos.empty(e3);
          }, header: function(e3) {
            return J2.test(e3.nodeName);
          }, input: function(e3) {
            return Q2.test(e3.nodeName);
          }, button: function(e3) {
            var t3 = e3.nodeName.toLowerCase();
            return "input" === t3 && "button" === e3.type || "button" === t3;
          }, text: function(e3) {
            var t3;
            return "input" === e3.nodeName.toLowerCase() && "text" === e3.type && (null == (t3 = e3.getAttribute("type")) || "text" === t3.toLowerCase());
          }, first: ve2(function() {
            return [0];
          }), last: ve2(function(e3, t3) {
            return [t3 - 1];
          }), eq: ve2(function(e3, t3, n3) {
            return [n3 < 0 ? n3 + t3 : n3];
          }), even: ve2(function(e3, t3) {
            for (var n3 = 0; n3 < t3; n3 += 2)
              e3.push(n3);
            return e3;
          }), odd: ve2(function(e3, t3) {
            for (var n3 = 1; n3 < t3; n3 += 2)
              e3.push(n3);
            return e3;
          }), lt: ve2(function(e3, t3, n3) {
            for (var r3 = n3 < 0 ? n3 + t3 : t3 < n3 ? t3 : n3; 0 <= --r3; )
              e3.push(r3);
            return e3;
          }), gt: ve2(function(e3, t3, n3) {
            for (var r3 = n3 < 0 ? n3 + t3 : n3; ++r3 < t3; )
              e3.push(r3);
            return e3;
          }) } }).pseudos.nth = b2.pseudos.eq, { radio: true, checkbox: true, file: true, password: true, image: true })
            b2.pseudos[e2] = de2(e2);
          for (e2 in { submit: true, reset: true })
            b2.pseudos[e2] = he2(e2);
          function me2() {
          }
          function xe2(e3) {
            for (var t3 = 0, n3 = e3.length, r3 = ""; t3 < n3; t3++)
              r3 += e3[t3].value;
            return r3;
          }
          function be2(s3, e3, t3) {
            var u3 = e3.dir, l3 = e3.next, c3 = l3 || u3, f3 = t3 && "parentNode" === c3, p3 = r2++;
            return e3.first ? function(e4, t4, n3) {
              while (e4 = e4[u3])
                if (1 === e4.nodeType || f3)
                  return s3(e4, t4, n3);
              return false;
            } : function(e4, t4, n3) {
              var r3, i3, o3, a3 = [k2, p3];
              if (n3) {
                while (e4 = e4[u3])
                  if ((1 === e4.nodeType || f3) && s3(e4, t4, n3))
                    return true;
              } else
                while (e4 = e4[u3])
                  if (1 === e4.nodeType || f3)
                    if (i3 = (o3 = e4[S2] || (e4[S2] = {}))[e4.uniqueID] || (o3[e4.uniqueID] = {}), l3 && l3 === e4.nodeName.toLowerCase())
                      e4 = e4[u3] || e4;
                    else {
                      if ((r3 = i3[c3]) && r3[0] === k2 && r3[1] === p3)
                        return a3[2] = r3[2];
                      if ((i3[c3] = a3)[2] = s3(e4, t4, n3))
                        return true;
                    }
              return false;
            };
          }
          function we2(i3) {
            return 1 < i3.length ? function(e3, t3, n3) {
              var r3 = i3.length;
              while (r3--)
                if (!i3[r3](e3, t3, n3))
                  return false;
              return true;
            } : i3[0];
          }
          function Te2(e3, t3, n3, r3, i3) {
            for (var o3, a3 = [], s3 = 0, u3 = e3.length, l3 = null != t3; s3 < u3; s3++)
              (o3 = e3[s3]) && (n3 && !n3(o3, r3, i3) || (a3.push(o3), l3 && t3.push(s3)));
            return a3;
          }
          function Ce2(d3, h3, g3, v3, y3, e3) {
            return v3 && !v3[S2] && (v3 = Ce2(v3)), y3 && !y3[S2] && (y3 = Ce2(y3, e3)), le2(function(e4, t3, n3, r3) {
              var i3, o3, a3, s3 = [], u3 = [], l3 = t3.length, c3 = e4 || function(e5, t4, n4) {
                for (var r4 = 0, i4 = t4.length; r4 < i4; r4++)
                  se2(e5, t4[r4], n4);
                return n4;
              }(h3 || "*", n3.nodeType ? [n3] : n3, []), f3 = !d3 || !e4 && h3 ? c3 : Te2(c3, s3, d3, n3, r3), p3 = g3 ? y3 || (e4 ? d3 : l3 || v3) ? [] : t3 : f3;
              if (g3 && g3(f3, p3, n3, r3), v3) {
                i3 = Te2(p3, u3), v3(i3, [], n3, r3), o3 = i3.length;
                while (o3--)
                  (a3 = i3[o3]) && (p3[u3[o3]] = !(f3[u3[o3]] = a3));
              }
              if (e4) {
                if (y3 || d3) {
                  if (y3) {
                    i3 = [], o3 = p3.length;
                    while (o3--)
                      (a3 = p3[o3]) && i3.push(f3[o3] = a3);
                    y3(null, p3 = [], i3, r3);
                  }
                  o3 = p3.length;
                  while (o3--)
                    (a3 = p3[o3]) && -1 < (i3 = y3 ? P2(e4, a3) : s3[o3]) && (e4[i3] = !(t3[i3] = a3));
                }
              } else
                p3 = Te2(p3 === t3 ? p3.splice(l3, p3.length) : p3), y3 ? y3(null, t3, p3, r3) : H2.apply(t3, p3);
            });
          }
          function Ee2(e3) {
            for (var i3, t3, n3, r3 = e3.length, o3 = b2.relative[e3[0].type], a3 = o3 || b2.relative[" "], s3 = o3 ? 1 : 0, u3 = be2(function(e4) {
              return e4 === i3;
            }, a3, true), l3 = be2(function(e4) {
              return -1 < P2(i3, e4);
            }, a3, true), c3 = [function(e4, t4, n4) {
              var r4 = !o3 && (n4 || t4 !== w2) || ((i3 = t4).nodeType ? u3(e4, t4, n4) : l3(e4, t4, n4));
              return i3 = null, r4;
            }]; s3 < r3; s3++)
              if (t3 = b2.relative[e3[s3].type])
                c3 = [be2(we2(c3), t3)];
              else {
                if ((t3 = b2.filter[e3[s3].type].apply(null, e3[s3].matches))[S2]) {
                  for (n3 = ++s3; n3 < r3; n3++)
                    if (b2.relative[e3[n3].type])
                      break;
                  return Ce2(1 < s3 && we2(c3), 1 < s3 && xe2(e3.slice(0, s3 - 1).concat({ value: " " === e3[s3 - 2].type ? "*" : "" })).replace($3, "$1"), t3, s3 < n3 && Ee2(e3.slice(s3, n3)), n3 < r3 && Ee2(e3 = e3.slice(n3)), n3 < r3 && xe2(e3));
                }
                c3.push(t3);
              }
            return we2(c3);
          }
          return me2.prototype = b2.filters = b2.pseudos, b2.setFilters = new me2(), h2 = se2.tokenize = function(e3, t3) {
            var n3, r3, i3, o3, a3, s3, u3, l3 = x2[e3 + " "];
            if (l3)
              return t3 ? 0 : l3.slice(0);
            a3 = e3, s3 = [], u3 = b2.preFilter;
            while (a3) {
              for (o3 in n3 && !(r3 = _2.exec(a3)) || (r3 && (a3 = a3.slice(r3[0].length) || a3), s3.push(i3 = [])), n3 = false, (r3 = z2.exec(a3)) && (n3 = r3.shift(), i3.push({ value: n3, type: r3[0].replace($3, " ") }), a3 = a3.slice(n3.length)), b2.filter)
                !(r3 = G2[o3].exec(a3)) || u3[o3] && !(r3 = u3[o3](r3)) || (n3 = r3.shift(), i3.push({ value: n3, type: o3, matches: r3 }), a3 = a3.slice(n3.length));
              if (!n3)
                break;
            }
            return t3 ? a3.length : a3 ? se2.error(e3) : x2(e3, s3).slice(0);
          }, f2 = se2.compile = function(e3, t3) {
            var n3, v3, y3, m3, x3, r3, i3 = [], o3 = [], a3 = A2[e3 + " "];
            if (!a3) {
              t3 || (t3 = h2(e3)), n3 = t3.length;
              while (n3--)
                (a3 = Ee2(t3[n3]))[S2] ? i3.push(a3) : o3.push(a3);
              (a3 = A2(e3, (v3 = o3, m3 = 0 < (y3 = i3).length, x3 = 0 < v3.length, r3 = function(e4, t4, n4, r4, i4) {
                var o4, a4, s3, u3 = 0, l3 = "0", c3 = e4 && [], f3 = [], p3 = w2, d3 = e4 || x3 && b2.find.TAG("*", i4), h3 = k2 += null == p3 ? 1 : Math.random() || 0.1, g3 = d3.length;
                for (i4 && (w2 = t4 == C2 || t4 || i4); l3 !== g3 && null != (o4 = d3[l3]); l3++) {
                  if (x3 && o4) {
                    a4 = 0, t4 || o4.ownerDocument == C2 || (T2(o4), n4 = !E2);
                    while (s3 = v3[a4++])
                      if (s3(o4, t4 || C2, n4)) {
                        r4.push(o4);
                        break;
                      }
                    i4 && (k2 = h3);
                  }
                  m3 && ((o4 = !s3 && o4) && u3--, e4 && c3.push(o4));
                }
                if (u3 += l3, m3 && l3 !== u3) {
                  a4 = 0;
                  while (s3 = y3[a4++])
                    s3(c3, f3, t4, n4);
                  if (e4) {
                    if (0 < u3)
                      while (l3--)
                        c3[l3] || f3[l3] || (f3[l3] = q2.call(r4));
                    f3 = Te2(f3);
                  }
                  H2.apply(r4, f3), i4 && !e4 && 0 < f3.length && 1 < u3 + y3.length && se2.uniqueSort(r4);
                }
                return i4 && (k2 = h3, w2 = p3), c3;
              }, m3 ? le2(r3) : r3))).selector = e3;
            }
            return a3;
          }, g2 = se2.select = function(e3, t3, n3, r3) {
            var i3, o3, a3, s3, u3, l3 = "function" == typeof e3 && e3, c3 = !r3 && h2(e3 = l3.selector || e3);
            if (n3 = n3 || [], 1 === c3.length) {
              if (2 < (o3 = c3[0] = c3[0].slice(0)).length && "ID" === (a3 = o3[0]).type && 9 === t3.nodeType && E2 && b2.relative[o3[1].type]) {
                if (!(t3 = (b2.find.ID(a3.matches[0].replace(te2, ne2), t3) || [])[0]))
                  return n3;
                l3 && (t3 = t3.parentNode), e3 = e3.slice(o3.shift().value.length);
              }
              i3 = G2.needsContext.test(e3) ? 0 : o3.length;
              while (i3--) {
                if (a3 = o3[i3], b2.relative[s3 = a3.type])
                  break;
                if ((u3 = b2.find[s3]) && (r3 = u3(a3.matches[0].replace(te2, ne2), ee2.test(o3[0].type) && ye2(t3.parentNode) || t3))) {
                  if (o3.splice(i3, 1), !(e3 = r3.length && xe2(o3)))
                    return H2.apply(n3, r3), n3;
                  break;
                }
              }
            }
            return (l3 || f2(e3, c3))(r3, t3, !E2, n3, !t3 || ee2.test(e3) && ye2(t3.parentNode) || t3), n3;
          }, d2.sortStable = S2.split("").sort(j2).join("") === S2, d2.detectDuplicates = !!l2, T2(), d2.sortDetached = ce2(function(e3) {
            return 1 & e3.compareDocumentPosition(C2.createElement("fieldset"));
          }), ce2(function(e3) {
            return e3.innerHTML = "<a href='#'></a>", "#" === e3.firstChild.getAttribute("href");
          }) || fe2("type|href|height|width", function(e3, t3, n3) {
            if (!n3)
              return e3.getAttribute(t3, "type" === t3.toLowerCase() ? 1 : 2);
          }), d2.attributes && ce2(function(e3) {
            return e3.innerHTML = "<input/>", e3.firstChild.setAttribute("value", ""), "" === e3.firstChild.getAttribute("value");
          }) || fe2("value", function(e3, t3, n3) {
            if (!n3 && "input" === e3.nodeName.toLowerCase())
              return e3.defaultValue;
          }), ce2(function(e3) {
            return null == e3.getAttribute("disabled");
          }) || fe2(R2, function(e3, t3, n3) {
            var r3;
            if (!n3)
              return true === e3[t3] ? t3.toLowerCase() : (r3 = e3.getAttributeNode(t3)) && r3.specified ? r3.value : null;
          }), se2;
        }(C);
        S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;
        var h = function(e2, t2, n2) {
          var r2 = [], i2 = void 0 !== n2;
          while ((e2 = e2[t2]) && 9 !== e2.nodeType)
            if (1 === e2.nodeType) {
              if (i2 && S(e2).is(n2))
                break;
              r2.push(e2);
            }
          return r2;
        }, T = function(e2, t2) {
          for (var n2 = []; e2; e2 = e2.nextSibling)
            1 === e2.nodeType && e2 !== t2 && n2.push(e2);
          return n2;
        }, k = S.expr.match.needsContext;
        function A(e2, t2) {
          return e2.nodeName && e2.nodeName.toLowerCase() === t2.toLowerCase();
        }
        var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function j(e2, n2, r2) {
          return m(n2) ? S.grep(e2, function(e3, t2) {
            return !!n2.call(e3, t2, e3) !== r2;
          }) : n2.nodeType ? S.grep(e2, function(e3) {
            return e3 === n2 !== r2;
          }) : "string" != typeof n2 ? S.grep(e2, function(e3) {
            return -1 < i.call(n2, e3) !== r2;
          }) : S.filter(n2, e2, r2);
        }
        S.filter = function(e2, t2, n2) {
          var r2 = t2[0];
          return n2 && (e2 = ":not(" + e2 + ")"), 1 === t2.length && 1 === r2.nodeType ? S.find.matchesSelector(r2, e2) ? [r2] : [] : S.find.matches(e2, S.grep(t2, function(e3) {
            return 1 === e3.nodeType;
          }));
        }, S.fn.extend({ find: function(e2) {
          var t2, n2, r2 = this.length, i2 = this;
          if ("string" != typeof e2)
            return this.pushStack(S(e2).filter(function() {
              for (t2 = 0; t2 < r2; t2++)
                if (S.contains(i2[t2], this))
                  return true;
            }));
          for (n2 = this.pushStack([]), t2 = 0; t2 < r2; t2++)
            S.find(e2, i2[t2], n2);
          return 1 < r2 ? S.uniqueSort(n2) : n2;
        }, filter: function(e2) {
          return this.pushStack(j(this, e2 || [], false));
        }, not: function(e2) {
          return this.pushStack(j(this, e2 || [], true));
        }, is: function(e2) {
          return !!j(this, "string" == typeof e2 && k.test(e2) ? S(e2) : e2 || [], false).length;
        } });
        var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (S.fn.init = function(e2, t2, n2) {
          var r2, i2;
          if (!e2)
            return this;
          if (n2 = n2 || D, "string" == typeof e2) {
            if (!(r2 = "<" === e2[0] && ">" === e2[e2.length - 1] && 3 <= e2.length ? [null, e2, null] : q.exec(e2)) || !r2[1] && t2)
              return !t2 || t2.jquery ? (t2 || n2).find(e2) : this.constructor(t2).find(e2);
            if (r2[1]) {
              if (t2 = t2 instanceof S ? t2[0] : t2, S.merge(this, S.parseHTML(r2[1], t2 && t2.nodeType ? t2.ownerDocument || t2 : E, true)), N.test(r2[1]) && S.isPlainObject(t2))
                for (r2 in t2)
                  m(this[r2]) ? this[r2](t2[r2]) : this.attr(r2, t2[r2]);
              return this;
            }
            return (i2 = E.getElementById(r2[2])) && (this[0] = i2, this.length = 1), this;
          }
          return e2.nodeType ? (this[0] = e2, this.length = 1, this) : m(e2) ? void 0 !== n2.ready ? n2.ready(e2) : e2(S) : S.makeArray(e2, this);
        }).prototype = S.fn, D = S(E);
        var L = /^(?:parents|prev(?:Until|All))/, H = { children: true, contents: true, next: true, prev: true };
        function O(e2, t2) {
          while ((e2 = e2[t2]) && 1 !== e2.nodeType)
            ;
          return e2;
        }
        S.fn.extend({ has: function(e2) {
          var t2 = S(e2, this), n2 = t2.length;
          return this.filter(function() {
            for (var e3 = 0; e3 < n2; e3++)
              if (S.contains(this, t2[e3]))
                return true;
          });
        }, closest: function(e2, t2) {
          var n2, r2 = 0, i2 = this.length, o2 = [], a2 = "string" != typeof e2 && S(e2);
          if (!k.test(e2)) {
            for (; r2 < i2; r2++)
              for (n2 = this[r2]; n2 && n2 !== t2; n2 = n2.parentNode)
                if (n2.nodeType < 11 && (a2 ? -1 < a2.index(n2) : 1 === n2.nodeType && S.find.matchesSelector(n2, e2))) {
                  o2.push(n2);
                  break;
                }
          }
          return this.pushStack(1 < o2.length ? S.uniqueSort(o2) : o2);
        }, index: function(e2) {
          return e2 ? "string" == typeof e2 ? i.call(S(e2), this[0]) : i.call(this, e2.jquery ? e2[0] : e2) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }, add: function(e2, t2) {
          return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e2, t2))));
        }, addBack: function(e2) {
          return this.add(null == e2 ? this.prevObject : this.prevObject.filter(e2));
        } }), S.each({ parent: function(e2) {
          var t2 = e2.parentNode;
          return t2 && 11 !== t2.nodeType ? t2 : null;
        }, parents: function(e2) {
          return h(e2, "parentNode");
        }, parentsUntil: function(e2, t2, n2) {
          return h(e2, "parentNode", n2);
        }, next: function(e2) {
          return O(e2, "nextSibling");
        }, prev: function(e2) {
          return O(e2, "previousSibling");
        }, nextAll: function(e2) {
          return h(e2, "nextSibling");
        }, prevAll: function(e2) {
          return h(e2, "previousSibling");
        }, nextUntil: function(e2, t2, n2) {
          return h(e2, "nextSibling", n2);
        }, prevUntil: function(e2, t2, n2) {
          return h(e2, "previousSibling", n2);
        }, siblings: function(e2) {
          return T((e2.parentNode || {}).firstChild, e2);
        }, children: function(e2) {
          return T(e2.firstChild);
        }, contents: function(e2) {
          return null != e2.contentDocument && r(e2.contentDocument) ? e2.contentDocument : (A(e2, "template") && (e2 = e2.content || e2), S.merge([], e2.childNodes));
        } }, function(r2, i2) {
          S.fn[r2] = function(e2, t2) {
            var n2 = S.map(this, i2, e2);
            return "Until" !== r2.slice(-5) && (t2 = e2), t2 && "string" == typeof t2 && (n2 = S.filter(t2, n2)), 1 < this.length && (H[r2] || S.uniqueSort(n2), L.test(r2) && n2.reverse()), this.pushStack(n2);
          };
        });
        var P = /[^\x20\t\r\n\f]+/g;
        function R(e2) {
          return e2;
        }
        function M(e2) {
          throw e2;
        }
        function I(e2, t2, n2, r2) {
          var i2;
          try {
            e2 && m(i2 = e2.promise) ? i2.call(e2).done(t2).fail(n2) : e2 && m(i2 = e2.then) ? i2.call(e2, t2, n2) : t2.apply(void 0, [e2].slice(r2));
          } catch (e3) {
            n2.apply(void 0, [e3]);
          }
        }
        S.Callbacks = function(r2) {
          var e2, n2;
          r2 = "string" == typeof r2 ? (e2 = r2, n2 = {}, S.each(e2.match(P) || [], function(e3, t3) {
            n2[t3] = true;
          }), n2) : S.extend({}, r2);
          var i2, t2, o2, a2, s2 = [], u2 = [], l2 = -1, c2 = function() {
            for (a2 = a2 || r2.once, o2 = i2 = true; u2.length; l2 = -1) {
              t2 = u2.shift();
              while (++l2 < s2.length)
                false === s2[l2].apply(t2[0], t2[1]) && r2.stopOnFalse && (l2 = s2.length, t2 = false);
            }
            r2.memory || (t2 = false), i2 = false, a2 && (s2 = t2 ? [] : "");
          }, f2 = { add: function() {
            return s2 && (t2 && !i2 && (l2 = s2.length - 1, u2.push(t2)), function n3(e3) {
              S.each(e3, function(e4, t3) {
                m(t3) ? r2.unique && f2.has(t3) || s2.push(t3) : t3 && t3.length && "string" !== w(t3) && n3(t3);
              });
            }(arguments), t2 && !i2 && c2()), this;
          }, remove: function() {
            return S.each(arguments, function(e3, t3) {
              var n3;
              while (-1 < (n3 = S.inArray(t3, s2, n3)))
                s2.splice(n3, 1), n3 <= l2 && l2--;
            }), this;
          }, has: function(e3) {
            return e3 ? -1 < S.inArray(e3, s2) : 0 < s2.length;
          }, empty: function() {
            return s2 && (s2 = []), this;
          }, disable: function() {
            return a2 = u2 = [], s2 = t2 = "", this;
          }, disabled: function() {
            return !s2;
          }, lock: function() {
            return a2 = u2 = [], t2 || i2 || (s2 = t2 = ""), this;
          }, locked: function() {
            return !!a2;
          }, fireWith: function(e3, t3) {
            return a2 || (t3 = [e3, (t3 = t3 || []).slice ? t3.slice() : t3], u2.push(t3), i2 || c2()), this;
          }, fire: function() {
            return f2.fireWith(this, arguments), this;
          }, fired: function() {
            return !!o2;
          } };
          return f2;
        }, S.extend({ Deferred: function(e2) {
          var o2 = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]], i2 = "pending", a2 = { state: function() {
            return i2;
          }, always: function() {
            return s2.done(arguments).fail(arguments), this;
          }, "catch": function(e3) {
            return a2.then(null, e3);
          }, pipe: function() {
            var i3 = arguments;
            return S.Deferred(function(r2) {
              S.each(o2, function(e3, t2) {
                var n2 = m(i3[t2[4]]) && i3[t2[4]];
                s2[t2[1]](function() {
                  var e4 = n2 && n2.apply(this, arguments);
                  e4 && m(e4.promise) ? e4.promise().progress(r2.notify).done(r2.resolve).fail(r2.reject) : r2[t2[0] + "With"](this, n2 ? [e4] : arguments);
                });
              }), i3 = null;
            }).promise();
          }, then: function(t2, n2, r2) {
            var u2 = 0;
            function l2(i3, o3, a3, s3) {
              return function() {
                var n3 = this, r3 = arguments, e3 = function() {
                  var e4, t4;
                  if (!(i3 < u2)) {
                    if ((e4 = a3.apply(n3, r3)) === o3.promise())
                      throw new TypeError("Thenable self-resolution");
                    t4 = e4 && ("object" == typeof e4 || "function" == typeof e4) && e4.then, m(t4) ? s3 ? t4.call(e4, l2(u2, o3, R, s3), l2(u2, o3, M, s3)) : (u2++, t4.call(e4, l2(u2, o3, R, s3), l2(u2, o3, M, s3), l2(u2, o3, R, o3.notifyWith))) : (a3 !== R && (n3 = void 0, r3 = [e4]), (s3 || o3.resolveWith)(n3, r3));
                  }
                }, t3 = s3 ? e3 : function() {
                  try {
                    e3();
                  } catch (e4) {
                    S.Deferred.exceptionHook && S.Deferred.exceptionHook(e4, t3.stackTrace), u2 <= i3 + 1 && (a3 !== M && (n3 = void 0, r3 = [e4]), o3.rejectWith(n3, r3));
                  }
                };
                i3 ? t3() : (S.Deferred.getStackHook && (t3.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t3));
              };
            }
            return S.Deferred(function(e3) {
              o2[0][3].add(l2(0, e3, m(r2) ? r2 : R, e3.notifyWith)), o2[1][3].add(l2(0, e3, m(t2) ? t2 : R)), o2[2][3].add(l2(0, e3, m(n2) ? n2 : M));
            }).promise();
          }, promise: function(e3) {
            return null != e3 ? S.extend(e3, a2) : a2;
          } }, s2 = {};
          return S.each(o2, function(e3, t2) {
            var n2 = t2[2], r2 = t2[5];
            a2[t2[1]] = n2.add, r2 && n2.add(function() {
              i2 = r2;
            }, o2[3 - e3][2].disable, o2[3 - e3][3].disable, o2[0][2].lock, o2[0][3].lock), n2.add(t2[3].fire), s2[t2[0]] = function() {
              return s2[t2[0] + "With"](this === s2 ? void 0 : this, arguments), this;
            }, s2[t2[0] + "With"] = n2.fireWith;
          }), a2.promise(s2), e2 && e2.call(s2, s2), s2;
        }, when: function(e2) {
          var n2 = arguments.length, t2 = n2, r2 = Array(t2), i2 = s.call(arguments), o2 = S.Deferred(), a2 = function(t3) {
            return function(e3) {
              r2[t3] = this, i2[t3] = 1 < arguments.length ? s.call(arguments) : e3, --n2 || o2.resolveWith(r2, i2);
            };
          };
          if (n2 <= 1 && (I(e2, o2.done(a2(t2)).resolve, o2.reject, !n2), "pending" === o2.state() || m(i2[t2] && i2[t2].then)))
            return o2.then();
          while (t2--)
            I(i2[t2], a2(t2), o2.reject);
          return o2.promise();
        } });
        var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        S.Deferred.exceptionHook = function(e2, t2) {
          C.console && C.console.warn && e2 && W.test(e2.name) && C.console.warn("jQuery.Deferred exception: " + e2.message, e2.stack, t2);
        }, S.readyException = function(e2) {
          C.setTimeout(function() {
            throw e2;
          });
        };
        var F = S.Deferred();
        function B() {
          E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready();
        }
        S.fn.ready = function(e2) {
          return F.then(e2)["catch"](function(e3) {
            S.readyException(e3);
          }), this;
        }, S.extend({ isReady: false, readyWait: 1, ready: function(e2) {
          (true === e2 ? --S.readyWait : S.isReady) || (S.isReady = true) !== e2 && 0 < --S.readyWait || F.resolveWith(E, [S]);
        } }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
        var $2 = function(e2, t2, n2, r2, i2, o2, a2) {
          var s2 = 0, u2 = e2.length, l2 = null == n2;
          if ("object" === w(n2))
            for (s2 in i2 = true, n2)
              $2(e2, t2, s2, n2[s2], true, o2, a2);
          else if (void 0 !== r2 && (i2 = true, m(r2) || (a2 = true), l2 && (a2 ? (t2.call(e2, r2), t2 = null) : (l2 = t2, t2 = function(e3, t3, n3) {
            return l2.call(S(e3), n3);
          })), t2))
            for (; s2 < u2; s2++)
              t2(e2[s2], n2, a2 ? r2 : r2.call(e2[s2], s2, t2(e2[s2], n2)));
          return i2 ? e2 : l2 ? t2.call(e2) : u2 ? t2(e2[0], n2) : o2;
        }, _ = /^-ms-/, z = /-([a-z])/g;
        function U(e2, t2) {
          return t2.toUpperCase();
        }
        function X(e2) {
          return e2.replace(_, "ms-").replace(z, U);
        }
        var V = function(e2) {
          return 1 === e2.nodeType || 9 === e2.nodeType || !+e2.nodeType;
        };
        function G() {
          this.expando = S.expando + G.uid++;
        }
        G.uid = 1, G.prototype = { cache: function(e2) {
          var t2 = e2[this.expando];
          return t2 || (t2 = {}, V(e2) && (e2.nodeType ? e2[this.expando] = t2 : Object.defineProperty(e2, this.expando, { value: t2, configurable: true }))), t2;
        }, set: function(e2, t2, n2) {
          var r2, i2 = this.cache(e2);
          if ("string" == typeof t2)
            i2[X(t2)] = n2;
          else
            for (r2 in t2)
              i2[X(r2)] = t2[r2];
          return i2;
        }, get: function(e2, t2) {
          return void 0 === t2 ? this.cache(e2) : e2[this.expando] && e2[this.expando][X(t2)];
        }, access: function(e2, t2, n2) {
          return void 0 === t2 || t2 && "string" == typeof t2 && void 0 === n2 ? this.get(e2, t2) : (this.set(e2, t2, n2), void 0 !== n2 ? n2 : t2);
        }, remove: function(e2, t2) {
          var n2, r2 = e2[this.expando];
          if (void 0 !== r2) {
            if (void 0 !== t2) {
              n2 = (t2 = Array.isArray(t2) ? t2.map(X) : (t2 = X(t2)) in r2 ? [t2] : t2.match(P) || []).length;
              while (n2--)
                delete r2[t2[n2]];
            }
            (void 0 === t2 || S.isEmptyObject(r2)) && (e2.nodeType ? e2[this.expando] = void 0 : delete e2[this.expando]);
          }
        }, hasData: function(e2) {
          var t2 = e2[this.expando];
          return void 0 !== t2 && !S.isEmptyObject(t2);
        } };
        var Y = new G(), Q = new G(), J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g;
        function Z(e2, t2, n2) {
          var r2, i2;
          if (void 0 === n2 && 1 === e2.nodeType)
            if (r2 = "data-" + t2.replace(K, "-$&").toLowerCase(), "string" == typeof (n2 = e2.getAttribute(r2))) {
              try {
                n2 = "true" === (i2 = n2) || "false" !== i2 && ("null" === i2 ? null : i2 === +i2 + "" ? +i2 : J.test(i2) ? JSON.parse(i2) : i2);
              } catch (e3) {
              }
              Q.set(e2, t2, n2);
            } else
              n2 = void 0;
          return n2;
        }
        S.extend({ hasData: function(e2) {
          return Q.hasData(e2) || Y.hasData(e2);
        }, data: function(e2, t2, n2) {
          return Q.access(e2, t2, n2);
        }, removeData: function(e2, t2) {
          Q.remove(e2, t2);
        }, _data: function(e2, t2, n2) {
          return Y.access(e2, t2, n2);
        }, _removeData: function(e2, t2) {
          Y.remove(e2, t2);
        } }), S.fn.extend({ data: function(n2, e2) {
          var t2, r2, i2, o2 = this[0], a2 = o2 && o2.attributes;
          if (void 0 === n2) {
            if (this.length && (i2 = Q.get(o2), 1 === o2.nodeType && !Y.get(o2, "hasDataAttrs"))) {
              t2 = a2.length;
              while (t2--)
                a2[t2] && 0 === (r2 = a2[t2].name).indexOf("data-") && (r2 = X(r2.slice(5)), Z(o2, r2, i2[r2]));
              Y.set(o2, "hasDataAttrs", true);
            }
            return i2;
          }
          return "object" == typeof n2 ? this.each(function() {
            Q.set(this, n2);
          }) : $2(this, function(e3) {
            var t3;
            if (o2 && void 0 === e3)
              return void 0 !== (t3 = Q.get(o2, n2)) ? t3 : void 0 !== (t3 = Z(o2, n2)) ? t3 : void 0;
            this.each(function() {
              Q.set(this, n2, e3);
            });
          }, null, e2, 1 < arguments.length, null, true);
        }, removeData: function(e2) {
          return this.each(function() {
            Q.remove(this, e2);
          });
        } }), S.extend({ queue: function(e2, t2, n2) {
          var r2;
          if (e2)
            return t2 = (t2 || "fx") + "queue", r2 = Y.get(e2, t2), n2 && (!r2 || Array.isArray(n2) ? r2 = Y.access(e2, t2, S.makeArray(n2)) : r2.push(n2)), r2 || [];
        }, dequeue: function(e2, t2) {
          t2 = t2 || "fx";
          var n2 = S.queue(e2, t2), r2 = n2.length, i2 = n2.shift(), o2 = S._queueHooks(e2, t2);
          "inprogress" === i2 && (i2 = n2.shift(), r2--), i2 && ("fx" === t2 && n2.unshift("inprogress"), delete o2.stop, i2.call(e2, function() {
            S.dequeue(e2, t2);
          }, o2)), !r2 && o2 && o2.empty.fire();
        }, _queueHooks: function(e2, t2) {
          var n2 = t2 + "queueHooks";
          return Y.get(e2, n2) || Y.access(e2, n2, { empty: S.Callbacks("once memory").add(function() {
            Y.remove(e2, [t2 + "queue", n2]);
          }) });
        } }), S.fn.extend({ queue: function(t2, n2) {
          var e2 = 2;
          return "string" != typeof t2 && (n2 = t2, t2 = "fx", e2--), arguments.length < e2 ? S.queue(this[0], t2) : void 0 === n2 ? this : this.each(function() {
            var e3 = S.queue(this, t2, n2);
            S._queueHooks(this, t2), "fx" === t2 && "inprogress" !== e3[0] && S.dequeue(this, t2);
          });
        }, dequeue: function(e2) {
          return this.each(function() {
            S.dequeue(this, e2);
          });
        }, clearQueue: function(e2) {
          return this.queue(e2 || "fx", []);
        }, promise: function(e2, t2) {
          var n2, r2 = 1, i2 = S.Deferred(), o2 = this, a2 = this.length, s2 = function() {
            --r2 || i2.resolveWith(o2, [o2]);
          };
          "string" != typeof e2 && (t2 = e2, e2 = void 0), e2 = e2 || "fx";
          while (a2--)
            (n2 = Y.get(o2[a2], e2 + "queueHooks")) && n2.empty && (r2++, n2.empty.add(s2));
          return s2(), i2.promise(t2);
        } });
        var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = ["Top", "Right", "Bottom", "Left"], re = E.documentElement, ie = function(e2) {
          return S.contains(e2.ownerDocument, e2);
        }, oe = { composed: true };
        re.getRootNode && (ie = function(e2) {
          return S.contains(e2.ownerDocument, e2) || e2.getRootNode(oe) === e2.ownerDocument;
        });
        var ae = function(e2, t2) {
          return "none" === (e2 = t2 || e2).style.display || "" === e2.style.display && ie(e2) && "none" === S.css(e2, "display");
        };
        function se(e2, t2, n2, r2) {
          var i2, o2, a2 = 20, s2 = r2 ? function() {
            return r2.cur();
          } : function() {
            return S.css(e2, t2, "");
          }, u2 = s2(), l2 = n2 && n2[3] || (S.cssNumber[t2] ? "" : "px"), c2 = e2.nodeType && (S.cssNumber[t2] || "px" !== l2 && +u2) && te.exec(S.css(e2, t2));
          if (c2 && c2[3] !== l2) {
            u2 /= 2, l2 = l2 || c2[3], c2 = +u2 || 1;
            while (a2--)
              S.style(e2, t2, c2 + l2), (1 - o2) * (1 - (o2 = s2() / u2 || 0.5)) <= 0 && (a2 = 0), c2 /= o2;
            c2 *= 2, S.style(e2, t2, c2 + l2), n2 = n2 || [];
          }
          return n2 && (c2 = +c2 || +u2 || 0, i2 = n2[1] ? c2 + (n2[1] + 1) * n2[2] : +n2[2], r2 && (r2.unit = l2, r2.start = c2, r2.end = i2)), i2;
        }
        var ue = {};
        function le(e2, t2) {
          for (var n2, r2, i2, o2, a2, s2, u2, l2 = [], c2 = 0, f2 = e2.length; c2 < f2; c2++)
            (r2 = e2[c2]).style && (n2 = r2.style.display, t2 ? ("none" === n2 && (l2[c2] = Y.get(r2, "display") || null, l2[c2] || (r2.style.display = "")), "" === r2.style.display && ae(r2) && (l2[c2] = (u2 = a2 = o2 = void 0, a2 = (i2 = r2).ownerDocument, s2 = i2.nodeName, (u2 = ue[s2]) || (o2 = a2.body.appendChild(a2.createElement(s2)), u2 = S.css(o2, "display"), o2.parentNode.removeChild(o2), "none" === u2 && (u2 = "block"), ue[s2] = u2)))) : "none" !== n2 && (l2[c2] = "none", Y.set(r2, "display", n2)));
          for (c2 = 0; c2 < f2; c2++)
            null != l2[c2] && (e2[c2].style.display = l2[c2]);
          return e2;
        }
        S.fn.extend({ show: function() {
          return le(this, true);
        }, hide: function() {
          return le(this);
        }, toggle: function(e2) {
          return "boolean" == typeof e2 ? e2 ? this.show() : this.hide() : this.each(function() {
            ae(this) ? S(this).show() : S(this).hide();
          });
        } });
        var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i;
        ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(true).cloneNode(true).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(true).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
        var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
        function ve(e2, t2) {
          var n2;
          return n2 = "undefined" != typeof e2.getElementsByTagName ? e2.getElementsByTagName(t2 || "*") : "undefined" != typeof e2.querySelectorAll ? e2.querySelectorAll(t2 || "*") : [], void 0 === t2 || t2 && A(e2, t2) ? S.merge([e2], n2) : n2;
        }
        function ye(e2, t2) {
          for (var n2 = 0, r2 = e2.length; n2 < r2; n2++)
            Y.set(e2[n2], "globalEval", !t2 || Y.get(t2[n2], "globalEval"));
        }
        ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
        var me = /<|&#?\w+;/;
        function xe(e2, t2, n2, r2, i2) {
          for (var o2, a2, s2, u2, l2, c2, f2 = t2.createDocumentFragment(), p2 = [], d2 = 0, h2 = e2.length; d2 < h2; d2++)
            if ((o2 = e2[d2]) || 0 === o2)
              if ("object" === w(o2))
                S.merge(p2, o2.nodeType ? [o2] : o2);
              else if (me.test(o2)) {
                a2 = a2 || f2.appendChild(t2.createElement("div")), s2 = (de.exec(o2) || ["", ""])[1].toLowerCase(), u2 = ge[s2] || ge._default, a2.innerHTML = u2[1] + S.htmlPrefilter(o2) + u2[2], c2 = u2[0];
                while (c2--)
                  a2 = a2.lastChild;
                S.merge(p2, a2.childNodes), (a2 = f2.firstChild).textContent = "";
              } else
                p2.push(t2.createTextNode(o2));
          f2.textContent = "", d2 = 0;
          while (o2 = p2[d2++])
            if (r2 && -1 < S.inArray(o2, r2))
              i2 && i2.push(o2);
            else if (l2 = ie(o2), a2 = ve(f2.appendChild(o2), "script"), l2 && ye(a2), n2) {
              c2 = 0;
              while (o2 = a2[c2++])
                he.test(o2.type || "") && n2.push(o2);
            }
          return f2;
        }
        var be = /^([^.]*)(?:\.(.+)|)/;
        function we() {
          return true;
        }
        function Te() {
          return false;
        }
        function Ce(e2, t2) {
          return e2 === function() {
            try {
              return E.activeElement;
            } catch (e3) {
            }
          }() == ("focus" === t2);
        }
        function Ee(e2, t2, n2, r2, i2, o2) {
          var a2, s2;
          if ("object" == typeof t2) {
            for (s2 in "string" != typeof n2 && (r2 = r2 || n2, n2 = void 0), t2)
              Ee(e2, s2, n2, r2, t2[s2], o2);
            return e2;
          }
          if (null == r2 && null == i2 ? (i2 = n2, r2 = n2 = void 0) : null == i2 && ("string" == typeof n2 ? (i2 = r2, r2 = void 0) : (i2 = r2, r2 = n2, n2 = void 0)), false === i2)
            i2 = Te;
          else if (!i2)
            return e2;
          return 1 === o2 && (a2 = i2, (i2 = function(e3) {
            return S().off(e3), a2.apply(this, arguments);
          }).guid = a2.guid || (a2.guid = S.guid++)), e2.each(function() {
            S.event.add(this, t2, i2, r2, n2);
          });
        }
        function Se(e2, i2, o2) {
          o2 ? (Y.set(e2, i2, false), S.event.add(e2, i2, { namespace: false, handler: function(e3) {
            var t2, n2, r2 = Y.get(this, i2);
            if (1 & e3.isTrigger && this[i2]) {
              if (r2.length)
                (S.event.special[i2] || {}).delegateType && e3.stopPropagation();
              else if (r2 = s.call(arguments), Y.set(this, i2, r2), t2 = o2(this, i2), this[i2](), r2 !== (n2 = Y.get(this, i2)) || t2 ? Y.set(this, i2, false) : n2 = {}, r2 !== n2)
                return e3.stopImmediatePropagation(), e3.preventDefault(), n2 && n2.value;
            } else
              r2.length && (Y.set(this, i2, { value: S.event.trigger(S.extend(r2[0], S.Event.prototype), r2.slice(1), this) }), e3.stopImmediatePropagation());
          } })) : void 0 === Y.get(e2, i2) && S.event.add(e2, i2, we);
        }
        S.event = { global: {}, add: function(t2, e2, n2, r2, i2) {
          var o2, a2, s2, u2, l2, c2, f2, p2, d2, h2, g2, v2 = Y.get(t2);
          if (V(t2)) {
            n2.handler && (n2 = (o2 = n2).handler, i2 = o2.selector), i2 && S.find.matchesSelector(re, i2), n2.guid || (n2.guid = S.guid++), (u2 = v2.events) || (u2 = v2.events = /* @__PURE__ */ Object.create(null)), (a2 = v2.handle) || (a2 = v2.handle = function(e3) {
              return "undefined" != typeof S && S.event.triggered !== e3.type ? S.event.dispatch.apply(t2, arguments) : void 0;
            }), l2 = (e2 = (e2 || "").match(P) || [""]).length;
            while (l2--)
              d2 = g2 = (s2 = be.exec(e2[l2]) || [])[1], h2 = (s2[2] || "").split(".").sort(), d2 && (f2 = S.event.special[d2] || {}, d2 = (i2 ? f2.delegateType : f2.bindType) || d2, f2 = S.event.special[d2] || {}, c2 = S.extend({ type: d2, origType: g2, data: r2, handler: n2, guid: n2.guid, selector: i2, needsContext: i2 && S.expr.match.needsContext.test(i2), namespace: h2.join(".") }, o2), (p2 = u2[d2]) || ((p2 = u2[d2] = []).delegateCount = 0, f2.setup && false !== f2.setup.call(t2, r2, h2, a2) || t2.addEventListener && t2.addEventListener(d2, a2)), f2.add && (f2.add.call(t2, c2), c2.handler.guid || (c2.handler.guid = n2.guid)), i2 ? p2.splice(p2.delegateCount++, 0, c2) : p2.push(c2), S.event.global[d2] = true);
          }
        }, remove: function(e2, t2, n2, r2, i2) {
          var o2, a2, s2, u2, l2, c2, f2, p2, d2, h2, g2, v2 = Y.hasData(e2) && Y.get(e2);
          if (v2 && (u2 = v2.events)) {
            l2 = (t2 = (t2 || "").match(P) || [""]).length;
            while (l2--)
              if (d2 = g2 = (s2 = be.exec(t2[l2]) || [])[1], h2 = (s2[2] || "").split(".").sort(), d2) {
                f2 = S.event.special[d2] || {}, p2 = u2[d2 = (r2 ? f2.delegateType : f2.bindType) || d2] || [], s2 = s2[2] && new RegExp("(^|\\.)" + h2.join("\\.(?:.*\\.|)") + "(\\.|$)"), a2 = o2 = p2.length;
                while (o2--)
                  c2 = p2[o2], !i2 && g2 !== c2.origType || n2 && n2.guid !== c2.guid || s2 && !s2.test(c2.namespace) || r2 && r2 !== c2.selector && ("**" !== r2 || !c2.selector) || (p2.splice(o2, 1), c2.selector && p2.delegateCount--, f2.remove && f2.remove.call(e2, c2));
                a2 && !p2.length && (f2.teardown && false !== f2.teardown.call(e2, h2, v2.handle) || S.removeEvent(e2, d2, v2.handle), delete u2[d2]);
              } else
                for (d2 in u2)
                  S.event.remove(e2, d2 + t2[l2], n2, r2, true);
            S.isEmptyObject(u2) && Y.remove(e2, "handle events");
          }
        }, dispatch: function(e2) {
          var t2, n2, r2, i2, o2, a2, s2 = new Array(arguments.length), u2 = S.event.fix(e2), l2 = (Y.get(this, "events") || /* @__PURE__ */ Object.create(null))[u2.type] || [], c2 = S.event.special[u2.type] || {};
          for (s2[0] = u2, t2 = 1; t2 < arguments.length; t2++)
            s2[t2] = arguments[t2];
          if (u2.delegateTarget = this, !c2.preDispatch || false !== c2.preDispatch.call(this, u2)) {
            a2 = S.event.handlers.call(this, u2, l2), t2 = 0;
            while ((i2 = a2[t2++]) && !u2.isPropagationStopped()) {
              u2.currentTarget = i2.elem, n2 = 0;
              while ((o2 = i2.handlers[n2++]) && !u2.isImmediatePropagationStopped())
                u2.rnamespace && false !== o2.namespace && !u2.rnamespace.test(o2.namespace) || (u2.handleObj = o2, u2.data = o2.data, void 0 !== (r2 = ((S.event.special[o2.origType] || {}).handle || o2.handler).apply(i2.elem, s2)) && false === (u2.result = r2) && (u2.preventDefault(), u2.stopPropagation()));
            }
            return c2.postDispatch && c2.postDispatch.call(this, u2), u2.result;
          }
        }, handlers: function(e2, t2) {
          var n2, r2, i2, o2, a2, s2 = [], u2 = t2.delegateCount, l2 = e2.target;
          if (u2 && l2.nodeType && !("click" === e2.type && 1 <= e2.button)) {
            for (; l2 !== this; l2 = l2.parentNode || this)
              if (1 === l2.nodeType && ("click" !== e2.type || true !== l2.disabled)) {
                for (o2 = [], a2 = {}, n2 = 0; n2 < u2; n2++)
                  void 0 === a2[i2 = (r2 = t2[n2]).selector + " "] && (a2[i2] = r2.needsContext ? -1 < S(i2, this).index(l2) : S.find(i2, this, null, [l2]).length), a2[i2] && o2.push(r2);
                o2.length && s2.push({ elem: l2, handlers: o2 });
              }
          }
          return l2 = this, u2 < t2.length && s2.push({ elem: l2, handlers: t2.slice(u2) }), s2;
        }, addProp: function(t2, e2) {
          Object.defineProperty(S.Event.prototype, t2, { enumerable: true, configurable: true, get: m(e2) ? function() {
            if (this.originalEvent)
              return e2(this.originalEvent);
          } : function() {
            if (this.originalEvent)
              return this.originalEvent[t2];
          }, set: function(e3) {
            Object.defineProperty(this, t2, { enumerable: true, configurable: true, writable: true, value: e3 });
          } });
        }, fix: function(e2) {
          return e2[S.expando] ? e2 : new S.Event(e2);
        }, special: { load: { noBubble: true }, click: { setup: function(e2) {
          var t2 = this || e2;
          return pe.test(t2.type) && t2.click && A(t2, "input") && Se(t2, "click", we), false;
        }, trigger: function(e2) {
          var t2 = this || e2;
          return pe.test(t2.type) && t2.click && A(t2, "input") && Se(t2, "click"), true;
        }, _default: function(e2) {
          var t2 = e2.target;
          return pe.test(t2.type) && t2.click && A(t2, "input") && Y.get(t2, "click") || A(t2, "a");
        } }, beforeunload: { postDispatch: function(e2) {
          void 0 !== e2.result && e2.originalEvent && (e2.originalEvent.returnValue = e2.result);
        } } } }, S.removeEvent = function(e2, t2, n2) {
          e2.removeEventListener && e2.removeEventListener(t2, n2);
        }, S.Event = function(e2, t2) {
          if (!(this instanceof S.Event))
            return new S.Event(e2, t2);
          e2 && e2.type ? (this.originalEvent = e2, this.type = e2.type, this.isDefaultPrevented = e2.defaultPrevented || void 0 === e2.defaultPrevented && false === e2.returnValue ? we : Te, this.target = e2.target && 3 === e2.target.nodeType ? e2.target.parentNode : e2.target, this.currentTarget = e2.currentTarget, this.relatedTarget = e2.relatedTarget) : this.type = e2, t2 && S.extend(this, t2), this.timeStamp = e2 && e2.timeStamp || Date.now(), this[S.expando] = true;
        }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Te, isPropagationStopped: Te, isImmediatePropagationStopped: Te, isSimulated: false, preventDefault: function() {
          var e2 = this.originalEvent;
          this.isDefaultPrevented = we, e2 && !this.isSimulated && e2.preventDefault();
        }, stopPropagation: function() {
          var e2 = this.originalEvent;
          this.isPropagationStopped = we, e2 && !this.isSimulated && e2.stopPropagation();
        }, stopImmediatePropagation: function() {
          var e2 = this.originalEvent;
          this.isImmediatePropagationStopped = we, e2 && !this.isSimulated && e2.stopImmediatePropagation(), this.stopPropagation();
        } }, S.each({ altKey: true, bubbles: true, cancelable: true, changedTouches: true, ctrlKey: true, detail: true, eventPhase: true, metaKey: true, pageX: true, pageY: true, shiftKey: true, view: true, "char": true, code: true, charCode: true, key: true, keyCode: true, button: true, buttons: true, clientX: true, clientY: true, offsetX: true, offsetY: true, pointerId: true, pointerType: true, screenX: true, screenY: true, targetTouches: true, toElement: true, touches: true, which: true }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function(e2, t2) {
          S.event.special[e2] = { setup: function() {
            return Se(this, e2, Ce), false;
          }, trigger: function() {
            return Se(this, e2), true;
          }, _default: function() {
            return true;
          }, delegateType: t2 };
        }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(e2, i2) {
          S.event.special[e2] = { delegateType: i2, bindType: i2, handle: function(e3) {
            var t2, n2 = e3.relatedTarget, r2 = e3.handleObj;
            return n2 && (n2 === this || S.contains(this, n2)) || (e3.type = r2.origType, t2 = r2.handler.apply(this, arguments), e3.type = i2), t2;
          } };
        }), S.fn.extend({ on: function(e2, t2, n2, r2) {
          return Ee(this, e2, t2, n2, r2);
        }, one: function(e2, t2, n2, r2) {
          return Ee(this, e2, t2, n2, r2, 1);
        }, off: function(e2, t2, n2) {
          var r2, i2;
          if (e2 && e2.preventDefault && e2.handleObj)
            return r2 = e2.handleObj, S(e2.delegateTarget).off(r2.namespace ? r2.origType + "." + r2.namespace : r2.origType, r2.selector, r2.handler), this;
          if ("object" == typeof e2) {
            for (i2 in e2)
              this.off(i2, t2, e2[i2]);
            return this;
          }
          return false !== t2 && "function" != typeof t2 || (n2 = t2, t2 = void 0), false === n2 && (n2 = Te), this.each(function() {
            S.event.remove(this, e2, n2, t2);
          });
        } });
        var ke = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function je(e2, t2) {
          return A(e2, "table") && A(11 !== t2.nodeType ? t2 : t2.firstChild, "tr") && S(e2).children("tbody")[0] || e2;
        }
        function De(e2) {
          return e2.type = (null !== e2.getAttribute("type")) + "/" + e2.type, e2;
        }
        function qe(e2) {
          return "true/" === (e2.type || "").slice(0, 5) ? e2.type = e2.type.slice(5) : e2.removeAttribute("type"), e2;
        }
        function Le(e2, t2) {
          var n2, r2, i2, o2, a2, s2;
          if (1 === t2.nodeType) {
            if (Y.hasData(e2) && (s2 = Y.get(e2).events))
              for (i2 in Y.remove(t2, "handle events"), s2)
                for (n2 = 0, r2 = s2[i2].length; n2 < r2; n2++)
                  S.event.add(t2, i2, s2[i2][n2]);
            Q.hasData(e2) && (o2 = Q.access(e2), a2 = S.extend({}, o2), Q.set(t2, a2));
          }
        }
        function He(n2, r2, i2, o2) {
          r2 = g(r2);
          var e2, t2, a2, s2, u2, l2, c2 = 0, f2 = n2.length, p2 = f2 - 1, d2 = r2[0], h2 = m(d2);
          if (h2 || 1 < f2 && "string" == typeof d2 && !y.checkClone && Ae.test(d2))
            return n2.each(function(e3) {
              var t3 = n2.eq(e3);
              h2 && (r2[0] = d2.call(this, e3, t3.html())), He(t3, r2, i2, o2);
            });
          if (f2 && (t2 = (e2 = xe(r2, n2[0].ownerDocument, false, n2, o2)).firstChild, 1 === e2.childNodes.length && (e2 = t2), t2 || o2)) {
            for (s2 = (a2 = S.map(ve(e2, "script"), De)).length; c2 < f2; c2++)
              u2 = e2, c2 !== p2 && (u2 = S.clone(u2, true, true), s2 && S.merge(a2, ve(u2, "script"))), i2.call(n2[c2], u2, c2);
            if (s2)
              for (l2 = a2[a2.length - 1].ownerDocument, S.map(a2, qe), c2 = 0; c2 < s2; c2++)
                u2 = a2[c2], he.test(u2.type || "") && !Y.access(u2, "globalEval") && S.contains(l2, u2) && (u2.src && "module" !== (u2.type || "").toLowerCase() ? S._evalUrl && !u2.noModule && S._evalUrl(u2.src, { nonce: u2.nonce || u2.getAttribute("nonce") }, l2) : b(u2.textContent.replace(Ne, ""), u2, l2));
          }
          return n2;
        }
        function Oe(e2, t2, n2) {
          for (var r2, i2 = t2 ? S.filter(t2, e2) : e2, o2 = 0; null != (r2 = i2[o2]); o2++)
            n2 || 1 !== r2.nodeType || S.cleanData(ve(r2)), r2.parentNode && (n2 && ie(r2) && ye(ve(r2, "script")), r2.parentNode.removeChild(r2));
          return e2;
        }
        S.extend({ htmlPrefilter: function(e2) {
          return e2;
        }, clone: function(e2, t2, n2) {
          var r2, i2, o2, a2, s2, u2, l2, c2 = e2.cloneNode(true), f2 = ie(e2);
          if (!(y.noCloneChecked || 1 !== e2.nodeType && 11 !== e2.nodeType || S.isXMLDoc(e2)))
            for (a2 = ve(c2), r2 = 0, i2 = (o2 = ve(e2)).length; r2 < i2; r2++)
              s2 = o2[r2], u2 = a2[r2], void 0, "input" === (l2 = u2.nodeName.toLowerCase()) && pe.test(s2.type) ? u2.checked = s2.checked : "input" !== l2 && "textarea" !== l2 || (u2.defaultValue = s2.defaultValue);
          if (t2)
            if (n2)
              for (o2 = o2 || ve(e2), a2 = a2 || ve(c2), r2 = 0, i2 = o2.length; r2 < i2; r2++)
                Le(o2[r2], a2[r2]);
            else
              Le(e2, c2);
          return 0 < (a2 = ve(c2, "script")).length && ye(a2, !f2 && ve(e2, "script")), c2;
        }, cleanData: function(e2) {
          for (var t2, n2, r2, i2 = S.event.special, o2 = 0; void 0 !== (n2 = e2[o2]); o2++)
            if (V(n2)) {
              if (t2 = n2[Y.expando]) {
                if (t2.events)
                  for (r2 in t2.events)
                    i2[r2] ? S.event.remove(n2, r2) : S.removeEvent(n2, r2, t2.handle);
                n2[Y.expando] = void 0;
              }
              n2[Q.expando] && (n2[Q.expando] = void 0);
            }
        } }), S.fn.extend({ detach: function(e2) {
          return Oe(this, e2, true);
        }, remove: function(e2) {
          return Oe(this, e2);
        }, text: function(e2) {
          return $2(this, function(e3) {
            return void 0 === e3 ? S.text(this) : this.empty().each(function() {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e3);
            });
          }, null, e2, arguments.length);
        }, append: function() {
          return He(this, arguments, function(e2) {
            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e2).appendChild(e2);
          });
        }, prepend: function() {
          return He(this, arguments, function(e2) {
            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
              var t2 = je(this, e2);
              t2.insertBefore(e2, t2.firstChild);
            }
          });
        }, before: function() {
          return He(this, arguments, function(e2) {
            this.parentNode && this.parentNode.insertBefore(e2, this);
          });
        }, after: function() {
          return He(this, arguments, function(e2) {
            this.parentNode && this.parentNode.insertBefore(e2, this.nextSibling);
          });
        }, empty: function() {
          for (var e2, t2 = 0; null != (e2 = this[t2]); t2++)
            1 === e2.nodeType && (S.cleanData(ve(e2, false)), e2.textContent = "");
          return this;
        }, clone: function(e2, t2) {
          return e2 = null != e2 && e2, t2 = null == t2 ? e2 : t2, this.map(function() {
            return S.clone(this, e2, t2);
          });
        }, html: function(e2) {
          return $2(this, function(e3) {
            var t2 = this[0] || {}, n2 = 0, r2 = this.length;
            if (void 0 === e3 && 1 === t2.nodeType)
              return t2.innerHTML;
            if ("string" == typeof e3 && !ke.test(e3) && !ge[(de.exec(e3) || ["", ""])[1].toLowerCase()]) {
              e3 = S.htmlPrefilter(e3);
              try {
                for (; n2 < r2; n2++)
                  1 === (t2 = this[n2] || {}).nodeType && (S.cleanData(ve(t2, false)), t2.innerHTML = e3);
                t2 = 0;
              } catch (e4) {
              }
            }
            t2 && this.empty().append(e3);
          }, null, e2, arguments.length);
        }, replaceWith: function() {
          var n2 = [];
          return He(this, arguments, function(e2) {
            var t2 = this.parentNode;
            S.inArray(this, n2) < 0 && (S.cleanData(ve(this)), t2 && t2.replaceChild(e2, this));
          }, n2);
        } }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(e2, a2) {
          S.fn[e2] = function(e3) {
            for (var t2, n2 = [], r2 = S(e3), i2 = r2.length - 1, o2 = 0; o2 <= i2; o2++)
              t2 = o2 === i2 ? this : this.clone(true), S(r2[o2])[a2](t2), u.apply(n2, t2.get());
            return this.pushStack(n2);
          };
        });
        var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Re = function(e2) {
          var t2 = e2.ownerDocument.defaultView;
          return t2 && t2.opener || (t2 = C), t2.getComputedStyle(e2);
        }, Me = function(e2, t2, n2) {
          var r2, i2, o2 = {};
          for (i2 in t2)
            o2[i2] = e2.style[i2], e2.style[i2] = t2[i2];
          for (i2 in r2 = n2.call(e2), t2)
            e2.style[i2] = o2[i2];
          return r2;
        }, Ie = new RegExp(ne.join("|"), "i");
        function We(e2, t2, n2) {
          var r2, i2, o2, a2, s2 = e2.style;
          return (n2 = n2 || Re(e2)) && ("" !== (a2 = n2.getPropertyValue(t2) || n2[t2]) || ie(e2) || (a2 = S.style(e2, t2)), !y.pixelBoxStyles() && Pe.test(a2) && Ie.test(t2) && (r2 = s2.width, i2 = s2.minWidth, o2 = s2.maxWidth, s2.minWidth = s2.maxWidth = s2.width = a2, a2 = n2.width, s2.width = r2, s2.minWidth = i2, s2.maxWidth = o2)), void 0 !== a2 ? a2 + "" : a2;
        }
        function Fe(e2, t2) {
          return { get: function() {
            if (!e2())
              return (this.get = t2).apply(this, arguments);
            delete this.get;
          } };
        }
        !function() {
          function e2() {
            if (l2) {
              u2.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u2).appendChild(l2);
              var e3 = C.getComputedStyle(l2);
              n2 = "1%" !== e3.top, s2 = 12 === t2(e3.marginLeft), l2.style.right = "60%", o2 = 36 === t2(e3.right), r2 = 36 === t2(e3.width), l2.style.position = "absolute", i2 = 12 === t2(l2.offsetWidth / 3), re.removeChild(u2), l2 = null;
            }
          }
          function t2(e3) {
            return Math.round(parseFloat(e3));
          }
          var n2, r2, i2, o2, a2, s2, u2 = E.createElement("div"), l2 = E.createElement("div");
          l2.style && (l2.style.backgroundClip = "content-box", l2.cloneNode(true).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l2.style.backgroundClip, S.extend(y, { boxSizingReliable: function() {
            return e2(), r2;
          }, pixelBoxStyles: function() {
            return e2(), o2;
          }, pixelPosition: function() {
            return e2(), n2;
          }, reliableMarginLeft: function() {
            return e2(), s2;
          }, scrollboxSize: function() {
            return e2(), i2;
          }, reliableTrDimensions: function() {
            var e3, t3, n3, r3;
            return null == a2 && (e3 = E.createElement("table"), t3 = E.createElement("tr"), n3 = E.createElement("div"), e3.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t3.style.cssText = "border:1px solid", t3.style.height = "1px", n3.style.height = "9px", n3.style.display = "block", re.appendChild(e3).appendChild(t3).appendChild(n3), r3 = C.getComputedStyle(t3), a2 = parseInt(r3.height, 10) + parseInt(r3.borderTopWidth, 10) + parseInt(r3.borderBottomWidth, 10) === t3.offsetHeight, re.removeChild(e3)), a2;
          } }));
        }();
        var Be = ["Webkit", "Moz", "ms"], $e = E.createElement("div").style, _e = {};
        function ze(e2) {
          var t2 = S.cssProps[e2] || _e[e2];
          return t2 || (e2 in $e ? e2 : _e[e2] = function(e3) {
            var t3 = e3[0].toUpperCase() + e3.slice(1), n2 = Be.length;
            while (n2--)
              if ((e3 = Be[n2] + t3) in $e)
                return e3;
          }(e2) || e2);
        }
        var Ue = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ve = { position: "absolute", visibility: "hidden", display: "block" }, Ge = { letterSpacing: "0", fontWeight: "400" };
        function Ye(e2, t2, n2) {
          var r2 = te.exec(t2);
          return r2 ? Math.max(0, r2[2] - (n2 || 0)) + (r2[3] || "px") : t2;
        }
        function Qe(e2, t2, n2, r2, i2, o2) {
          var a2 = "width" === t2 ? 1 : 0, s2 = 0, u2 = 0;
          if (n2 === (r2 ? "border" : "content"))
            return 0;
          for (; a2 < 4; a2 += 2)
            "margin" === n2 && (u2 += S.css(e2, n2 + ne[a2], true, i2)), r2 ? ("content" === n2 && (u2 -= S.css(e2, "padding" + ne[a2], true, i2)), "margin" !== n2 && (u2 -= S.css(e2, "border" + ne[a2] + "Width", true, i2))) : (u2 += S.css(e2, "padding" + ne[a2], true, i2), "padding" !== n2 ? u2 += S.css(e2, "border" + ne[a2] + "Width", true, i2) : s2 += S.css(e2, "border" + ne[a2] + "Width", true, i2));
          return !r2 && 0 <= o2 && (u2 += Math.max(0, Math.ceil(e2["offset" + t2[0].toUpperCase() + t2.slice(1)] - o2 - u2 - s2 - 0.5)) || 0), u2;
        }
        function Je(e2, t2, n2) {
          var r2 = Re(e2), i2 = (!y.boxSizingReliable() || n2) && "border-box" === S.css(e2, "boxSizing", false, r2), o2 = i2, a2 = We(e2, t2, r2), s2 = "offset" + t2[0].toUpperCase() + t2.slice(1);
          if (Pe.test(a2)) {
            if (!n2)
              return a2;
            a2 = "auto";
          }
          return (!y.boxSizingReliable() && i2 || !y.reliableTrDimensions() && A(e2, "tr") || "auto" === a2 || !parseFloat(a2) && "inline" === S.css(e2, "display", false, r2)) && e2.getClientRects().length && (i2 = "border-box" === S.css(e2, "boxSizing", false, r2), (o2 = s2 in e2) && (a2 = e2[s2])), (a2 = parseFloat(a2) || 0) + Qe(e2, t2, n2 || (i2 ? "border" : "content"), o2, r2, a2) + "px";
        }
        function Ke(e2, t2, n2, r2, i2) {
          return new Ke.prototype.init(e2, t2, n2, r2, i2);
        }
        S.extend({ cssHooks: { opacity: { get: function(e2, t2) {
          if (t2) {
            var n2 = We(e2, "opacity");
            return "" === n2 ? "1" : n2;
          }
        } } }, cssNumber: { animationIterationCount: true, columnCount: true, fillOpacity: true, flexGrow: true, flexShrink: true, fontWeight: true, gridArea: true, gridColumn: true, gridColumnEnd: true, gridColumnStart: true, gridRow: true, gridRowEnd: true, gridRowStart: true, lineHeight: true, opacity: true, order: true, orphans: true, widows: true, zIndex: true, zoom: true }, cssProps: {}, style: function(e2, t2, n2, r2) {
          if (e2 && 3 !== e2.nodeType && 8 !== e2.nodeType && e2.style) {
            var i2, o2, a2, s2 = X(t2), u2 = Xe.test(t2), l2 = e2.style;
            if (u2 || (t2 = ze(s2)), a2 = S.cssHooks[t2] || S.cssHooks[s2], void 0 === n2)
              return a2 && "get" in a2 && void 0 !== (i2 = a2.get(e2, false, r2)) ? i2 : l2[t2];
            "string" === (o2 = typeof n2) && (i2 = te.exec(n2)) && i2[1] && (n2 = se(e2, t2, i2), o2 = "number"), null != n2 && n2 == n2 && ("number" !== o2 || u2 || (n2 += i2 && i2[3] || (S.cssNumber[s2] ? "" : "px")), y.clearCloneStyle || "" !== n2 || 0 !== t2.indexOf("background") || (l2[t2] = "inherit"), a2 && "set" in a2 && void 0 === (n2 = a2.set(e2, n2, r2)) || (u2 ? l2.setProperty(t2, n2) : l2[t2] = n2));
          }
        }, css: function(e2, t2, n2, r2) {
          var i2, o2, a2, s2 = X(t2);
          return Xe.test(t2) || (t2 = ze(s2)), (a2 = S.cssHooks[t2] || S.cssHooks[s2]) && "get" in a2 && (i2 = a2.get(e2, true, n2)), void 0 === i2 && (i2 = We(e2, t2, r2)), "normal" === i2 && t2 in Ge && (i2 = Ge[t2]), "" === n2 || n2 ? (o2 = parseFloat(i2), true === n2 || isFinite(o2) ? o2 || 0 : i2) : i2;
        } }), S.each(["height", "width"], function(e2, u2) {
          S.cssHooks[u2] = { get: function(e3, t2, n2) {
            if (t2)
              return !Ue.test(S.css(e3, "display")) || e3.getClientRects().length && e3.getBoundingClientRect().width ? Je(e3, u2, n2) : Me(e3, Ve, function() {
                return Je(e3, u2, n2);
              });
          }, set: function(e3, t2, n2) {
            var r2, i2 = Re(e3), o2 = !y.scrollboxSize() && "absolute" === i2.position, a2 = (o2 || n2) && "border-box" === S.css(e3, "boxSizing", false, i2), s2 = n2 ? Qe(e3, u2, n2, a2, i2) : 0;
            return a2 && o2 && (s2 -= Math.ceil(e3["offset" + u2[0].toUpperCase() + u2.slice(1)] - parseFloat(i2[u2]) - Qe(e3, u2, "border", false, i2) - 0.5)), s2 && (r2 = te.exec(t2)) && "px" !== (r2[3] || "px") && (e3.style[u2] = t2, t2 = S.css(e3, u2)), Ye(0, t2, s2);
          } };
        }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function(e2, t2) {
          if (t2)
            return (parseFloat(We(e2, "marginLeft")) || e2.getBoundingClientRect().left - Me(e2, { marginLeft: 0 }, function() {
              return e2.getBoundingClientRect().left;
            })) + "px";
        }), S.each({ margin: "", padding: "", border: "Width" }, function(i2, o2) {
          S.cssHooks[i2 + o2] = { expand: function(e2) {
            for (var t2 = 0, n2 = {}, r2 = "string" == typeof e2 ? e2.split(" ") : [e2]; t2 < 4; t2++)
              n2[i2 + ne[t2] + o2] = r2[t2] || r2[t2 - 2] || r2[0];
            return n2;
          } }, "margin" !== i2 && (S.cssHooks[i2 + o2].set = Ye);
        }), S.fn.extend({ css: function(e2, t2) {
          return $2(this, function(e3, t3, n2) {
            var r2, i2, o2 = {}, a2 = 0;
            if (Array.isArray(t3)) {
              for (r2 = Re(e3), i2 = t3.length; a2 < i2; a2++)
                o2[t3[a2]] = S.css(e3, t3[a2], false, r2);
              return o2;
            }
            return void 0 !== n2 ? S.style(e3, t3, n2) : S.css(e3, t3);
          }, e2, t2, 1 < arguments.length);
        } }), ((S.Tween = Ke).prototype = { constructor: Ke, init: function(e2, t2, n2, r2, i2, o2) {
          this.elem = e2, this.prop = n2, this.easing = i2 || S.easing._default, this.options = t2, this.start = this.now = this.cur(), this.end = r2, this.unit = o2 || (S.cssNumber[n2] ? "" : "px");
        }, cur: function() {
          var e2 = Ke.propHooks[this.prop];
          return e2 && e2.get ? e2.get(this) : Ke.propHooks._default.get(this);
        }, run: function(e2) {
          var t2, n2 = Ke.propHooks[this.prop];
          return this.options.duration ? this.pos = t2 = S.easing[this.easing](e2, this.options.duration * e2, 0, 1, this.options.duration) : this.pos = t2 = e2, this.now = (this.end - this.start) * t2 + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n2 && n2.set ? n2.set(this) : Ke.propHooks._default.set(this), this;
        } }).init.prototype = Ke.prototype, (Ke.propHooks = { _default: { get: function(e2) {
          var t2;
          return 1 !== e2.elem.nodeType || null != e2.elem[e2.prop] && null == e2.elem.style[e2.prop] ? e2.elem[e2.prop] : (t2 = S.css(e2.elem, e2.prop, "")) && "auto" !== t2 ? t2 : 0;
        }, set: function(e2) {
          S.fx.step[e2.prop] ? S.fx.step[e2.prop](e2) : 1 !== e2.elem.nodeType || !S.cssHooks[e2.prop] && null == e2.elem.style[ze(e2.prop)] ? e2.elem[e2.prop] = e2.now : S.style(e2.elem, e2.prop, e2.now + e2.unit);
        } } }).scrollTop = Ke.propHooks.scrollLeft = { set: function(e2) {
          e2.elem.nodeType && e2.elem.parentNode && (e2.elem[e2.prop] = e2.now);
        } }, S.easing = { linear: function(e2) {
          return e2;
        }, swing: function(e2) {
          return 0.5 - Math.cos(e2 * Math.PI) / 2;
        }, _default: "swing" }, S.fx = Ke.prototype.init, S.fx.step = {};
        var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/;
        function ot() {
          et && (false === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick());
        }
        function at() {
          return C.setTimeout(function() {
            Ze = void 0;
          }), Ze = Date.now();
        }
        function st(e2, t2) {
          var n2, r2 = 0, i2 = { height: e2 };
          for (t2 = t2 ? 1 : 0; r2 < 4; r2 += 2 - t2)
            i2["margin" + (n2 = ne[r2])] = i2["padding" + n2] = e2;
          return t2 && (i2.opacity = i2.width = e2), i2;
        }
        function ut(e2, t2, n2) {
          for (var r2, i2 = (lt.tweeners[t2] || []).concat(lt.tweeners["*"]), o2 = 0, a2 = i2.length; o2 < a2; o2++)
            if (r2 = i2[o2].call(n2, t2, e2))
              return r2;
        }
        function lt(o2, e2, t2) {
          var n2, a2, r2 = 0, i2 = lt.prefilters.length, s2 = S.Deferred().always(function() {
            delete u2.elem;
          }), u2 = function() {
            if (a2)
              return false;
            for (var e3 = Ze || at(), t3 = Math.max(0, l2.startTime + l2.duration - e3), n3 = 1 - (t3 / l2.duration || 0), r3 = 0, i3 = l2.tweens.length; r3 < i3; r3++)
              l2.tweens[r3].run(n3);
            return s2.notifyWith(o2, [l2, n3, t3]), n3 < 1 && i3 ? t3 : (i3 || s2.notifyWith(o2, [l2, 1, 0]), s2.resolveWith(o2, [l2]), false);
          }, l2 = s2.promise({ elem: o2, props: S.extend({}, e2), opts: S.extend(true, { specialEasing: {}, easing: S.easing._default }, t2), originalProperties: e2, originalOptions: t2, startTime: Ze || at(), duration: t2.duration, tweens: [], createTween: function(e3, t3) {
            var n3 = S.Tween(o2, l2.opts, e3, t3, l2.opts.specialEasing[e3] || l2.opts.easing);
            return l2.tweens.push(n3), n3;
          }, stop: function(e3) {
            var t3 = 0, n3 = e3 ? l2.tweens.length : 0;
            if (a2)
              return this;
            for (a2 = true; t3 < n3; t3++)
              l2.tweens[t3].run(1);
            return e3 ? (s2.notifyWith(o2, [l2, 1, 0]), s2.resolveWith(o2, [l2, e3])) : s2.rejectWith(o2, [l2, e3]), this;
          } }), c2 = l2.props;
          for (!function(e3, t3) {
            var n3, r3, i3, o3, a3;
            for (n3 in e3)
              if (i3 = t3[r3 = X(n3)], o3 = e3[n3], Array.isArray(o3) && (i3 = o3[1], o3 = e3[n3] = o3[0]), n3 !== r3 && (e3[r3] = o3, delete e3[n3]), (a3 = S.cssHooks[r3]) && "expand" in a3)
                for (n3 in o3 = a3.expand(o3), delete e3[r3], o3)
                  n3 in e3 || (e3[n3] = o3[n3], t3[n3] = i3);
              else
                t3[r3] = i3;
          }(c2, l2.opts.specialEasing); r2 < i2; r2++)
            if (n2 = lt.prefilters[r2].call(l2, o2, c2, l2.opts))
              return m(n2.stop) && (S._queueHooks(l2.elem, l2.opts.queue).stop = n2.stop.bind(n2)), n2;
          return S.map(c2, ut, l2), m(l2.opts.start) && l2.opts.start.call(o2, l2), l2.progress(l2.opts.progress).done(l2.opts.done, l2.opts.complete).fail(l2.opts.fail).always(l2.opts.always), S.fx.timer(S.extend(u2, { elem: o2, anim: l2, queue: l2.opts.queue })), l2;
        }
        S.Animation = S.extend(lt, { tweeners: { "*": [function(e2, t2) {
          var n2 = this.createTween(e2, t2);
          return se(n2.elem, e2, te.exec(t2), n2), n2;
        }] }, tweener: function(e2, t2) {
          m(e2) ? (t2 = e2, e2 = ["*"]) : e2 = e2.match(P);
          for (var n2, r2 = 0, i2 = e2.length; r2 < i2; r2++)
            n2 = e2[r2], lt.tweeners[n2] = lt.tweeners[n2] || [], lt.tweeners[n2].unshift(t2);
        }, prefilters: [function(e2, t2, n2) {
          var r2, i2, o2, a2, s2, u2, l2, c2, f2 = "width" in t2 || "height" in t2, p2 = this, d2 = {}, h2 = e2.style, g2 = e2.nodeType && ae(e2), v2 = Y.get(e2, "fxshow");
          for (r2 in n2.queue || (null == (a2 = S._queueHooks(e2, "fx")).unqueued && (a2.unqueued = 0, s2 = a2.empty.fire, a2.empty.fire = function() {
            a2.unqueued || s2();
          }), a2.unqueued++, p2.always(function() {
            p2.always(function() {
              a2.unqueued--, S.queue(e2, "fx").length || a2.empty.fire();
            });
          })), t2)
            if (i2 = t2[r2], rt.test(i2)) {
              if (delete t2[r2], o2 = o2 || "toggle" === i2, i2 === (g2 ? "hide" : "show")) {
                if ("show" !== i2 || !v2 || void 0 === v2[r2])
                  continue;
                g2 = true;
              }
              d2[r2] = v2 && v2[r2] || S.style(e2, r2);
            }
          if ((u2 = !S.isEmptyObject(t2)) || !S.isEmptyObject(d2))
            for (r2 in f2 && 1 === e2.nodeType && (n2.overflow = [h2.overflow, h2.overflowX, h2.overflowY], null == (l2 = v2 && v2.display) && (l2 = Y.get(e2, "display")), "none" === (c2 = S.css(e2, "display")) && (l2 ? c2 = l2 : (le([e2], true), l2 = e2.style.display || l2, c2 = S.css(e2, "display"), le([e2]))), ("inline" === c2 || "inline-block" === c2 && null != l2) && "none" === S.css(e2, "float") && (u2 || (p2.done(function() {
              h2.display = l2;
            }), null == l2 && (c2 = h2.display, l2 = "none" === c2 ? "" : c2)), h2.display = "inline-block")), n2.overflow && (h2.overflow = "hidden", p2.always(function() {
              h2.overflow = n2.overflow[0], h2.overflowX = n2.overflow[1], h2.overflowY = n2.overflow[2];
            })), u2 = false, d2)
              u2 || (v2 ? "hidden" in v2 && (g2 = v2.hidden) : v2 = Y.access(e2, "fxshow", { display: l2 }), o2 && (v2.hidden = !g2), g2 && le([e2], true), p2.done(function() {
                for (r2 in g2 || le([e2]), Y.remove(e2, "fxshow"), d2)
                  S.style(e2, r2, d2[r2]);
              })), u2 = ut(g2 ? v2[r2] : 0, r2, p2), r2 in v2 || (v2[r2] = u2.start, g2 && (u2.end = u2.start, u2.start = 0));
        }], prefilter: function(e2, t2) {
          t2 ? lt.prefilters.unshift(e2) : lt.prefilters.push(e2);
        } }), S.speed = function(e2, t2, n2) {
          var r2 = e2 && "object" == typeof e2 ? S.extend({}, e2) : { complete: n2 || !n2 && t2 || m(e2) && e2, duration: e2, easing: n2 && t2 || t2 && !m(t2) && t2 };
          return S.fx.off ? r2.duration = 0 : "number" != typeof r2.duration && (r2.duration in S.fx.speeds ? r2.duration = S.fx.speeds[r2.duration] : r2.duration = S.fx.speeds._default), null != r2.queue && true !== r2.queue || (r2.queue = "fx"), r2.old = r2.complete, r2.complete = function() {
            m(r2.old) && r2.old.call(this), r2.queue && S.dequeue(this, r2.queue);
          }, r2;
        }, S.fn.extend({ fadeTo: function(e2, t2, n2, r2) {
          return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t2 }, e2, n2, r2);
        }, animate: function(t2, e2, n2, r2) {
          var i2 = S.isEmptyObject(t2), o2 = S.speed(e2, n2, r2), a2 = function() {
            var e3 = lt(this, S.extend({}, t2), o2);
            (i2 || Y.get(this, "finish")) && e3.stop(true);
          };
          return a2.finish = a2, i2 || false === o2.queue ? this.each(a2) : this.queue(o2.queue, a2);
        }, stop: function(i2, e2, o2) {
          var a2 = function(e3) {
            var t2 = e3.stop;
            delete e3.stop, t2(o2);
          };
          return "string" != typeof i2 && (o2 = e2, e2 = i2, i2 = void 0), e2 && this.queue(i2 || "fx", []), this.each(function() {
            var e3 = true, t2 = null != i2 && i2 + "queueHooks", n2 = S.timers, r2 = Y.get(this);
            if (t2)
              r2[t2] && r2[t2].stop && a2(r2[t2]);
            else
              for (t2 in r2)
                r2[t2] && r2[t2].stop && it.test(t2) && a2(r2[t2]);
            for (t2 = n2.length; t2--; )
              n2[t2].elem !== this || null != i2 && n2[t2].queue !== i2 || (n2[t2].anim.stop(o2), e3 = false, n2.splice(t2, 1));
            !e3 && o2 || S.dequeue(this, i2);
          });
        }, finish: function(a2) {
          return false !== a2 && (a2 = a2 || "fx"), this.each(function() {
            var e2, t2 = Y.get(this), n2 = t2[a2 + "queue"], r2 = t2[a2 + "queueHooks"], i2 = S.timers, o2 = n2 ? n2.length : 0;
            for (t2.finish = true, S.queue(this, a2, []), r2 && r2.stop && r2.stop.call(this, true), e2 = i2.length; e2--; )
              i2[e2].elem === this && i2[e2].queue === a2 && (i2[e2].anim.stop(true), i2.splice(e2, 1));
            for (e2 = 0; e2 < o2; e2++)
              n2[e2] && n2[e2].finish && n2[e2].finish.call(this);
            delete t2.finish;
          });
        } }), S.each(["toggle", "show", "hide"], function(e2, r2) {
          var i2 = S.fn[r2];
          S.fn[r2] = function(e3, t2, n2) {
            return null == e3 || "boolean" == typeof e3 ? i2.apply(this, arguments) : this.animate(st(r2, true), e3, t2, n2);
          };
        }), S.each({ slideDown: st("show"), slideUp: st("hide"), slideToggle: st("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(e2, r2) {
          S.fn[e2] = function(e3, t2, n2) {
            return this.animate(r2, e3, t2, n2);
          };
        }), S.timers = [], S.fx.tick = function() {
          var e2, t2 = 0, n2 = S.timers;
          for (Ze = Date.now(); t2 < n2.length; t2++)
            (e2 = n2[t2])() || n2[t2] !== e2 || n2.splice(t2--, 1);
          n2.length || S.fx.stop(), Ze = void 0;
        }, S.fx.timer = function(e2) {
          S.timers.push(e2), S.fx.start();
        }, S.fx.interval = 13, S.fx.start = function() {
          et || (et = true, ot());
        }, S.fx.stop = function() {
          et = null;
        }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function(r2, e2) {
          return r2 = S.fx && S.fx.speeds[r2] || r2, e2 = e2 || "fx", this.queue(e2, function(e3, t2) {
            var n2 = C.setTimeout(e3, r2);
            t2.stop = function() {
              C.clearTimeout(n2);
            };
          });
        }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
        var ct, ft = S.expr.attrHandle;
        S.fn.extend({ attr: function(e2, t2) {
          return $2(this, S.attr, e2, t2, 1 < arguments.length);
        }, removeAttr: function(e2) {
          return this.each(function() {
            S.removeAttr(this, e2);
          });
        } }), S.extend({ attr: function(e2, t2, n2) {
          var r2, i2, o2 = e2.nodeType;
          if (3 !== o2 && 8 !== o2 && 2 !== o2)
            return "undefined" == typeof e2.getAttribute ? S.prop(e2, t2, n2) : (1 === o2 && S.isXMLDoc(e2) || (i2 = S.attrHooks[t2.toLowerCase()] || (S.expr.match.bool.test(t2) ? ct : void 0)), void 0 !== n2 ? null === n2 ? void S.removeAttr(e2, t2) : i2 && "set" in i2 && void 0 !== (r2 = i2.set(e2, n2, t2)) ? r2 : (e2.setAttribute(t2, n2 + ""), n2) : i2 && "get" in i2 && null !== (r2 = i2.get(e2, t2)) ? r2 : null == (r2 = S.find.attr(e2, t2)) ? void 0 : r2);
        }, attrHooks: { type: { set: function(e2, t2) {
          if (!y.radioValue && "radio" === t2 && A(e2, "input")) {
            var n2 = e2.value;
            return e2.setAttribute("type", t2), n2 && (e2.value = n2), t2;
          }
        } } }, removeAttr: function(e2, t2) {
          var n2, r2 = 0, i2 = t2 && t2.match(P);
          if (i2 && 1 === e2.nodeType)
            while (n2 = i2[r2++])
              e2.removeAttribute(n2);
        } }), ct = { set: function(e2, t2, n2) {
          return false === t2 ? S.removeAttr(e2, n2) : e2.setAttribute(n2, n2), n2;
        } }, S.each(S.expr.match.bool.source.match(/\w+/g), function(e2, t2) {
          var a2 = ft[t2] || S.find.attr;
          ft[t2] = function(e3, t3, n2) {
            var r2, i2, o2 = t3.toLowerCase();
            return n2 || (i2 = ft[o2], ft[o2] = r2, r2 = null != a2(e3, t3, n2) ? o2 : null, ft[o2] = i2), r2;
          };
        });
        var pt = /^(?:input|select|textarea|button)$/i, dt = /^(?:a|area)$/i;
        function ht(e2) {
          return (e2.match(P) || []).join(" ");
        }
        function gt(e2) {
          return e2.getAttribute && e2.getAttribute("class") || "";
        }
        function vt(e2) {
          return Array.isArray(e2) ? e2 : "string" == typeof e2 && e2.match(P) || [];
        }
        S.fn.extend({ prop: function(e2, t2) {
          return $2(this, S.prop, e2, t2, 1 < arguments.length);
        }, removeProp: function(e2) {
          return this.each(function() {
            delete this[S.propFix[e2] || e2];
          });
        } }), S.extend({ prop: function(e2, t2, n2) {
          var r2, i2, o2 = e2.nodeType;
          if (3 !== o2 && 8 !== o2 && 2 !== o2)
            return 1 === o2 && S.isXMLDoc(e2) || (t2 = S.propFix[t2] || t2, i2 = S.propHooks[t2]), void 0 !== n2 ? i2 && "set" in i2 && void 0 !== (r2 = i2.set(e2, n2, t2)) ? r2 : e2[t2] = n2 : i2 && "get" in i2 && null !== (r2 = i2.get(e2, t2)) ? r2 : e2[t2];
        }, propHooks: { tabIndex: { get: function(e2) {
          var t2 = S.find.attr(e2, "tabindex");
          return t2 ? parseInt(t2, 10) : pt.test(e2.nodeName) || dt.test(e2.nodeName) && e2.href ? 0 : -1;
        } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = { get: function(e2) {
          var t2 = e2.parentNode;
          return t2 && t2.parentNode && t2.parentNode.selectedIndex, null;
        }, set: function(e2) {
          var t2 = e2.parentNode;
          t2 && (t2.selectedIndex, t2.parentNode && t2.parentNode.selectedIndex);
        } }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
          S.propFix[this.toLowerCase()] = this;
        }), S.fn.extend({ addClass: function(t2) {
          var e2, n2, r2, i2, o2, a2, s2, u2 = 0;
          if (m(t2))
            return this.each(function(e3) {
              S(this).addClass(t2.call(this, e3, gt(this)));
            });
          if ((e2 = vt(t2)).length) {
            while (n2 = this[u2++])
              if (i2 = gt(n2), r2 = 1 === n2.nodeType && " " + ht(i2) + " ") {
                a2 = 0;
                while (o2 = e2[a2++])
                  r2.indexOf(" " + o2 + " ") < 0 && (r2 += o2 + " ");
                i2 !== (s2 = ht(r2)) && n2.setAttribute("class", s2);
              }
          }
          return this;
        }, removeClass: function(t2) {
          var e2, n2, r2, i2, o2, a2, s2, u2 = 0;
          if (m(t2))
            return this.each(function(e3) {
              S(this).removeClass(t2.call(this, e3, gt(this)));
            });
          if (!arguments.length)
            return this.attr("class", "");
          if ((e2 = vt(t2)).length) {
            while (n2 = this[u2++])
              if (i2 = gt(n2), r2 = 1 === n2.nodeType && " " + ht(i2) + " ") {
                a2 = 0;
                while (o2 = e2[a2++])
                  while (-1 < r2.indexOf(" " + o2 + " "))
                    r2 = r2.replace(" " + o2 + " ", " ");
                i2 !== (s2 = ht(r2)) && n2.setAttribute("class", s2);
              }
          }
          return this;
        }, toggleClass: function(i2, t2) {
          var o2 = typeof i2, a2 = "string" === o2 || Array.isArray(i2);
          return "boolean" == typeof t2 && a2 ? t2 ? this.addClass(i2) : this.removeClass(i2) : m(i2) ? this.each(function(e2) {
            S(this).toggleClass(i2.call(this, e2, gt(this), t2), t2);
          }) : this.each(function() {
            var e2, t3, n2, r2;
            if (a2) {
              t3 = 0, n2 = S(this), r2 = vt(i2);
              while (e2 = r2[t3++])
                n2.hasClass(e2) ? n2.removeClass(e2) : n2.addClass(e2);
            } else
              void 0 !== i2 && "boolean" !== o2 || ((e2 = gt(this)) && Y.set(this, "__className__", e2), this.setAttribute && this.setAttribute("class", e2 || false === i2 ? "" : Y.get(this, "__className__") || ""));
          });
        }, hasClass: function(e2) {
          var t2, n2, r2 = 0;
          t2 = " " + e2 + " ";
          while (n2 = this[r2++])
            if (1 === n2.nodeType && -1 < (" " + ht(gt(n2)) + " ").indexOf(t2))
              return true;
          return false;
        } });
        var yt = /\r/g;
        S.fn.extend({ val: function(n2) {
          var r2, e2, i2, t2 = this[0];
          return arguments.length ? (i2 = m(n2), this.each(function(e3) {
            var t3;
            1 === this.nodeType && (null == (t3 = i2 ? n2.call(this, e3, S(this).val()) : n2) ? t3 = "" : "number" == typeof t3 ? t3 += "" : Array.isArray(t3) && (t3 = S.map(t3, function(e4) {
              return null == e4 ? "" : e4 + "";
            })), (r2 = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r2 && void 0 !== r2.set(this, t3, "value") || (this.value = t3));
          })) : t2 ? (r2 = S.valHooks[t2.type] || S.valHooks[t2.nodeName.toLowerCase()]) && "get" in r2 && void 0 !== (e2 = r2.get(t2, "value")) ? e2 : "string" == typeof (e2 = t2.value) ? e2.replace(yt, "") : null == e2 ? "" : e2 : void 0;
        } }), S.extend({ valHooks: { option: { get: function(e2) {
          var t2 = S.find.attr(e2, "value");
          return null != t2 ? t2 : ht(S.text(e2));
        } }, select: { get: function(e2) {
          var t2, n2, r2, i2 = e2.options, o2 = e2.selectedIndex, a2 = "select-one" === e2.type, s2 = a2 ? null : [], u2 = a2 ? o2 + 1 : i2.length;
          for (r2 = o2 < 0 ? u2 : a2 ? o2 : 0; r2 < u2; r2++)
            if (((n2 = i2[r2]).selected || r2 === o2) && !n2.disabled && (!n2.parentNode.disabled || !A(n2.parentNode, "optgroup"))) {
              if (t2 = S(n2).val(), a2)
                return t2;
              s2.push(t2);
            }
          return s2;
        }, set: function(e2, t2) {
          var n2, r2, i2 = e2.options, o2 = S.makeArray(t2), a2 = i2.length;
          while (a2--)
            ((r2 = i2[a2]).selected = -1 < S.inArray(S.valHooks.option.get(r2), o2)) && (n2 = true);
          return n2 || (e2.selectedIndex = -1), o2;
        } } } }), S.each(["radio", "checkbox"], function() {
          S.valHooks[this] = { set: function(e2, t2) {
            if (Array.isArray(t2))
              return e2.checked = -1 < S.inArray(S(e2).val(), t2);
          } }, y.checkOn || (S.valHooks[this].get = function(e2) {
            return null === e2.getAttribute("value") ? "on" : e2.value;
          });
        }), y.focusin = "onfocusin" in C;
        var mt = /^(?:focusinfocus|focusoutblur)$/, xt = function(e2) {
          e2.stopPropagation();
        };
        S.extend(S.event, { trigger: function(e2, t2, n2, r2) {
          var i2, o2, a2, s2, u2, l2, c2, f2, p2 = [n2 || E], d2 = v.call(e2, "type") ? e2.type : e2, h2 = v.call(e2, "namespace") ? e2.namespace.split(".") : [];
          if (o2 = f2 = a2 = n2 = n2 || E, 3 !== n2.nodeType && 8 !== n2.nodeType && !mt.test(d2 + S.event.triggered) && (-1 < d2.indexOf(".") && (d2 = (h2 = d2.split(".")).shift(), h2.sort()), u2 = d2.indexOf(":") < 0 && "on" + d2, (e2 = e2[S.expando] ? e2 : new S.Event(d2, "object" == typeof e2 && e2)).isTrigger = r2 ? 2 : 3, e2.namespace = h2.join("."), e2.rnamespace = e2.namespace ? new RegExp("(^|\\.)" + h2.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e2.result = void 0, e2.target || (e2.target = n2), t2 = null == t2 ? [e2] : S.makeArray(t2, [e2]), c2 = S.event.special[d2] || {}, r2 || !c2.trigger || false !== c2.trigger.apply(n2, t2))) {
            if (!r2 && !c2.noBubble && !x(n2)) {
              for (s2 = c2.delegateType || d2, mt.test(s2 + d2) || (o2 = o2.parentNode); o2; o2 = o2.parentNode)
                p2.push(o2), a2 = o2;
              a2 === (n2.ownerDocument || E) && p2.push(a2.defaultView || a2.parentWindow || C);
            }
            i2 = 0;
            while ((o2 = p2[i2++]) && !e2.isPropagationStopped())
              f2 = o2, e2.type = 1 < i2 ? s2 : c2.bindType || d2, (l2 = (Y.get(o2, "events") || /* @__PURE__ */ Object.create(null))[e2.type] && Y.get(o2, "handle")) && l2.apply(o2, t2), (l2 = u2 && o2[u2]) && l2.apply && V(o2) && (e2.result = l2.apply(o2, t2), false === e2.result && e2.preventDefault());
            return e2.type = d2, r2 || e2.isDefaultPrevented() || c2._default && false !== c2._default.apply(p2.pop(), t2) || !V(n2) || u2 && m(n2[d2]) && !x(n2) && ((a2 = n2[u2]) && (n2[u2] = null), S.event.triggered = d2, e2.isPropagationStopped() && f2.addEventListener(d2, xt), n2[d2](), e2.isPropagationStopped() && f2.removeEventListener(d2, xt), S.event.triggered = void 0, a2 && (n2[u2] = a2)), e2.result;
          }
        }, simulate: function(e2, t2, n2) {
          var r2 = S.extend(new S.Event(), n2, { type: e2, isSimulated: true });
          S.event.trigger(r2, null, t2);
        } }), S.fn.extend({ trigger: function(e2, t2) {
          return this.each(function() {
            S.event.trigger(e2, t2, this);
          });
        }, triggerHandler: function(e2, t2) {
          var n2 = this[0];
          if (n2)
            return S.event.trigger(e2, t2, n2, true);
        } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function(n2, r2) {
          var i2 = function(e2) {
            S.event.simulate(r2, e2.target, S.event.fix(e2));
          };
          S.event.special[r2] = { setup: function() {
            var e2 = this.ownerDocument || this.document || this, t2 = Y.access(e2, r2);
            t2 || e2.addEventListener(n2, i2, true), Y.access(e2, r2, (t2 || 0) + 1);
          }, teardown: function() {
            var e2 = this.ownerDocument || this.document || this, t2 = Y.access(e2, r2) - 1;
            t2 ? Y.access(e2, r2, t2) : (e2.removeEventListener(n2, i2, true), Y.remove(e2, r2));
          } };
        });
        var bt = C.location, wt = { guid: Date.now() }, Tt = /\?/;
        S.parseXML = function(e2) {
          var t2, n2;
          if (!e2 || "string" != typeof e2)
            return null;
          try {
            t2 = new C.DOMParser().parseFromString(e2, "text/xml");
          } catch (e3) {
          }
          return n2 = t2 && t2.getElementsByTagName("parsererror")[0], t2 && !n2 || S.error("Invalid XML: " + (n2 ? S.map(n2.childNodes, function(e3) {
            return e3.textContent;
          }).join("\n") : e2)), t2;
        };
        var Ct = /\[\]$/, Et = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, kt = /^(?:input|select|textarea|keygen)/i;
        function At(n2, e2, r2, i2) {
          var t2;
          if (Array.isArray(e2))
            S.each(e2, function(e3, t3) {
              r2 || Ct.test(n2) ? i2(n2, t3) : At(n2 + "[" + ("object" == typeof t3 && null != t3 ? e3 : "") + "]", t3, r2, i2);
            });
          else if (r2 || "object" !== w(e2))
            i2(n2, e2);
          else
            for (t2 in e2)
              At(n2 + "[" + t2 + "]", e2[t2], r2, i2);
        }
        S.param = function(e2, t2) {
          var n2, r2 = [], i2 = function(e3, t3) {
            var n3 = m(t3) ? t3() : t3;
            r2[r2.length] = encodeURIComponent(e3) + "=" + encodeURIComponent(null == n3 ? "" : n3);
          };
          if (null == e2)
            return "";
          if (Array.isArray(e2) || e2.jquery && !S.isPlainObject(e2))
            S.each(e2, function() {
              i2(this.name, this.value);
            });
          else
            for (n2 in e2)
              At(n2, e2[n2], t2, i2);
          return r2.join("&");
        }, S.fn.extend({ serialize: function() {
          return S.param(this.serializeArray());
        }, serializeArray: function() {
          return this.map(function() {
            var e2 = S.prop(this, "elements");
            return e2 ? S.makeArray(e2) : this;
          }).filter(function() {
            var e2 = this.type;
            return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e2) && (this.checked || !pe.test(e2));
          }).map(function(e2, t2) {
            var n2 = S(this).val();
            return null == n2 ? null : Array.isArray(n2) ? S.map(n2, function(e3) {
              return { name: t2.name, value: e3.replace(Et, "\r\n") };
            }) : { name: t2.name, value: n2.replace(Et, "\r\n") };
          }).get();
        } });
        var Nt = /%20/g, jt = /#.*$/, Dt = /([?&])_=[^&]*/, qt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Lt = /^(?:GET|HEAD)$/, Ht = /^\/\//, Ot = {}, Pt = {}, Rt = "*/".concat("*"), Mt = E.createElement("a");
        function It(o2) {
          return function(e2, t2) {
            "string" != typeof e2 && (t2 = e2, e2 = "*");
            var n2, r2 = 0, i2 = e2.toLowerCase().match(P) || [];
            if (m(t2))
              while (n2 = i2[r2++])
                "+" === n2[0] ? (n2 = n2.slice(1) || "*", (o2[n2] = o2[n2] || []).unshift(t2)) : (o2[n2] = o2[n2] || []).push(t2);
          };
        }
        function Wt(t2, i2, o2, a2) {
          var s2 = {}, u2 = t2 === Pt;
          function l2(e2) {
            var r2;
            return s2[e2] = true, S.each(t2[e2] || [], function(e3, t3) {
              var n2 = t3(i2, o2, a2);
              return "string" != typeof n2 || u2 || s2[n2] ? u2 ? !(r2 = n2) : void 0 : (i2.dataTypes.unshift(n2), l2(n2), false);
            }), r2;
          }
          return l2(i2.dataTypes[0]) || !s2["*"] && l2("*");
        }
        function Ft(e2, t2) {
          var n2, r2, i2 = S.ajaxSettings.flatOptions || {};
          for (n2 in t2)
            void 0 !== t2[n2] && ((i2[n2] ? e2 : r2 || (r2 = {}))[n2] = t2[n2]);
          return r2 && S.extend(true, e2, r2), e2;
        }
        Mt.href = bt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: true, processData: true, async: true, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": true, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: true, context: true } }, ajaxSetup: function(e2, t2) {
          return t2 ? Ft(Ft(e2, S.ajaxSettings), t2) : Ft(S.ajaxSettings, e2);
        }, ajaxPrefilter: It(Ot), ajaxTransport: It(Pt), ajax: function(e2, t2) {
          "object" == typeof e2 && (t2 = e2, e2 = void 0), t2 = t2 || {};
          var c2, f2, p2, n2, d2, r2, h2, g2, i2, o2, v2 = S.ajaxSetup({}, t2), y2 = v2.context || v2, m2 = v2.context && (y2.nodeType || y2.jquery) ? S(y2) : S.event, x2 = S.Deferred(), b2 = S.Callbacks("once memory"), w2 = v2.statusCode || {}, a2 = {}, s2 = {}, u2 = "canceled", T2 = { readyState: 0, getResponseHeader: function(e3) {
            var t3;
            if (h2) {
              if (!n2) {
                n2 = {};
                while (t3 = qt.exec(p2))
                  n2[t3[1].toLowerCase() + " "] = (n2[t3[1].toLowerCase() + " "] || []).concat(t3[2]);
              }
              t3 = n2[e3.toLowerCase() + " "];
            }
            return null == t3 ? null : t3.join(", ");
          }, getAllResponseHeaders: function() {
            return h2 ? p2 : null;
          }, setRequestHeader: function(e3, t3) {
            return null == h2 && (e3 = s2[e3.toLowerCase()] = s2[e3.toLowerCase()] || e3, a2[e3] = t3), this;
          }, overrideMimeType: function(e3) {
            return null == h2 && (v2.mimeType = e3), this;
          }, statusCode: function(e3) {
            var t3;
            if (e3)
              if (h2)
                T2.always(e3[T2.status]);
              else
                for (t3 in e3)
                  w2[t3] = [w2[t3], e3[t3]];
            return this;
          }, abort: function(e3) {
            var t3 = e3 || u2;
            return c2 && c2.abort(t3), l2(0, t3), this;
          } };
          if (x2.promise(T2), v2.url = ((e2 || v2.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v2.type = t2.method || t2.type || v2.method || v2.type, v2.dataTypes = (v2.dataType || "*").toLowerCase().match(P) || [""], null == v2.crossDomain) {
            r2 = E.createElement("a");
            try {
              r2.href = v2.url, r2.href = r2.href, v2.crossDomain = Mt.protocol + "//" + Mt.host != r2.protocol + "//" + r2.host;
            } catch (e3) {
              v2.crossDomain = true;
            }
          }
          if (v2.data && v2.processData && "string" != typeof v2.data && (v2.data = S.param(v2.data, v2.traditional)), Wt(Ot, v2, t2, T2), h2)
            return T2;
          for (i2 in (g2 = S.event && v2.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v2.type = v2.type.toUpperCase(), v2.hasContent = !Lt.test(v2.type), f2 = v2.url.replace(jt, ""), v2.hasContent ? v2.data && v2.processData && 0 === (v2.contentType || "").indexOf("application/x-www-form-urlencoded") && (v2.data = v2.data.replace(Nt, "+")) : (o2 = v2.url.slice(f2.length), v2.data && (v2.processData || "string" == typeof v2.data) && (f2 += (Tt.test(f2) ? "&" : "?") + v2.data, delete v2.data), false === v2.cache && (f2 = f2.replace(Dt, "$1"), o2 = (Tt.test(f2) ? "&" : "?") + "_=" + wt.guid++ + o2), v2.url = f2 + o2), v2.ifModified && (S.lastModified[f2] && T2.setRequestHeader("If-Modified-Since", S.lastModified[f2]), S.etag[f2] && T2.setRequestHeader("If-None-Match", S.etag[f2])), (v2.data && v2.hasContent && false !== v2.contentType || t2.contentType) && T2.setRequestHeader("Content-Type", v2.contentType), T2.setRequestHeader("Accept", v2.dataTypes[0] && v2.accepts[v2.dataTypes[0]] ? v2.accepts[v2.dataTypes[0]] + ("*" !== v2.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v2.accepts["*"]), v2.headers)
            T2.setRequestHeader(i2, v2.headers[i2]);
          if (v2.beforeSend && (false === v2.beforeSend.call(y2, T2, v2) || h2))
            return T2.abort();
          if (u2 = "abort", b2.add(v2.complete), T2.done(v2.success), T2.fail(v2.error), c2 = Wt(Pt, v2, t2, T2)) {
            if (T2.readyState = 1, g2 && m2.trigger("ajaxSend", [T2, v2]), h2)
              return T2;
            v2.async && 0 < v2.timeout && (d2 = C.setTimeout(function() {
              T2.abort("timeout");
            }, v2.timeout));
            try {
              h2 = false, c2.send(a2, l2);
            } catch (e3) {
              if (h2)
                throw e3;
              l2(-1, e3);
            }
          } else
            l2(-1, "No Transport");
          function l2(e3, t3, n3, r3) {
            var i3, o3, a3, s3, u3, l3 = t3;
            h2 || (h2 = true, d2 && C.clearTimeout(d2), c2 = void 0, p2 = r3 || "", T2.readyState = 0 < e3 ? 4 : 0, i3 = 200 <= e3 && e3 < 300 || 304 === e3, n3 && (s3 = function(e4, t4, n4) {
              var r4, i4, o4, a4, s4 = e4.contents, u4 = e4.dataTypes;
              while ("*" === u4[0])
                u4.shift(), void 0 === r4 && (r4 = e4.mimeType || t4.getResponseHeader("Content-Type"));
              if (r4) {
                for (i4 in s4)
                  if (s4[i4] && s4[i4].test(r4)) {
                    u4.unshift(i4);
                    break;
                  }
              }
              if (u4[0] in n4)
                o4 = u4[0];
              else {
                for (i4 in n4) {
                  if (!u4[0] || e4.converters[i4 + " " + u4[0]]) {
                    o4 = i4;
                    break;
                  }
                  a4 || (a4 = i4);
                }
                o4 = o4 || a4;
              }
              if (o4)
                return o4 !== u4[0] && u4.unshift(o4), n4[o4];
            }(v2, T2, n3)), !i3 && -1 < S.inArray("script", v2.dataTypes) && S.inArray("json", v2.dataTypes) < 0 && (v2.converters["text script"] = function() {
            }), s3 = function(e4, t4, n4, r4) {
              var i4, o4, a4, s4, u4, l4 = {}, c3 = e4.dataTypes.slice();
              if (c3[1])
                for (a4 in e4.converters)
                  l4[a4.toLowerCase()] = e4.converters[a4];
              o4 = c3.shift();
              while (o4)
                if (e4.responseFields[o4] && (n4[e4.responseFields[o4]] = t4), !u4 && r4 && e4.dataFilter && (t4 = e4.dataFilter(t4, e4.dataType)), u4 = o4, o4 = c3.shift()) {
                  if ("*" === o4)
                    o4 = u4;
                  else if ("*" !== u4 && u4 !== o4) {
                    if (!(a4 = l4[u4 + " " + o4] || l4["* " + o4])) {
                      for (i4 in l4)
                        if ((s4 = i4.split(" "))[1] === o4 && (a4 = l4[u4 + " " + s4[0]] || l4["* " + s4[0]])) {
                          true === a4 ? a4 = l4[i4] : true !== l4[i4] && (o4 = s4[0], c3.unshift(s4[1]));
                          break;
                        }
                    }
                    if (true !== a4)
                      if (a4 && e4["throws"])
                        t4 = a4(t4);
                      else
                        try {
                          t4 = a4(t4);
                        } catch (e5) {
                          return { state: "parsererror", error: a4 ? e5 : "No conversion from " + u4 + " to " + o4 };
                        }
                  }
                }
              return { state: "success", data: t4 };
            }(v2, s3, T2, i3), i3 ? (v2.ifModified && ((u3 = T2.getResponseHeader("Last-Modified")) && (S.lastModified[f2] = u3), (u3 = T2.getResponseHeader("etag")) && (S.etag[f2] = u3)), 204 === e3 || "HEAD" === v2.type ? l3 = "nocontent" : 304 === e3 ? l3 = "notmodified" : (l3 = s3.state, o3 = s3.data, i3 = !(a3 = s3.error))) : (a3 = l3, !e3 && l3 || (l3 = "error", e3 < 0 && (e3 = 0))), T2.status = e3, T2.statusText = (t3 || l3) + "", i3 ? x2.resolveWith(y2, [o3, l3, T2]) : x2.rejectWith(y2, [T2, l3, a3]), T2.statusCode(w2), w2 = void 0, g2 && m2.trigger(i3 ? "ajaxSuccess" : "ajaxError", [T2, v2, i3 ? o3 : a3]), b2.fireWith(y2, [T2, l3]), g2 && (m2.trigger("ajaxComplete", [T2, v2]), --S.active || S.event.trigger("ajaxStop")));
          }
          return T2;
        }, getJSON: function(e2, t2, n2) {
          return S.get(e2, t2, n2, "json");
        }, getScript: function(e2, t2) {
          return S.get(e2, void 0, t2, "script");
        } }), S.each(["get", "post"], function(e2, i2) {
          S[i2] = function(e3, t2, n2, r2) {
            return m(t2) && (r2 = r2 || n2, n2 = t2, t2 = void 0), S.ajax(S.extend({ url: e3, type: i2, dataType: r2, data: t2, success: n2 }, S.isPlainObject(e3) && e3));
          };
        }), S.ajaxPrefilter(function(e2) {
          var t2;
          for (t2 in e2.headers)
            "content-type" === t2.toLowerCase() && (e2.contentType = e2.headers[t2] || "");
        }), S._evalUrl = function(e2, t2, n2) {
          return S.ajax({ url: e2, type: "GET", dataType: "script", cache: true, async: false, global: false, converters: { "text script": function() {
          } }, dataFilter: function(e3) {
            S.globalEval(e3, t2, n2);
          } });
        }, S.fn.extend({ wrapAll: function(e2) {
          var t2;
          return this[0] && (m(e2) && (e2 = e2.call(this[0])), t2 = S(e2, this[0].ownerDocument).eq(0).clone(true), this[0].parentNode && t2.insertBefore(this[0]), t2.map(function() {
            var e3 = this;
            while (e3.firstElementChild)
              e3 = e3.firstElementChild;
            return e3;
          }).append(this)), this;
        }, wrapInner: function(n2) {
          return m(n2) ? this.each(function(e2) {
            S(this).wrapInner(n2.call(this, e2));
          }) : this.each(function() {
            var e2 = S(this), t2 = e2.contents();
            t2.length ? t2.wrapAll(n2) : e2.append(n2);
          });
        }, wrap: function(t2) {
          var n2 = m(t2);
          return this.each(function(e2) {
            S(this).wrapAll(n2 ? t2.call(this, e2) : t2);
          });
        }, unwrap: function(e2) {
          return this.parent(e2).not("body").each(function() {
            S(this).replaceWith(this.childNodes);
          }), this;
        } }), S.expr.pseudos.hidden = function(e2) {
          return !S.expr.pseudos.visible(e2);
        }, S.expr.pseudos.visible = function(e2) {
          return !!(e2.offsetWidth || e2.offsetHeight || e2.getClientRects().length);
        }, S.ajaxSettings.xhr = function() {
          try {
            return new C.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var Bt = { 0: 200, 1223: 204 }, $t = S.ajaxSettings.xhr();
        y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function(i2) {
          var o2, a2;
          if (y.cors || $t && !i2.crossDomain)
            return { send: function(e2, t2) {
              var n2, r2 = i2.xhr();
              if (r2.open(i2.type, i2.url, i2.async, i2.username, i2.password), i2.xhrFields)
                for (n2 in i2.xhrFields)
                  r2[n2] = i2.xhrFields[n2];
              for (n2 in i2.mimeType && r2.overrideMimeType && r2.overrideMimeType(i2.mimeType), i2.crossDomain || e2["X-Requested-With"] || (e2["X-Requested-With"] = "XMLHttpRequest"), e2)
                r2.setRequestHeader(n2, e2[n2]);
              o2 = function(e3) {
                return function() {
                  o2 && (o2 = a2 = r2.onload = r2.onerror = r2.onabort = r2.ontimeout = r2.onreadystatechange = null, "abort" === e3 ? r2.abort() : "error" === e3 ? "number" != typeof r2.status ? t2(0, "error") : t2(r2.status, r2.statusText) : t2(Bt[r2.status] || r2.status, r2.statusText, "text" !== (r2.responseType || "text") || "string" != typeof r2.responseText ? { binary: r2.response } : { text: r2.responseText }, r2.getAllResponseHeaders()));
                };
              }, r2.onload = o2(), a2 = r2.onerror = r2.ontimeout = o2("error"), void 0 !== r2.onabort ? r2.onabort = a2 : r2.onreadystatechange = function() {
                4 === r2.readyState && C.setTimeout(function() {
                  o2 && a2();
                });
              }, o2 = o2("abort");
              try {
                r2.send(i2.hasContent && i2.data || null);
              } catch (e3) {
                if (o2)
                  throw e3;
              }
            }, abort: function() {
              o2 && o2();
            } };
        }), S.ajaxPrefilter(function(e2) {
          e2.crossDomain && (e2.contents.script = false);
        }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(e2) {
          return S.globalEval(e2), e2;
        } } }), S.ajaxPrefilter("script", function(e2) {
          void 0 === e2.cache && (e2.cache = false), e2.crossDomain && (e2.type = "GET");
        }), S.ajaxTransport("script", function(n2) {
          var r2, i2;
          if (n2.crossDomain || n2.scriptAttrs)
            return { send: function(e2, t2) {
              r2 = S("<script>").attr(n2.scriptAttrs || {}).prop({ charset: n2.scriptCharset, src: n2.url }).on("load error", i2 = function(e3) {
                r2.remove(), i2 = null, e3 && t2("error" === e3.type ? 404 : 200, e3.type);
              }), E.head.appendChild(r2[0]);
            }, abort: function() {
              i2 && i2();
            } };
        });
        var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/;
        S.ajaxSetup({ jsonp: "callback", jsonpCallback: function() {
          var e2 = zt.pop() || S.expando + "_" + wt.guid++;
          return this[e2] = true, e2;
        } }), S.ajaxPrefilter("json jsonp", function(e2, t2, n2) {
          var r2, i2, o2, a2 = false !== e2.jsonp && (Ut.test(e2.url) ? "url" : "string" == typeof e2.data && 0 === (e2.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e2.data) && "data");
          if (a2 || "jsonp" === e2.dataTypes[0])
            return r2 = e2.jsonpCallback = m(e2.jsonpCallback) ? e2.jsonpCallback() : e2.jsonpCallback, a2 ? e2[a2] = e2[a2].replace(Ut, "$1" + r2) : false !== e2.jsonp && (e2.url += (Tt.test(e2.url) ? "&" : "?") + e2.jsonp + "=" + r2), e2.converters["script json"] = function() {
              return o2 || S.error(r2 + " was not called"), o2[0];
            }, e2.dataTypes[0] = "json", i2 = C[r2], C[r2] = function() {
              o2 = arguments;
            }, n2.always(function() {
              void 0 === i2 ? S(C).removeProp(r2) : C[r2] = i2, e2[r2] && (e2.jsonpCallback = t2.jsonpCallback, zt.push(r2)), o2 && m(i2) && i2(o2[0]), o2 = i2 = void 0;
            }), "script";
        }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function(e2, t2, n2) {
          return "string" != typeof e2 ? [] : ("boolean" == typeof t2 && (n2 = t2, t2 = false), t2 || (y.createHTMLDocument ? ((r2 = (t2 = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t2.head.appendChild(r2)) : t2 = E), o2 = !n2 && [], (i2 = N.exec(e2)) ? [t2.createElement(i2[1])] : (i2 = xe([e2], t2, o2), o2 && o2.length && S(o2).remove(), S.merge([], i2.childNodes)));
          var r2, i2, o2;
        }, S.fn.load = function(e2, t2, n2) {
          var r2, i2, o2, a2 = this, s2 = e2.indexOf(" ");
          return -1 < s2 && (r2 = ht(e2.slice(s2)), e2 = e2.slice(0, s2)), m(t2) ? (n2 = t2, t2 = void 0) : t2 && "object" == typeof t2 && (i2 = "POST"), 0 < a2.length && S.ajax({ url: e2, type: i2 || "GET", dataType: "html", data: t2 }).done(function(e3) {
            o2 = arguments, a2.html(r2 ? S("<div>").append(S.parseHTML(e3)).find(r2) : e3);
          }).always(n2 && function(e3, t3) {
            a2.each(function() {
              n2.apply(this, o2 || [e3.responseText, t3, e3]);
            });
          }), this;
        }, S.expr.pseudos.animated = function(t2) {
          return S.grep(S.timers, function(e2) {
            return t2 === e2.elem;
          }).length;
        }, S.offset = { setOffset: function(e2, t2, n2) {
          var r2, i2, o2, a2, s2, u2, l2 = S.css(e2, "position"), c2 = S(e2), f2 = {};
          "static" === l2 && (e2.style.position = "relative"), s2 = c2.offset(), o2 = S.css(e2, "top"), u2 = S.css(e2, "left"), ("absolute" === l2 || "fixed" === l2) && -1 < (o2 + u2).indexOf("auto") ? (a2 = (r2 = c2.position()).top, i2 = r2.left) : (a2 = parseFloat(o2) || 0, i2 = parseFloat(u2) || 0), m(t2) && (t2 = t2.call(e2, n2, S.extend({}, s2))), null != t2.top && (f2.top = t2.top - s2.top + a2), null != t2.left && (f2.left = t2.left - s2.left + i2), "using" in t2 ? t2.using.call(e2, f2) : c2.css(f2);
        } }, S.fn.extend({ offset: function(t2) {
          if (arguments.length)
            return void 0 === t2 ? this : this.each(function(e3) {
              S.offset.setOffset(this, t2, e3);
            });
          var e2, n2, r2 = this[0];
          return r2 ? r2.getClientRects().length ? (e2 = r2.getBoundingClientRect(), n2 = r2.ownerDocument.defaultView, { top: e2.top + n2.pageYOffset, left: e2.left + n2.pageXOffset }) : { top: 0, left: 0 } : void 0;
        }, position: function() {
          if (this[0]) {
            var e2, t2, n2, r2 = this[0], i2 = { top: 0, left: 0 };
            if ("fixed" === S.css(r2, "position"))
              t2 = r2.getBoundingClientRect();
            else {
              t2 = this.offset(), n2 = r2.ownerDocument, e2 = r2.offsetParent || n2.documentElement;
              while (e2 && (e2 === n2.body || e2 === n2.documentElement) && "static" === S.css(e2, "position"))
                e2 = e2.parentNode;
              e2 && e2 !== r2 && 1 === e2.nodeType && ((i2 = S(e2).offset()).top += S.css(e2, "borderTopWidth", true), i2.left += S.css(e2, "borderLeftWidth", true));
            }
            return { top: t2.top - i2.top - S.css(r2, "marginTop", true), left: t2.left - i2.left - S.css(r2, "marginLeft", true) };
          }
        }, offsetParent: function() {
          return this.map(function() {
            var e2 = this.offsetParent;
            while (e2 && "static" === S.css(e2, "position"))
              e2 = e2.offsetParent;
            return e2 || re;
          });
        } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(t2, i2) {
          var o2 = "pageYOffset" === i2;
          S.fn[t2] = function(e2) {
            return $2(this, function(e3, t3, n2) {
              var r2;
              if (x(e3) ? r2 = e3 : 9 === e3.nodeType && (r2 = e3.defaultView), void 0 === n2)
                return r2 ? r2[i2] : e3[t3];
              r2 ? r2.scrollTo(o2 ? r2.pageXOffset : n2, o2 ? n2 : r2.pageYOffset) : e3[t3] = n2;
            }, t2, e2, arguments.length);
          };
        }), S.each(["top", "left"], function(e2, n2) {
          S.cssHooks[n2] = Fe(y.pixelPosition, function(e3, t2) {
            if (t2)
              return t2 = We(e3, n2), Pe.test(t2) ? S(e3).position()[n2] + "px" : t2;
          });
        }), S.each({ Height: "height", Width: "width" }, function(a2, s2) {
          S.each({ padding: "inner" + a2, content: s2, "": "outer" + a2 }, function(r2, o2) {
            S.fn[o2] = function(e2, t2) {
              var n2 = arguments.length && (r2 || "boolean" != typeof e2), i2 = r2 || (true === e2 || true === t2 ? "margin" : "border");
              return $2(this, function(e3, t3, n3) {
                var r3;
                return x(e3) ? 0 === o2.indexOf("outer") ? e3["inner" + a2] : e3.document.documentElement["client" + a2] : 9 === e3.nodeType ? (r3 = e3.documentElement, Math.max(e3.body["scroll" + a2], r3["scroll" + a2], e3.body["offset" + a2], r3["offset" + a2], r3["client" + a2])) : void 0 === n3 ? S.css(e3, t3, i2) : S.style(e3, t3, n3, i2);
              }, s2, n2 ? e2 : void 0, n2);
            };
          });
        }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e2, t2) {
          S.fn[t2] = function(e3) {
            return this.on(t2, e3);
          };
        }), S.fn.extend({ bind: function(e2, t2, n2) {
          return this.on(e2, null, t2, n2);
        }, unbind: function(e2, t2) {
          return this.off(e2, null, t2);
        }, delegate: function(e2, t2, n2, r2) {
          return this.on(t2, e2, n2, r2);
        }, undelegate: function(e2, t2, n2) {
          return 1 === arguments.length ? this.off(e2, "**") : this.off(t2, e2 || "**", n2);
        }, hover: function(e2, t2) {
          return this.mouseenter(e2).mouseleave(t2 || e2);
        } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e2, n2) {
          S.fn[n2] = function(e3, t2) {
            return 0 < arguments.length ? this.on(n2, null, e3, t2) : this.trigger(n2);
          };
        });
        var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        S.proxy = function(e2, t2) {
          var n2, r2, i2;
          if ("string" == typeof t2 && (n2 = e2[t2], t2 = e2, e2 = n2), m(e2))
            return r2 = s.call(arguments, 2), (i2 = function() {
              return e2.apply(t2 || this, r2.concat(s.call(arguments)));
            }).guid = e2.guid = e2.guid || S.guid++, i2;
        }, S.holdReady = function(e2) {
          e2 ? S.readyWait++ : S.ready(true);
        }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function(e2) {
          var t2 = S.type(e2);
          return ("number" === t2 || "string" === t2) && !isNaN(e2 - parseFloat(e2));
        }, S.trim = function(e2) {
          return null == e2 ? "" : (e2 + "").replace(Xt, "");
        }, "function" == typeof define && define.amd && define("jquery", [], function() {
          return S;
        });
        var Vt = C.jQuery, Gt = C.$;
        return S.noConflict = function(e2) {
          return C.$ === S && (C.$ = Gt), e2 && C.jQuery === S && (C.jQuery = Vt), S;
        }, "undefined" == typeof e && (C.jQuery = C.$ = S), S;
      });
    }
  });

  // node_modules/@postlight/parser/src/shims/cheerio-query.js
  var cheerio_query_exports = {};
  __export(cheerio_query_exports, {
    default: () => cheerio_query_default
  });
  var import_jquery, PARSER_CLASS, PARSING_NODE, $, removeUnusedTags, isContainer, cheerio_query_default;
  var init_cheerio_query = __esm({
    "node_modules/@postlight/parser/src/shims/cheerio-query.js"() {
      import_jquery = __toESM(require_jquery_min());
      PARSER_CLASS = "mercury-parsing-container";
      import_jquery.default.noConflict();
      $ = (selector, context, rootjQuery, contextOverride = true) => {
        if (contextOverride) {
          if (context && typeof context === "string") {
            context = PARSING_NODE.find(context);
          } else if (!context) {
            context = PARSING_NODE;
          }
        }
        return new import_jquery.default.fn.init(selector, context, rootjQuery);
      };
      $.fn = $.prototype = import_jquery.default.fn;
      import_jquery.default.extend($, import_jquery.default);
      removeUnusedTags = ($node) => {
        $node.find('script, style, link[rel="stylesheet"]').remove();
        return $node;
      };
      $.cloneHtml = () => {
        const html = removeUnusedTags($("html", null, null, false).clone());
        return html.children().wrap("<div />").wrap("<div />");
      };
      $.root = () => $("*").first();
      $.browser = true;
      isContainer = ($node) => {
        const el = $node.get(0);
        if (el && el.tagName) {
          return el.tagName.toLowerCase() === "container";
        }
        return false;
      };
      $.html = ($node) => {
        if ($node) {
          if (isContainer($node) || isContainer($node.children("container"))) {
            return $node.children("container").html() || $node.html();
          }
          return $("<div>").append($node.eq(0).clone()).html();
        }
        const $body = removeUnusedTags($("body", null, null, false).clone());
        const $head = removeUnusedTags($("head", null, null, false).clone());
        if (PARSING_NODE && PARSING_NODE.length > 0) {
          return PARSING_NODE.children().html();
        }
        const html = $("<container />").append($(`<container>${$head.html()}</container>`)).append($(`<container>${$body.html()}</container>`)).wrap("<container />").parent().html();
        return html;
      };
      $.load = (html, opts = {}, returnHtml = false) => {
        if (!html) {
          html = $.cloneHtml();
        } else {
          html = $("<container />").html(html);
        }
        PARSING_NODE = PARSING_NODE || $(`<div class="${PARSER_CLASS}" style="display:none;" />`);
        html = removeUnusedTags(html);
        html.find("*").contents().each(function() {
          if (this.nodeType === Node.COMMENT_NODE) {
            $(this).remove();
          }
        });
        PARSING_NODE.html(html);
        if (returnHtml)
          return { $, html: html.html() };
        return $;
      };
      cheerio_query_default = $;
    }
  });

  // node_modules/turndown/lib/turndown.browser.cjs.js
  var require_turndown_browser_cjs = __commonJS({
    "node_modules/turndown/lib/turndown.browser.cjs.js"(exports, module) {
      "use strict";
      function extend(destination) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key))
              destination[key] = source[key];
          }
        }
        return destination;
      }
      function repeat(character, count) {
        return Array(count + 1).join(character);
      }
      function trimLeadingNewlines(string) {
        return string.replace(/^\n*/, "");
      }
      function trimTrailingNewlines(string) {
        var indexEnd = string.length;
        while (indexEnd > 0 && string[indexEnd - 1] === "\n")
          indexEnd--;
        return string.substring(0, indexEnd);
      }
      var blockElements = [
        "ADDRESS",
        "ARTICLE",
        "ASIDE",
        "AUDIO",
        "BLOCKQUOTE",
        "BODY",
        "CANVAS",
        "CENTER",
        "DD",
        "DIR",
        "DIV",
        "DL",
        "DT",
        "FIELDSET",
        "FIGCAPTION",
        "FIGURE",
        "FOOTER",
        "FORM",
        "FRAMESET",
        "H1",
        "H2",
        "H3",
        "H4",
        "H5",
        "H6",
        "HEADER",
        "HGROUP",
        "HR",
        "HTML",
        "ISINDEX",
        "LI",
        "MAIN",
        "MENU",
        "NAV",
        "NOFRAMES",
        "NOSCRIPT",
        "OL",
        "OUTPUT",
        "P",
        "PRE",
        "SECTION",
        "TABLE",
        "TBODY",
        "TD",
        "TFOOT",
        "TH",
        "THEAD",
        "TR",
        "UL"
      ];
      function isBlock(node) {
        return is(node, blockElements);
      }
      var voidElements = [
        "AREA",
        "BASE",
        "BR",
        "COL",
        "COMMAND",
        "EMBED",
        "HR",
        "IMG",
        "INPUT",
        "KEYGEN",
        "LINK",
        "META",
        "PARAM",
        "SOURCE",
        "TRACK",
        "WBR"
      ];
      function isVoid(node) {
        return is(node, voidElements);
      }
      function hasVoid(node) {
        return has(node, voidElements);
      }
      var meaningfulWhenBlankElements = [
        "A",
        "TABLE",
        "THEAD",
        "TBODY",
        "TFOOT",
        "TH",
        "TD",
        "IFRAME",
        "SCRIPT",
        "AUDIO",
        "VIDEO"
      ];
      function isMeaningfulWhenBlank(node) {
        return is(node, meaningfulWhenBlankElements);
      }
      function hasMeaningfulWhenBlank(node) {
        return has(node, meaningfulWhenBlankElements);
      }
      function is(node, tagNames) {
        return tagNames.indexOf(node.nodeName) >= 0;
      }
      function has(node, tagNames) {
        return node.getElementsByTagName && tagNames.some(function(tagName) {
          return node.getElementsByTagName(tagName).length;
        });
      }
      var rules = {};
      rules.paragraph = {
        filter: "p",
        replacement: function(content) {
          return "\n\n" + content + "\n\n";
        }
      };
      rules.lineBreak = {
        filter: "br",
        replacement: function(content, node, options) {
          return options.br + "\n";
        }
      };
      rules.heading = {
        filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
        replacement: function(content, node, options) {
          var hLevel = Number(node.nodeName.charAt(1));
          if (options.headingStyle === "setext" && hLevel < 3) {
            var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
            return "\n\n" + content + "\n" + underline + "\n\n";
          } else {
            return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
          }
        }
      };
      rules.blockquote = {
        filter: "blockquote",
        replacement: function(content) {
          content = content.replace(/^\n+|\n+$/g, "");
          content = content.replace(/^/gm, "> ");
          return "\n\n" + content + "\n\n";
        }
      };
      rules.list = {
        filter: ["ul", "ol"],
        replacement: function(content, node) {
          var parent = node.parentNode;
          if (parent.nodeName === "LI" && parent.lastElementChild === node) {
            return "\n" + content;
          } else {
            return "\n\n" + content + "\n\n";
          }
        }
      };
      rules.listItem = {
        filter: "li",
        replacement: function(content, node, options) {
          content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
          var prefix = options.bulletListMarker + "   ";
          var parent = node.parentNode;
          if (parent.nodeName === "OL") {
            var start = parent.getAttribute("start");
            var index = Array.prototype.indexOf.call(parent.children, node);
            prefix = (start ? Number(start) + index : index + 1) + ".  ";
          }
          return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
        }
      };
      rules.indentedCodeBlock = {
        filter: function(node, options) {
          return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
        },
        replacement: function(content, node, options) {
          return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
        }
      };
      rules.fencedCodeBlock = {
        filter: function(node, options) {
          return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
        },
        replacement: function(content, node, options) {
          var className = node.firstChild.getAttribute("class") || "";
          var language = (className.match(/language-(\S+)/) || [null, ""])[1];
          var code = node.firstChild.textContent;
          var fenceChar = options.fence.charAt(0);
          var fenceSize = 3;
          var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
          var match;
          while (match = fenceInCodeRegex.exec(code)) {
            if (match[0].length >= fenceSize) {
              fenceSize = match[0].length + 1;
            }
          }
          var fence = repeat(fenceChar, fenceSize);
          return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
        }
      };
      rules.horizontalRule = {
        filter: "hr",
        replacement: function(content, node, options) {
          return "\n\n" + options.hr + "\n\n";
        }
      };
      rules.inlineLink = {
        filter: function(node, options) {
          return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
        },
        replacement: function(content, node) {
          var href = node.getAttribute("href");
          var title = cleanAttribute(node.getAttribute("title"));
          if (title)
            title = ' "' + title + '"';
          return "[" + content + "](" + href + title + ")";
        }
      };
      rules.referenceLink = {
        filter: function(node, options) {
          return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
        },
        replacement: function(content, node, options) {
          var href = node.getAttribute("href");
          var title = cleanAttribute(node.getAttribute("title"));
          if (title)
            title = ' "' + title + '"';
          var replacement;
          var reference;
          switch (options.linkReferenceStyle) {
            case "collapsed":
              replacement = "[" + content + "][]";
              reference = "[" + content + "]: " + href + title;
              break;
            case "shortcut":
              replacement = "[" + content + "]";
              reference = "[" + content + "]: " + href + title;
              break;
            default:
              var id = this.references.length + 1;
              replacement = "[" + content + "][" + id + "]";
              reference = "[" + id + "]: " + href + title;
          }
          this.references.push(reference);
          return replacement;
        },
        references: [],
        append: function(options) {
          var references = "";
          if (this.references.length) {
            references = "\n\n" + this.references.join("\n") + "\n\n";
            this.references = [];
          }
          return references;
        }
      };
      rules.emphasis = {
        filter: ["em", "i"],
        replacement: function(content, node, options) {
          if (!content.trim())
            return "";
          return options.emDelimiter + content + options.emDelimiter;
        }
      };
      rules.strong = {
        filter: ["strong", "b"],
        replacement: function(content, node, options) {
          if (!content.trim())
            return "";
          return options.strongDelimiter + content + options.strongDelimiter;
        }
      };
      rules.code = {
        filter: function(node) {
          var hasSiblings = node.previousSibling || node.nextSibling;
          var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
          return node.nodeName === "CODE" && !isCodeBlock;
        },
        replacement: function(content) {
          if (!content)
            return "";
          content = content.replace(/\r?\n|\r/g, " ");
          var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
          var delimiter = "`";
          var matches = content.match(/`+/gm) || [];
          while (matches.indexOf(delimiter) !== -1)
            delimiter = delimiter + "`";
          return delimiter + extraSpace + content + extraSpace + delimiter;
        }
      };
      rules.image = {
        filter: "img",
        replacement: function(content, node) {
          var alt = cleanAttribute(node.getAttribute("alt"));
          var src = node.getAttribute("src") || "";
          var title = cleanAttribute(node.getAttribute("title"));
          var titlePart = title ? ' "' + title + '"' : "";
          return src ? "![" + alt + "](" + src + titlePart + ")" : "";
        }
      };
      function cleanAttribute(attribute) {
        return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
      }
      function Rules(options) {
        this.options = options;
        this._keep = [];
        this._remove = [];
        this.blankRule = {
          replacement: options.blankReplacement
        };
        this.keepReplacement = options.keepReplacement;
        this.defaultRule = {
          replacement: options.defaultReplacement
        };
        this.array = [];
        for (var key in options.rules)
          this.array.push(options.rules[key]);
      }
      Rules.prototype = {
        add: function(key, rule) {
          this.array.unshift(rule);
        },
        keep: function(filter) {
          this._keep.unshift({
            filter,
            replacement: this.keepReplacement
          });
        },
        remove: function(filter) {
          this._remove.unshift({
            filter,
            replacement: function() {
              return "";
            }
          });
        },
        forNode: function(node) {
          if (node.isBlank)
            return this.blankRule;
          var rule;
          if (rule = findRule(this.array, node, this.options))
            return rule;
          if (rule = findRule(this._keep, node, this.options))
            return rule;
          if (rule = findRule(this._remove, node, this.options))
            return rule;
          return this.defaultRule;
        },
        forEach: function(fn) {
          for (var i = 0; i < this.array.length; i++)
            fn(this.array[i], i);
        }
      };
      function findRule(rules2, node, options) {
        for (var i = 0; i < rules2.length; i++) {
          var rule = rules2[i];
          if (filterValue(rule, node, options))
            return rule;
        }
        return void 0;
      }
      function filterValue(rule, node, options) {
        var filter = rule.filter;
        if (typeof filter === "string") {
          if (filter === node.nodeName.toLowerCase())
            return true;
        } else if (Array.isArray(filter)) {
          if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
            return true;
        } else if (typeof filter === "function") {
          if (filter.call(rule, node, options))
            return true;
        } else {
          throw new TypeError("`filter` needs to be a string, array, or function");
        }
      }
      function collapseWhitespace(options) {
        var element = options.element;
        var isBlock2 = options.isBlock;
        var isVoid2 = options.isVoid;
        var isPre = options.isPre || function(node2) {
          return node2.nodeName === "PRE";
        };
        if (!element.firstChild || isPre(element))
          return;
        var prevText = null;
        var keepLeadingWs = false;
        var prev = null;
        var node = next(prev, element, isPre);
        while (node !== element) {
          if (node.nodeType === 3 || node.nodeType === 4) {
            var text = node.data.replace(/[ \r\n\t]+/g, " ");
            if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
              text = text.substr(1);
            }
            if (!text) {
              node = remove(node);
              continue;
            }
            node.data = text;
            prevText = node;
          } else if (node.nodeType === 1) {
            if (isBlock2(node) || node.nodeName === "BR") {
              if (prevText) {
                prevText.data = prevText.data.replace(/ $/, "");
              }
              prevText = null;
              keepLeadingWs = false;
            } else if (isVoid2(node) || isPre(node)) {
              prevText = null;
              keepLeadingWs = true;
            } else if (prevText) {
              keepLeadingWs = false;
            }
          } else {
            node = remove(node);
            continue;
          }
          var nextNode = next(prev, node, isPre);
          prev = node;
          node = nextNode;
        }
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
          if (!prevText.data) {
            remove(prevText);
          }
        }
      }
      function remove(node) {
        var next2 = node.nextSibling || node.parentNode;
        node.parentNode.removeChild(node);
        return next2;
      }
      function next(prev, current, isPre) {
        if (prev && prev.parentNode === current || isPre(current)) {
          return current.nextSibling || current.parentNode;
        }
        return current.firstChild || current.nextSibling || current.parentNode;
      }
      var root = typeof window !== "undefined" ? window : {};
      function canParseHTMLNatively() {
        var Parser2 = root.DOMParser;
        var canParse = false;
        try {
          if (new Parser2().parseFromString("", "text/html")) {
            canParse = true;
          }
        } catch (e) {
        }
        return canParse;
      }
      function createHTMLParser() {
        var Parser2 = function() {
        };
        {
          if (shouldUseActiveX()) {
            Parser2.prototype.parseFromString = function(string) {
              var doc = new window.ActiveXObject("htmlfile");
              doc.designMode = "on";
              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          } else {
            Parser2.prototype.parseFromString = function(string) {
              var doc = document.implementation.createHTMLDocument("");
              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          }
        }
        return Parser2;
      }
      function shouldUseActiveX() {
        var useActiveX = false;
        try {
          document.implementation.createHTMLDocument("").open();
        } catch (e) {
          if (window.ActiveXObject)
            useActiveX = true;
        }
        return useActiveX;
      }
      var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
      function RootNode(input, options) {
        var root2;
        if (typeof input === "string") {
          var doc = htmlParser().parseFromString(
            // DOM parsers arrange elements in the <head> and <body>.
            // Wrapping in a custom element ensures elements are reliably arranged in
            // a single element.
            '<x-turndown id="turndown-root">' + input + "</x-turndown>",
            "text/html"
          );
          root2 = doc.getElementById("turndown-root");
        } else {
          root2 = input.cloneNode(true);
        }
        collapseWhitespace({
          element: root2,
          isBlock,
          isVoid,
          isPre: options.preformattedCode ? isPreOrCode : null
        });
        return root2;
      }
      var _htmlParser;
      function htmlParser() {
        _htmlParser = _htmlParser || new HTMLParser();
        return _htmlParser;
      }
      function isPreOrCode(node) {
        return node.nodeName === "PRE" || node.nodeName === "CODE";
      }
      function Node2(node, options) {
        node.isBlock = isBlock(node);
        node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
        node.isBlank = isBlank(node);
        node.flankingWhitespace = flankingWhitespace(node, options);
        return node;
      }
      function isBlank(node) {
        return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
      }
      function flankingWhitespace(node, options) {
        if (node.isBlock || options.preformattedCode && node.isCode) {
          return { leading: "", trailing: "" };
        }
        var edges = edgeWhitespace(node.textContent);
        if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
          edges.leading = edges.leadingNonAscii;
        }
        if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
          edges.trailing = edges.trailingNonAscii;
        }
        return { leading: edges.leading, trailing: edges.trailing };
      }
      function edgeWhitespace(string) {
        var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
        return {
          leading: m[1],
          // whole string for whitespace-only strings
          leadingAscii: m[2],
          leadingNonAscii: m[3],
          trailing: m[4],
          // empty for whitespace-only strings
          trailingNonAscii: m[5],
          trailingAscii: m[6]
        };
      }
      function isFlankedByWhitespace(side, node, options) {
        var sibling;
        var regExp;
        var isFlanked;
        if (side === "left") {
          sibling = node.previousSibling;
          regExp = / $/;
        } else {
          sibling = node.nextSibling;
          regExp = /^ /;
        }
        if (sibling) {
          if (sibling.nodeType === 3) {
            isFlanked = regExp.test(sibling.nodeValue);
          } else if (options.preformattedCode && sibling.nodeName === "CODE") {
            isFlanked = false;
          } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
            isFlanked = regExp.test(sibling.textContent);
          }
        }
        return isFlanked;
      }
      var reduce = Array.prototype.reduce;
      var escapes = [
        [/\\/g, "\\\\"],
        [/\*/g, "\\*"],
        [/^-/g, "\\-"],
        [/^\+ /g, "\\+ "],
        [/^(=+)/g, "\\$1"],
        [/^(#{1,6}) /g, "\\$1 "],
        [/`/g, "\\`"],
        [/^~~~/g, "\\~~~"],
        [/\[/g, "\\["],
        [/\]/g, "\\]"],
        [/^>/g, "\\>"],
        [/_/g, "\\_"],
        [/^(\d+)\. /g, "$1\\. "]
      ];
      function TurndownService(options) {
        if (!(this instanceof TurndownService))
          return new TurndownService(options);
        var defaults = {
          rules,
          headingStyle: "setext",
          hr: "* * *",
          bulletListMarker: "*",
          codeBlockStyle: "indented",
          fence: "```",
          emDelimiter: "_",
          strongDelimiter: "**",
          linkStyle: "inlined",
          linkReferenceStyle: "full",
          br: "  ",
          preformattedCode: false,
          blankReplacement: function(content, node) {
            return node.isBlock ? "\n\n" : "";
          },
          keepReplacement: function(content, node) {
            return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
          },
          defaultReplacement: function(content, node) {
            return node.isBlock ? "\n\n" + content + "\n\n" : content;
          }
        };
        this.options = extend({}, defaults, options);
        this.rules = new Rules(this.options);
      }
      TurndownService.prototype = {
        /**
         * The entry point for converting a string or DOM node to Markdown
         * @public
         * @param {String|HTMLElement} input The string or DOM node to convert
         * @returns A Markdown representation of the input
         * @type String
         */
        turndown: function(input) {
          if (!canConvert(input)) {
            throw new TypeError(
              input + " is not a string, or an element/document/fragment node."
            );
          }
          if (input === "")
            return "";
          var output = process.call(this, new RootNode(input, this.options));
          return postProcess.call(this, output);
        },
        /**
         * Add one or more plugins
         * @public
         * @param {Function|Array} plugin The plugin or array of plugins to add
         * @returns The Turndown instance for chaining
         * @type Object
         */
        use: function(plugin) {
          if (Array.isArray(plugin)) {
            for (var i = 0; i < plugin.length; i++)
              this.use(plugin[i]);
          } else if (typeof plugin === "function") {
            plugin(this);
          } else {
            throw new TypeError("plugin must be a Function or an Array of Functions");
          }
          return this;
        },
        /**
         * Adds a rule
         * @public
         * @param {String} key The unique key of the rule
         * @param {Object} rule The rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        addRule: function(key, rule) {
          this.rules.add(key, rule);
          return this;
        },
        /**
         * Keep a node (as HTML) that matches the filter
         * @public
         * @param {String|Array|Function} filter The unique key of the rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        keep: function(filter) {
          this.rules.keep(filter);
          return this;
        },
        /**
         * Remove a node that matches the filter
         * @public
         * @param {String|Array|Function} filter The unique key of the rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        remove: function(filter) {
          this.rules.remove(filter);
          return this;
        },
        /**
         * Escapes Markdown syntax
         * @public
         * @param {String} string The string to escape
         * @returns A string with Markdown syntax escaped
         * @type String
         */
        escape: function(string) {
          return escapes.reduce(function(accumulator, escape2) {
            return accumulator.replace(escape2[0], escape2[1]);
          }, string);
        }
      };
      function process(parentNode) {
        var self2 = this;
        return reduce.call(parentNode.childNodes, function(output, node) {
          node = new Node2(node, self2.options);
          var replacement = "";
          if (node.nodeType === 3) {
            replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
          } else if (node.nodeType === 1) {
            replacement = replacementForNode.call(self2, node);
          }
          return join(output, replacement);
        }, "");
      }
      function postProcess(output) {
        var self2 = this;
        this.rules.forEach(function(rule) {
          if (typeof rule.append === "function") {
            output = join(output, rule.append(self2.options));
          }
        });
        return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
      }
      function replacementForNode(node) {
        var rule = this.rules.forNode(node);
        var content = process.call(this, node);
        var whitespace = node.flankingWhitespace;
        if (whitespace.leading || whitespace.trailing)
          content = content.trim();
        return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
      }
      function join(output, replacement) {
        var s1 = trimTrailingNewlines(output);
        var s2 = trimLeadingNewlines(replacement);
        var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
        var separator = "\n\n".substring(0, nls);
        return s1 + separator + s2;
      }
      function canConvert(input) {
        return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
      }
      module.exports = TurndownService;
    }
  });

  // node_modules/@postlight/parser/src/shims/iconv-lite.js
  var iconv_lite_exports = {};
  __export(iconv_lite_exports, {
    default: () => iconv_lite_default
  });
  var iconv, iconv_lite_default;
  var init_iconv_lite = __esm({
    "node_modules/@postlight/parser/src/shims/iconv-lite.js"() {
      iconv = {
        encodingExists: () => false,
        decode: (s) => s
      };
      iconv_lite_default = iconv;
    }
  });

  // node_modules/core-js/library/modules/_string-ws.js
  var require_string_ws = __commonJS({
    "node_modules/core-js/library/modules/_string-ws.js"(exports, module) {
      module.exports = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }
  });

  // node_modules/core-js/library/modules/_string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/library/modules/_string-trim.js"(exports, module) {
      var $export = require_export();
      var defined = require_defined();
      var fails = require_fails();
      var spaces = require_string_ws();
      var space = "[" + spaces + "]";
      var non = "\u200B\x85";
      var ltrim = RegExp("^" + space + space + "*");
      var rtrim = RegExp(space + space + "*$");
      var exporter = function(KEY, exec, ALIAS) {
        var exp = {};
        var FORCE = fails(function() {
          return !!spaces[KEY]() || non[KEY]() != non;
        });
        var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
        if (ALIAS)
          exp[ALIAS] = fn;
        $export($export.P + $export.F * FORCE, "String", exp);
      };
      var trim = exporter.trim = function(string, TYPE) {
        string = String(defined(string));
        if (TYPE & 1)
          string = string.replace(ltrim, "");
        if (TYPE & 2)
          string = string.replace(rtrim, "");
        return string;
      };
      module.exports = exporter;
    }
  });

  // node_modules/core-js/library/modules/_parse-int.js
  var require_parse_int = __commonJS({
    "node_modules/core-js/library/modules/_parse-int.js"(exports, module) {
      var $parseInt = require_global().parseInt;
      var $trim = require_string_trim().trim;
      var ws = require_string_ws();
      var hex = /^[-+]?0[xX]/;
      module.exports = $parseInt(ws + "08") !== 8 || $parseInt(ws + "0x16") !== 22 ? function parseInt2(str, radix) {
        var string = $trim(String(str), 3);
        return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
      } : $parseInt;
    }
  });

  // node_modules/core-js/library/modules/es6.parse-int.js
  var require_es6_parse_int = __commonJS({
    "node_modules/core-js/library/modules/es6.parse-int.js"() {
      var $export = require_export();
      var $parseInt = require_parse_int();
      $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });
    }
  });

  // node_modules/core-js/library/fn/parse-int.js
  var require_parse_int2 = __commonJS({
    "node_modules/core-js/library/fn/parse-int.js"(exports, module) {
      require_es6_parse_int();
      module.exports = require_core().parseInt;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/parse-int.js
  var require_parse_int3 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/parse-int.js"(exports, module) {
      module.exports = require_parse_int2();
    }
  });

  // node_modules/core-js/library/modules/es6.array.is-array.js
  var require_es6_array_is_array = __commonJS({
    "node_modules/core-js/library/modules/es6.array.is-array.js"() {
      var $export = require_export();
      $export($export.S, "Array", { isArray: require_is_array() });
    }
  });

  // node_modules/core-js/library/fn/array/is-array.js
  var require_is_array2 = __commonJS({
    "node_modules/core-js/library/fn/array/is-array.js"(exports, module) {
      require_es6_array_is_array();
      module.exports = require_core().Array.isArray;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/arrayWithHoles.js"(exports, module) {
      var _Array$isArray = require_is_array2();
      function _arrayWithHoles(arr) {
        if (_Array$isArray(arr))
          return arr;
      }
      module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/iterableToArrayLimit.js"(exports, module) {
      var _Symbol = require_symbol();
      var _Symbol$iterator = require_iterator();
      function _iterableToArrayLimit(arr, i) {
        var _i = null == arr ? null : "undefined" != typeof _Symbol && arr[_Symbol$iterator] || arr["@@iterator"];
        if (null != _i) {
          var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
          try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
              if (Object(_i) !== _i)
                return;
              _n = false;
            } else
              for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
                ;
          } catch (err) {
            _d = true, _e = err;
          } finally {
            try {
              if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
                return;
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
      }
      module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/core-js/library/modules/_create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/library/modules/_create-property.js"(exports, module) {
      "use strict";
      var $defineProperty = require_object_dp();
      var createDesc = require_property_desc();
      module.exports = function(object, index, value) {
        if (index in object)
          $defineProperty.f(object, index, createDesc(0, value));
        else
          object[index] = value;
      };
    }
  });

  // node_modules/core-js/library/modules/es6.array.from.js
  var require_es6_array_from = __commonJS({
    "node_modules/core-js/library/modules/es6.array.from.js"() {
      "use strict";
      var ctx = require_ctx();
      var $export = require_export();
      var toObject = require_to_object();
      var call = require_iter_call();
      var isArrayIter = require_is_array_iter();
      var toLength = require_to_length();
      var createProperty = require_create_property();
      var getIterFn = require_core_get_iterator_method();
      $export($export.S + $export.F * !require_iter_detect()(function(iter) {
        Array.from(iter);
      }), "Array", {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike) {
          var O = toObject(arrayLike);
          var C = typeof this == "function" ? this : Array;
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          var index = 0;
          var iterFn = getIterFn(O);
          var length, result, step, iterator;
          if (mapping)
            mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : void 0, 2);
          if (iterFn != void 0 && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);
            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }
          result.length = index;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/library/fn/array/from.js
  var require_from = __commonJS({
    "node_modules/core-js/library/fn/array/from.js"(exports, module) {
      require_es6_string_iterator();
      require_es6_array_from();
      module.exports = require_core().Array.from;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/arrayLikeToArray.js"(exports, module) {
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/unsupportedIterableToArray.js"(exports, module) {
      var _Array$from = require_from();
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return _Array$from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return arrayLikeToArray(o, minLen);
      }
      module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/nonIterableRest.js"(exports, module) {
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/slicedToArray.js"(exports, module) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }
      module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/promise.js
  var require_promise2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/promise.js"(exports, module) {
      module.exports = require_promise();
    }
  });

  // node_modules/@postlight/parser/node_modules/next-line/index.js
  var require_next_line = __commonJS({
    "node_modules/@postlight/parser/node_modules/next-line/index.js"(exports, module) {
      "use strict";
      module.exports = function(str) {
        var offset = 0;
        str = str.toString();
        return iterator;
        function iterator() {
          var i1 = str.indexOf("\r\n", offset);
          var i2 = str.indexOf("\n", offset);
          var i3 = str.indexOf("\r", offset);
          var indexes = [i1, i2, i3];
          var index = indexes.sort(function(a, b) {
            if (a > b)
              return 1;
            if (a < b)
              return -1;
            return 0;
          }).filter(function(index2) {
            return index2 !== -1;
          })[0];
          if (index !== void 0)
            return extract(index, index === i1 ? 2 : 1);
          var length = str.length;
          if (length === offset)
            return null;
          return extract(length, 0);
        }
        function extract(index, skip) {
          var line = str.substr(offset, index - offset);
          offset = index + skip;
          return line;
        }
      };
    }
  });

  // node_modules/@postlight/parser/node_modules/http-headers/index.js
  var require_http_headers = __commonJS({
    "node_modules/@postlight/parser/node_modules/http-headers/index.js"(exports, module) {
      "use strict";
      var nextLine = require_next_line();
      var startLine = /^[A-Z_]+(\/\d\.\d)? /;
      var requestLine = /^([A-Z_]+) (.+) [A-Z]+\/(\d)\.(\d)$/;
      var statusLine = /^[A-Z]+\/(\d)\.(\d) (\d{3}) (.*)$/;
      module.exports = function(data, onlyHeaders) {
        return parse(normalize(data), onlyHeaders);
      };
      function parse(str, onlyHeaders) {
        var line = firstLine(str);
        var match;
        if (onlyHeaders && startLine.test(line)) {
          return parseHeaders(str);
        } else if ((match = line.match(requestLine)) !== null) {
          return {
            method: match[1],
            url: match[2],
            version: { major: parseInt(match[3], 10), minor: parseInt(match[4], 10) },
            headers: parseHeaders(str)
          };
        } else if ((match = line.match(statusLine)) !== null) {
          return {
            version: { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) },
            statusCode: parseInt(match[3], 10),
            statusMessage: match[4],
            headers: parseHeaders(str)
          };
        } else {
          return parseHeaders(str);
        }
      }
      function parseHeaders(str) {
        var headers = {};
        var next = nextLine(str);
        var line = next();
        var index, name, value;
        if (startLine.test(line))
          line = next();
        while (line) {
          if (line[0] === " " || line[0] === "	") {
            value += " " + line.trim();
            line = next();
            continue;
          }
          if (name)
            addHeaderLine(name, value, headers);
          index = line.indexOf(":");
          name = line.substr(0, index);
          value = line.substr(index + 1).trim();
          line = next();
        }
        if (name)
          addHeaderLine(name, value, headers);
        return headers;
      }
      function normalize(str) {
        if (str && str._header)
          str = str._header;
        if (!str || typeof str.toString !== "function")
          return "";
        return str.toString().trim();
      }
      function firstLine(str) {
        var nl = str.indexOf("\r\n");
        if (nl === -1)
          return str;
        else
          return str.slice(0, nl);
      }
      function addHeaderLine(field, value, dest) {
        field = field.toLowerCase();
        switch (field) {
          case "set-cookie":
            if (dest[field] !== void 0) {
              dest[field].push(value);
            } else {
              dest[field] = [value];
            }
            break;
          case "content-type":
          case "content-length":
          case "user-agent":
          case "referer":
          case "host":
          case "authorization":
          case "proxy-authorization":
          case "if-modified-since":
          case "if-unmodified-since":
          case "from":
          case "location":
          case "max-forwards":
          case "retry-after":
          case "etag":
          case "last-modified":
          case "server":
          case "age":
          case "expires":
            if (dest[field] === void 0)
              dest[field] = value;
            break;
          default:
            if (typeof dest[field] === "string") {
              dest[field] += ", " + value;
            } else {
              dest[field] = value;
            }
        }
      }
    }
  });

  // node_modules/@postlight/parser/node_modules/browser-request/index.js
  var require_browser_request = __commonJS({
    "node_modules/@postlight/parser/node_modules/browser-request/index.js"(exports, module) {
      var httpHeaders = require_http_headers();
      var XHR = XMLHttpRequest;
      if (!XHR)
        throw new Error("missing XMLHttpRequest");
      request2.log = {
        "trace": noop,
        "debug": noop,
        "info": noop,
        "warn": noop,
        "error": noop
      };
      var DEFAULT_TIMEOUT = 3 * 60 * 1e3;
      function request2(options, callback) {
        if (typeof callback !== "function")
          throw new Error("Bad callback given: " + callback);
        if (!options)
          throw new Error("No options given");
        var options_onResponse = options.onResponse;
        if (typeof options === "string")
          options = { "uri": options };
        else
          options = JSON.parse(JSON.stringify(options));
        options.onResponse = options_onResponse;
        if (options.verbose)
          request2.log = getLogger();
        if (options.url) {
          options.uri = options.url;
          delete options.url;
        }
        if (!options.uri && options.uri !== "")
          throw new Error("options.uri is a required argument");
        if (typeof options.uri != "string")
          throw new Error("options.uri must be a string");
        var unsupported_options = ["proxy", "_redirectsFollowed", "maxRedirects", "followRedirect"];
        for (var i = 0; i < unsupported_options.length; i++)
          if (options[unsupported_options[i]])
            throw new Error("options." + unsupported_options[i] + " is not supported");
        options.callback = callback;
        options.method = options.method || "GET";
        options.headers = options.headers || {};
        options.body = options.body || null;
        options.timeout = options.timeout || request2.DEFAULT_TIMEOUT;
        if (options.headers.host)
          throw new Error("Options.headers.host is not supported");
        if (options.json) {
          options.headers.accept = options.headers.accept || "application/json";
          if (options.method !== "GET")
            options.headers["content-type"] = "application/json";
          if (typeof options.json !== "boolean")
            options.body = JSON.stringify(options.json);
          else if (typeof options.body !== "string")
            options.body = JSON.stringify(options.body);
        }
        var serialize = function(obj) {
          var str = [];
          for (var p in obj)
            if (obj.hasOwnProperty(p)) {
              str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
            }
          return str.join("&");
        };
        if (options.qs) {
          var qs = typeof options.qs == "string" ? options.qs : serialize(options.qs);
          if (options.uri.indexOf("?") !== -1) {
            options.uri = options.uri + "&" + qs;
          } else {
            options.uri = options.uri + "?" + qs;
          }
        }
        var multipart = function(obj) {
          var result = {};
          result.boundry = "-------------------------------" + Math.floor(Math.random() * 1e9);
          var lines = [];
          for (var p in obj) {
            if (obj.hasOwnProperty(p)) {
              lines.push(
                "--" + result.boundry + '\nContent-Disposition: form-data; name="' + p + '"\n\n' + obj[p] + "\n"
              );
            }
          }
          lines.push("--" + result.boundry + "--");
          result.body = lines.join("");
          result.length = result.body.length;
          result.type = "multipart/form-data; boundary=" + result.boundry;
          return result;
        };
        if (options.form) {
          if (typeof options.form == "string")
            throw "form name unsupported";
          if (options.method === "POST") {
            var encoding = (options.encoding || "application/x-www-form-urlencoded").toLowerCase();
            options.headers["content-type"] = encoding;
            switch (encoding) {
              case "application/x-www-form-urlencoded":
                options.body = serialize(options.form).replace(/%20/g, "+");
                break;
              case "multipart/form-data":
                var multi = multipart(options.form);
                options.body = multi.body;
                options.headers["content-type"] = multi.type;
                break;
              default:
                throw new Error("unsupported encoding:" + encoding);
            }
          }
        }
        options.onResponse = options.onResponse || noop;
        if (options.onResponse === true) {
          options.onResponse = callback;
          options.callback = noop;
        }
        if (!options.headers.authorization && options.auth)
          options.headers.authorization = "Basic " + b64_enc(options.auth.username + ":" + options.auth.password);
        return run_xhr(options);
      }
      var req_seq = 0;
      function run_xhr(options) {
        var xhr = new XHR(), timed_out = false, is_cors = is_crossDomain(options.uri), supports_cors = "withCredentials" in xhr;
        req_seq += 1;
        xhr.seq_id = req_seq;
        xhr.id = req_seq + ": " + options.method + " " + options.uri;
        xhr._id = xhr.id;
        if (is_cors && !supports_cors) {
          var cors_err = new Error("Browser does not support cross-origin request: " + options.uri);
          cors_err.cors = "unsupported";
          return options.callback(cors_err, xhr);
        }
        xhr.timeoutTimer = setTimeout(too_late, options.timeout);
        function too_late() {
          timed_out = true;
          var er = new Error("ETIMEDOUT");
          er.code = "ETIMEDOUT";
          er.duration = options.timeout;
          request2.log.error("Timeout", { "id": xhr._id, "milliseconds": options.timeout });
          return options.callback(er, xhr);
        }
        var did = { "response": false, "loading": false, "end": false };
        xhr.onreadystatechange = on_state_change;
        xhr.open(options.method, options.uri, true);
        if (is_cors)
          xhr.withCredentials = !!options.withCredentials;
        xhr.send(options.body);
        return xhr;
        function on_state_change(event) {
          if (timed_out)
            return request2.log.debug("Ignoring timed out state change", { "state": xhr.readyState, "id": xhr.id });
          request2.log.debug("State change", { "state": xhr.readyState, "id": xhr.id, "timed_out": timed_out });
          if (xhr.readyState === XHR.OPENED) {
            request2.log.debug("Request started", { "id": xhr.id });
            for (var key in options.headers)
              xhr.setRequestHeader(key, options.headers[key]);
          } else if (xhr.readyState === XHR.HEADERS_RECEIVED)
            on_response();
          else if (xhr.readyState === XHR.LOADING) {
            on_response();
            on_loading();
          } else if (xhr.readyState === XHR.DONE) {
            on_response();
            on_loading();
            on_end();
          }
        }
        function on_response() {
          if (did.response)
            return;
          did.response = true;
          request2.log.debug("Got response", { "id": xhr.id, "status": xhr.status });
          clearTimeout(xhr.timeoutTimer);
          xhr.statusCode = xhr.status;
          if (is_cors && xhr.statusCode == 0) {
            var cors_err2 = new Error("CORS request rejected: " + options.uri);
            cors_err2.cors = "rejected";
            did.loading = true;
            did.end = true;
            return options.callback(cors_err2, xhr);
          }
          options.onResponse(null, xhr);
        }
        function on_loading() {
          if (did.loading)
            return;
          did.loading = true;
          request2.log.debug("Response body loading", { "id": xhr.id });
        }
        function on_end() {
          if (did.end)
            return;
          did.end = true;
          request2.log.debug("Request done", { "id": xhr.id });
          xhr.body = xhr.responseText;
          xhr.headers = httpHeaders(xhr.getAllResponseHeaders());
          if (options.json) {
            try {
              xhr.body = JSON.parse(xhr.responseText);
            } catch (er) {
              return options.callback(er, xhr);
            }
          }
          options.callback(null, xhr, xhr.body);
        }
      }
      request2.withCredentials = false;
      request2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
      request2.defaults = function(options, requester) {
        var def = function(method) {
          var d = function(params, callback) {
            if (typeof params === "string")
              params = { "uri": params };
            else {
              params = JSON.parse(JSON.stringify(params));
            }
            for (var i in options) {
              if (params[i] === void 0)
                params[i] = options[i];
            }
            return method(params, callback);
          };
          return d;
        };
        var de = def(request2);
        de.get = def(request2.get);
        de.post = def(request2.post);
        de.put = def(request2.put);
        de.head = def(request2.head);
        return de;
      };
      var shortcuts = ["get", "put", "post", "head"];
      shortcuts.forEach(function(shortcut) {
        var method = shortcut.toUpperCase();
        var func = shortcut.toLowerCase();
        request2[func] = function(opts) {
          if (typeof opts === "string")
            opts = { "method": method, "uri": opts };
          else {
            opts = JSON.parse(JSON.stringify(opts));
            opts.method = method;
          }
          var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
          return request2.apply(this, args);
        };
      });
      request2.couch = function(options, callback) {
        if (typeof options === "string")
          options = { "uri": options };
        options.json = true;
        if (options.body)
          options.json = options.body;
        delete options.body;
        callback = callback || noop;
        var xhr = request2(options, couch_handler);
        return xhr;
        function couch_handler(er, resp, body) {
          if (er)
            return callback(er, resp, body);
          if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
            er = new Error("CouchDB error: " + (body.error.reason || body.error.error));
            for (var key in body)
              er[key] = body[key];
            return callback(er, resp, body);
          }
          return callback(er, resp, body);
        }
      };
      function noop() {
      }
      function getLogger() {
        var logger = {}, levels = ["trace", "debug", "info", "warn", "error"], level, i;
        for (i = 0; i < levels.length; i++) {
          level = levels[i];
          logger[level] = noop;
          if (typeof console !== "undefined" && console && console[level])
            logger[level] = formatted(console, level);
        }
        return logger;
      }
      function formatted(obj, method) {
        return formatted_logger;
        function formatted_logger(str, context) {
          if (typeof context === "object")
            str += " " + JSON.stringify(context);
          return obj[method].call(obj, str);
        }
      }
      function is_crossDomain(url) {
        var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;
        var ajaxLocation;
        try {
          ajaxLocation = location.href;
        } catch (e) {
          ajaxLocation = document.createElement("a");
          ajaxLocation.href = "";
          ajaxLocation = ajaxLocation.href;
        }
        var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], parts = rurl.exec(url.toLowerCase());
        var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));
        return result;
      }
      function b64_enc(data) {
        var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "", tmp_arr = [];
        if (!data) {
          return data;
        }
        do {
          o1 = data.charCodeAt(i++);
          o2 = data.charCodeAt(i++);
          o3 = data.charCodeAt(i++);
          bits = o1 << 16 | o2 << 8 | o3;
          h1 = bits >> 18 & 63;
          h2 = bits >> 12 & 63;
          h3 = bits >> 6 & 63;
          h4 = bits & 63;
          tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
        } while (i < data.length);
        enc = tmp_arr.join("");
        switch (data.length % 3) {
          case 1:
            enc = enc.slice(0, -2) + "==";
            break;
          case 2:
            enc = enc.slice(0, -1) + "=";
            break;
        }
        return enc;
      }
      module.exports = request2;
    }
  });

  // node_modules/core-js/library/modules/_own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/library/modules/_own-keys.js"(exports, module) {
      var gOPN = require_object_gopn();
      var gOPS = require_object_gops();
      var anObject = require_an_object();
      var Reflect2 = require_global().Reflect;
      module.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
        var keys = gOPN.f(anObject(it));
        var getSymbols = gOPS.f;
        return getSymbols ? keys.concat(getSymbols(it)) : keys;
      };
    }
  });

  // node_modules/core-js/library/modules/es6.reflect.own-keys.js
  var require_es6_reflect_own_keys = __commonJS({
    "node_modules/core-js/library/modules/es6.reflect.own-keys.js"() {
      var $export = require_export();
      $export($export.S, "Reflect", { ownKeys: require_own_keys() });
    }
  });

  // node_modules/core-js/library/fn/reflect/own-keys.js
  var require_own_keys2 = __commonJS({
    "node_modules/core-js/library/fn/reflect/own-keys.js"(exports, module) {
      require_es6_reflect_own_keys();
      module.exports = require_core().Reflect.ownKeys;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/reflect/own-keys.js
  var require_own_keys3 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/reflect/own-keys.js"(exports, module) {
      module.exports = require_own_keys2();
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/arrayWithoutHoles.js
  var require_arrayWithoutHoles = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/arrayWithoutHoles.js"(exports, module) {
      var _Array$isArray = require_is_array2();
      var arrayLikeToArray = require_arrayLikeToArray();
      function _arrayWithoutHoles(arr) {
        if (_Array$isArray(arr))
          return arrayLikeToArray(arr);
      }
      module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/iterableToArray.js
  var require_iterableToArray = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/iterableToArray.js"(exports, module) {
      var _Symbol = require_symbol();
      var _Symbol$iterator = require_iterator();
      var _Array$from = require_from();
      function _iterableToArray(iter) {
        if (typeof _Symbol !== "undefined" && iter[_Symbol$iterator] != null || iter["@@iterator"] != null)
          return _Array$from(iter);
      }
      module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/nonIterableSpread.js
  var require_nonIterableSpread = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/nonIterableSpread.js"(exports, module) {
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime-corejs2/helpers/toConsumableArray.js
  var require_toConsumableArray = __commonJS({
    "node_modules/@babel/runtime-corejs2/helpers/toConsumableArray.js"(exports, module) {
      var arrayWithoutHoles = require_arrayWithoutHoles();
      var iterableToArray = require_iterableToArray();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableSpread = require_nonIterableSpread();
      function _toConsumableArray(arr) {
        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
      }
      module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/core-js/library/modules/_parse-float.js
  var require_parse_float = __commonJS({
    "node_modules/core-js/library/modules/_parse-float.js"(exports, module) {
      var $parseFloat = require_global().parseFloat;
      var $trim = require_string_trim().trim;
      module.exports = 1 / $parseFloat(require_string_ws() + "-0") !== -Infinity ? function parseFloat2(str) {
        var string = $trim(String(str), 3);
        var result = $parseFloat(string);
        return result === 0 && string.charAt(0) == "-" ? -0 : result;
      } : $parseFloat;
    }
  });

  // node_modules/core-js/library/modules/es6.parse-float.js
  var require_es6_parse_float = __commonJS({
    "node_modules/core-js/library/modules/es6.parse-float.js"() {
      var $export = require_export();
      var $parseFloat = require_parse_float();
      $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });
    }
  });

  // node_modules/core-js/library/fn/parse-float.js
  var require_parse_float2 = __commonJS({
    "node_modules/core-js/library/fn/parse-float.js"(exports, module) {
      require_es6_parse_float();
      module.exports = require_core().parseFloat;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/parse-float.js
  var require_parse_float3 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/parse-float.js"(exports, module) {
      module.exports = require_parse_float2();
    }
  });

  // node_modules/core-js/library/modules/_validate-collection.js
  var require_validate_collection = __commonJS({
    "node_modules/core-js/library/modules/_validate-collection.js"(exports, module) {
      var isObject = require_is_object();
      module.exports = function(it, TYPE) {
        if (!isObject(it) || it._t !== TYPE)
          throw TypeError("Incompatible receiver, " + TYPE + " required!");
        return it;
      };
    }
  });

  // node_modules/core-js/library/modules/_collection-strong.js
  var require_collection_strong = __commonJS({
    "node_modules/core-js/library/modules/_collection-strong.js"(exports, module) {
      "use strict";
      var dP = require_object_dp().f;
      var create = require_object_create();
      var redefineAll = require_redefine_all();
      var ctx = require_ctx();
      var anInstance = require_an_instance();
      var forOf = require_for_of();
      var $iterDefine = require_iter_define();
      var step = require_iter_step();
      var setSpecies = require_set_species();
      var DESCRIPTORS = require_descriptors();
      var fastKey = require_meta().fastKey;
      var validate = require_validate_collection();
      var SIZE = DESCRIPTORS ? "_s" : "size";
      var getEntry = function(that, key) {
        var index = fastKey(key);
        var entry;
        if (index !== "F")
          return that._i[index];
        for (entry = that._f; entry; entry = entry.n) {
          if (entry.k == key)
            return entry;
        }
      };
      module.exports = {
        getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function(that, iterable) {
            anInstance(that, C, NAME, "_i");
            that._t = NAME;
            that._i = create(null);
            that._f = void 0;
            that._l = void 0;
            that[SIZE] = 0;
            if (iterable != void 0)
              forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                entry.r = true;
                if (entry.p)
                  entry.p = entry.p.n = void 0;
                delete data[entry.i];
              }
              that._f = that._l = void 0;
              that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            "delete": function(key) {
              var that = validate(this, NAME);
              var entry = getEntry(that, key);
              if (entry) {
                var next = entry.n;
                var prev = entry.p;
                delete that._i[entry.i];
                entry.r = true;
                if (prev)
                  prev.n = next;
                if (next)
                  next.p = prev;
                if (that._f == entry)
                  that._f = next;
                if (that._l == entry)
                  that._l = prev;
                that[SIZE]--;
              }
              return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn) {
              validate(this, NAME);
              var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
              var entry;
              while (entry = entry ? entry.n : this._f) {
                f(entry.v, entry.k, this);
                while (entry && entry.r)
                  entry = entry.p;
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(validate(this, NAME), key);
            }
          });
          if (DESCRIPTORS)
            dP(C.prototype, "size", {
              get: function() {
                return validate(this, NAME)[SIZE];
              }
            });
          return C;
        },
        def: function(that, key, value) {
          var entry = getEntry(that, key);
          var prev, index;
          if (entry) {
            entry.v = value;
          } else {
            that._l = entry = {
              i: index = fastKey(key, true),
              // <- index
              k: key,
              // <- key
              v: value,
              // <- value
              p: prev = that._l,
              // <- previous entry
              n: void 0,
              // <- next entry
              r: false
              // <- removed
            };
            if (!that._f)
              that._f = entry;
            if (prev)
              prev.n = entry;
            that[SIZE]++;
            if (index !== "F")
              that._i[index] = entry;
          }
          return that;
        },
        getEntry,
        setStrong: function(C, NAME, IS_MAP) {
          $iterDefine(C, NAME, function(iterated, kind) {
            this._t = validate(iterated, NAME);
            this._k = kind;
            this._l = void 0;
          }, function() {
            var that = this;
            var kind = that._k;
            var entry = that._l;
            while (entry && entry.r)
              entry = entry.p;
            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
              that._t = void 0;
              return step(1);
            }
            if (kind == "keys")
              return step(0, entry.k);
            if (kind == "values")
              return step(0, entry.v);
            return step(0, [entry.k, entry.v]);
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(NAME);
        }
      };
    }
  });

  // node_modules/core-js/library/modules/_array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/library/modules/_array-species-constructor.js"(exports, module) {
      var isObject = require_is_object();
      var isArray = require_is_array();
      var SPECIES = require_wks()("species");
      module.exports = function(original) {
        var C;
        if (isArray(original)) {
          C = original.constructor;
          if (typeof C == "function" && (C === Array || isArray(C.prototype)))
            C = void 0;
          if (isObject(C)) {
            C = C[SPECIES];
            if (C === null)
              C = void 0;
          }
        }
        return C === void 0 ? Array : C;
      };
    }
  });

  // node_modules/core-js/library/modules/_array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/library/modules/_array-species-create.js"(exports, module) {
      var speciesConstructor = require_array_species_constructor();
      module.exports = function(original, length) {
        return new (speciesConstructor(original))(length);
      };
    }
  });

  // node_modules/core-js/library/modules/_array-methods.js
  var require_array_methods = __commonJS({
    "node_modules/core-js/library/modules/_array-methods.js"(exports, module) {
      var ctx = require_ctx();
      var IObject = require_iobject();
      var toObject = require_to_object();
      var toLength = require_to_length();
      var asc = require_array_species_create();
      module.exports = function(TYPE, $create) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        var create = $create || asc;
        return function($this, callbackfn, that) {
          var O = toObject($this);
          var self2 = IObject(O);
          var f = ctx(callbackfn, that, 3);
          var length = toLength(self2.length);
          var index = 0;
          var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
          var val, res;
          for (; length > index; index++)
            if (NO_HOLES || index in self2) {
              val = self2[index];
              res = f(val, index, O);
              if (TYPE) {
                if (IS_MAP)
                  result[index] = res;
                else if (res)
                  switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return val;
                    case 6:
                      return index;
                    case 2:
                      result.push(val);
                  }
                else if (IS_EVERY)
                  return false;
              }
            }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
    }
  });

  // node_modules/core-js/library/modules/_collection.js
  var require_collection = __commonJS({
    "node_modules/core-js/library/modules/_collection.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var $export = require_export();
      var meta = require_meta();
      var fails = require_fails();
      var hide = require_hide();
      var redefineAll = require_redefine_all();
      var forOf = require_for_of();
      var anInstance = require_an_instance();
      var isObject = require_is_object();
      var setToStringTag = require_set_to_string_tag();
      var dP = require_object_dp().f;
      var each = require_array_methods()(0);
      var DESCRIPTORS = require_descriptors();
      module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global2[NAME];
        var C = Base;
        var ADDER = IS_MAP ? "set" : "add";
        var proto = C && C.prototype;
        var O = {};
        if (!DESCRIPTORS || typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
          new C().entries().next();
        }))) {
          C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
          redefineAll(C.prototype, methods);
          meta.NEED = true;
        } else {
          C = wrapper(function(target, iterable) {
            anInstance(target, C, NAME, "_c");
            target._c = new Base();
            if (iterable != void 0)
              forOf(iterable, IS_MAP, target[ADDER], target);
          });
          each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
            var IS_ADDER = KEY == "add" || KEY == "set";
            if (KEY in proto && !(IS_WEAK && KEY == "clear"))
              hide(C.prototype, KEY, function(a, b) {
                anInstance(this, C, KEY);
                if (!IS_ADDER && IS_WEAK && !isObject(a))
                  return KEY == "get" ? void 0 : false;
                var result = this._c[KEY](a === 0 ? 0 : a, b);
                return IS_ADDER ? this : result;
              });
          });
          IS_WEAK || dP(C.prototype, "size", {
            get: function() {
              return this._c.size;
            }
          });
        }
        setToStringTag(C, NAME);
        O[NAME] = C;
        $export($export.G + $export.W + $export.F, O);
        if (!IS_WEAK)
          common.setStrong(C, NAME, IS_MAP);
        return C;
      };
    }
  });

  // node_modules/core-js/library/modules/es6.set.js
  var require_es6_set = __commonJS({
    "node_modules/core-js/library/modules/es6.set.js"(exports, module) {
      "use strict";
      var strong = require_collection_strong();
      var validate = require_validate_collection();
      var SET = "Set";
      module.exports = require_collection()(SET, function(get) {
        return function Set() {
          return get(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
        }
      }, strong);
    }
  });

  // node_modules/core-js/library/modules/_array-from-iterable.js
  var require_array_from_iterable = __commonJS({
    "node_modules/core-js/library/modules/_array-from-iterable.js"(exports, module) {
      var forOf = require_for_of();
      module.exports = function(iter, ITERATOR) {
        var result = [];
        forOf(iter, false, result.push, result, ITERATOR);
        return result;
      };
    }
  });

  // node_modules/core-js/library/modules/_collection-to-json.js
  var require_collection_to_json = __commonJS({
    "node_modules/core-js/library/modules/_collection-to-json.js"(exports, module) {
      var classof = require_classof();
      var from = require_array_from_iterable();
      module.exports = function(NAME) {
        return function toJSON() {
          if (classof(this) != NAME)
            throw TypeError(NAME + "#toJSON isn't generic");
          return from(this);
        };
      };
    }
  });

  // node_modules/core-js/library/modules/es7.set.to-json.js
  var require_es7_set_to_json = __commonJS({
    "node_modules/core-js/library/modules/es7.set.to-json.js"() {
      var $export = require_export();
      $export($export.P + $export.R, "Set", { toJSON: require_collection_to_json()("Set") });
    }
  });

  // node_modules/core-js/library/modules/_set-collection-of.js
  var require_set_collection_of = __commonJS({
    "node_modules/core-js/library/modules/_set-collection-of.js"(exports, module) {
      "use strict";
      var $export = require_export();
      module.exports = function(COLLECTION) {
        $export($export.S, COLLECTION, { of: function of() {
          var length = arguments.length;
          var A = new Array(length);
          while (length--)
            A[length] = arguments[length];
          return new this(A);
        } });
      };
    }
  });

  // node_modules/core-js/library/modules/es7.set.of.js
  var require_es7_set_of = __commonJS({
    "node_modules/core-js/library/modules/es7.set.of.js"() {
      require_set_collection_of()("Set");
    }
  });

  // node_modules/core-js/library/modules/_set-collection-from.js
  var require_set_collection_from = __commonJS({
    "node_modules/core-js/library/modules/_set-collection-from.js"(exports, module) {
      "use strict";
      var $export = require_export();
      var aFunction = require_a_function();
      var ctx = require_ctx();
      var forOf = require_for_of();
      module.exports = function(COLLECTION) {
        $export($export.S, COLLECTION, { from: function from(source) {
          var mapFn = arguments[1];
          var mapping, A, n, cb;
          aFunction(this);
          mapping = mapFn !== void 0;
          if (mapping)
            aFunction(mapFn);
          if (source == void 0)
            return new this();
          A = [];
          if (mapping) {
            n = 0;
            cb = ctx(mapFn, arguments[2], 2);
            forOf(source, false, function(nextItem) {
              A.push(cb(nextItem, n++));
            });
          } else {
            forOf(source, false, A.push, A);
          }
          return new this(A);
        } });
      };
    }
  });

  // node_modules/core-js/library/modules/es7.set.from.js
  var require_es7_set_from = __commonJS({
    "node_modules/core-js/library/modules/es7.set.from.js"() {
      require_set_collection_from()("Set");
    }
  });

  // node_modules/core-js/library/fn/set.js
  var require_set = __commonJS({
    "node_modules/core-js/library/fn/set.js"(exports, module) {
      require_es6_object_to_string();
      require_es6_string_iterator();
      require_web_dom_iterable();
      require_es6_set();
      require_es7_set_to_json();
      require_es7_set_of();
      require_es7_set_from();
      module.exports = require_core().Set;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/set.js
  var require_set2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/set.js"(exports, module) {
      module.exports = require_set();
    }
  });

  // node_modules/core-js/library/modules/core.get-iterator.js
  var require_core_get_iterator = __commonJS({
    "node_modules/core-js/library/modules/core.get-iterator.js"(exports, module) {
      var anObject = require_an_object();
      var get = require_core_get_iterator_method();
      module.exports = require_core().getIterator = function(it) {
        var iterFn = get(it);
        if (typeof iterFn != "function")
          throw TypeError(it + " is not iterable!");
        return anObject(iterFn.call(it));
      };
    }
  });

  // node_modules/core-js/library/fn/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/library/fn/get-iterator.js"(exports, module) {
      require_web_dom_iterable();
      require_es6_string_iterator();
      module.exports = require_core_get_iterator();
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/get-iterator.js
  var require_get_iterator2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/get-iterator.js"(exports, module) {
      module.exports = require_get_iterator();
    }
  });

  // node_modules/core-js/library/modules/_object-assign.js
  var require_object_assign = __commonJS({
    "node_modules/core-js/library/modules/_object-assign.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var getKeys = require_object_keys();
      var gOPS = require_object_gops();
      var pIE = require_object_pie();
      var toObject = require_to_object();
      var IObject = require_iobject();
      var $assign = Object.assign;
      module.exports = !$assign || require_fails()(function() {
        var A = {};
        var B = {};
        var S = Symbol();
        var K = "abcdefghijklmnopqrst";
        A[S] = 7;
        K.split("").forEach(function(k) {
          B[k] = k;
        });
        return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var aLen = arguments.length;
        var index = 1;
        var getSymbols = gOPS.f;
        var isEnum = pIE.f;
        while (aLen > index) {
          var S = IObject(arguments[index++]);
          var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || isEnum.call(S, key))
              T[key] = S[key];
          }
        }
        return T;
      } : $assign;
    }
  });

  // node_modules/core-js/library/modules/es6.object.assign.js
  var require_es6_object_assign = __commonJS({
    "node_modules/core-js/library/modules/es6.object.assign.js"() {
      var $export = require_export();
      $export($export.S + $export.F, "Object", { assign: require_object_assign() });
    }
  });

  // node_modules/core-js/library/fn/object/assign.js
  var require_assign = __commonJS({
    "node_modules/core-js/library/fn/object/assign.js"(exports, module) {
      require_es6_object_assign();
      module.exports = require_core().Object.assign;
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/object/assign.js
  var require_assign2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/object/assign.js"(exports, module) {
      module.exports = require_assign();
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/object/keys.js
  var require_keys2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/object/keys.js"(exports, module) {
      module.exports = require_keys();
    }
  });

  // node_modules/string-direction/index.js
  var require_string_direction = __commonJS({
    "node_modules/string-direction/index.js"(exports) {
      (function() {
        var LTR_MARK = "\u200E", RTL_MARK = "\u200F", LTR = "ltr", RTL = "rtl", BIDI = "bidi", NODI = "";
        var rtlSciriptRanges = {
          Hebrew: ["0590", "05FF"],
          Arabic: ["0600", "06FF"],
          NKo: ["07C0", "07FF"],
          Syriac: ["0700", "074F"],
          Thaana: ["0780", "07BF"],
          Tifinagh: ["2D30", "2D7F"]
        };
        function getDirection(string) {
          if (typeof string === "undefined")
            throw new Error("TypeError missing argument");
          if (typeof string !== "string")
            throw new Error("TypeError getDirection expects strings");
          if (string === "")
            return NODI;
          if (string.indexOf(LTR_MARK) > -1 && string.indexOf(RTL_MARK) > -1)
            return BIDI;
          if (string.indexOf(LTR_MARK) > -1)
            return LTR;
          if (string.indexOf(RTL_MARK) > -1)
            return RTL;
          var hasRtl = hasDirectionCharacters(string, RTL);
          var hasLtr = hasDirectionCharacters(string, LTR);
          if (hasRtl && hasLtr)
            return BIDI;
          if (hasLtr)
            return LTR;
          if (hasRtl)
            return RTL;
          return NODI;
        }
        function hasDirectionCharacters(string, direction) {
          var i, char, range, charIsRtl, hasRtl = false, hasLtr = false, hasDigit = false;
          hasDigit = string.search(/[0-9]/) > -1;
          string = string.replace(/[\s\n\0\f\t\v\'\"\-0-9\+\?\!]+/gm, "");
          for (i = 0; i < string.length; i++) {
            char = string.charAt(i);
            charIsRtl = false;
            for (range in rtlSciriptRanges) {
              if (rtlSciriptRanges.hasOwnProperty(range)) {
                if (isInScriptRange(
                  char,
                  rtlSciriptRanges[range][0],
                  rtlSciriptRanges[range][1]
                )) {
                  hasRtl = true;
                  charIsRtl = true;
                }
              }
            }
            if (charIsRtl === false) {
              hasLtr = true;
            }
          }
          if (direction === RTL)
            return hasRtl;
          if (direction === LTR)
            return hasLtr || !hasRtl && hasDigit;
        }
        function isInScriptRange(char, from, to) {
          var charCode = char.charCodeAt(0), fromCode = parseInt(from, 16), toCode = parseInt(to, 16);
          return charCode > fromCode && charCode < toCode;
        }
        function patchStringPrototype() {
          String.prototype.getDirection = function() {
            return getDirection(this.valueOf());
          };
        }
        if (typeof exports !== "undefined") {
          exports.getDirection = getDirection;
          exports.patch = patchStringPrototype;
        } else {
          this.stringDirection = {
            getDirection,
            patch: patchStringPrototype
          };
        }
      }).call(exports);
    }
  });

  // node_modules/valid-url/index.js
  var require_valid_url = __commonJS({
    "node_modules/valid-url/index.js"(exports, module) {
      (function(module2) {
        "use strict";
        module2.exports.is_uri = is_iri;
        module2.exports.is_http_uri = is_http_iri;
        module2.exports.is_https_uri = is_https_iri;
        module2.exports.is_web_uri = is_web_iri;
        module2.exports.isUri = is_iri;
        module2.exports.isHttpUri = is_http_iri;
        module2.exports.isHttpsUri = is_https_iri;
        module2.exports.isWebUri = is_web_iri;
        var splitUri = function(uri) {
          var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
          return splitted;
        };
        function is_iri(value) {
          if (!value) {
            return;
          }
          if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
            return;
          if (/%[^0-9a-f]/i.test(value))
            return;
          if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
            return;
          var splitted = [];
          var scheme = "";
          var authority = "";
          var path = "";
          var query = "";
          var fragment = "";
          var out = "";
          splitted = splitUri(value);
          scheme = splitted[1];
          authority = splitted[2];
          path = splitted[3];
          query = splitted[4];
          fragment = splitted[5];
          if (!(scheme && scheme.length && path.length >= 0))
            return;
          if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path)))
              return;
          } else {
            if (/^\/\//.test(path))
              return;
          }
          if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
            return;
          out += scheme + ":";
          if (authority && authority.length) {
            out += "//" + authority;
          }
          out += path;
          if (query && query.length) {
            out += "?" + query;
          }
          if (fragment && fragment.length) {
            out += "#" + fragment;
          }
          return out;
        }
        function is_http_iri(value, allowHttps) {
          if (!is_iri(value)) {
            return;
          }
          var splitted = [];
          var scheme = "";
          var authority = "";
          var path = "";
          var port = "";
          var query = "";
          var fragment = "";
          var out = "";
          splitted = splitUri(value);
          scheme = splitted[1];
          authority = splitted[2];
          path = splitted[3];
          query = splitted[4];
          fragment = splitted[5];
          if (!scheme)
            return;
          if (allowHttps) {
            if (scheme.toLowerCase() != "https")
              return;
          } else {
            if (scheme.toLowerCase() != "http")
              return;
          }
          if (!authority) {
            return;
          }
          if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, "");
          }
          out += scheme + ":";
          out += "//" + authority;
          if (port) {
            out += port;
          }
          out += path;
          if (query && query.length) {
            out += "?" + query;
          }
          if (fragment && fragment.length) {
            out += "#" + fragment;
          }
          return out;
        }
        function is_https_iri(value) {
          return is_http_iri(value, true);
        }
        function is_web_iri(value) {
          return is_http_iri(value) || is_https_iri(value);
        }
      })(module);
    }
  });

  // node_modules/@postlight/parser/node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/@postlight/parser/node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn) {
          var res = [], i, arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key, argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now2) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now2) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                value,
                mom.month(),
                daysInMonth(value, mom.month())
              );
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(
            s.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i, func = callback, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token2[i]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return name.match("^[^/\\\\]*$") != null;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i = 0; i < tokenLen; i++) {
            token2 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property, propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now2) {
          var diff2 = myMoment.diff(now2, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now2))
          );
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token2) {
            var era = config._locale.erasParse(input, token2, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format2, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format2, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.29.4";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // node_modules/@postlight/parser/node_modules/moment-timezone/builds/moment-timezone-with-data-2012-2022.min.js
  var require_moment_timezone_with_data_2012_2022_min = __commonJS({
    "node_modules/@postlight/parser/node_modules/moment-timezone/builds/moment-timezone-with-data-2012-2022.min.js"(exports, module) {
      !function(a, i) {
        "use strict";
        "object" == typeof module && module.exports ? module.exports = i(require_moment()) : "function" == typeof define && define.amd ? define(["moment"], i) : i(a.moment);
      }(exports, function(o) {
        "use strict";
        void 0 === o.version && o.default && (o = o.default);
        var i, A = {}, n = {}, t = {}, s = {}, u = {};
        o && "string" == typeof o.version || N("Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/");
        var a = o.version.split("."), e = +a[0], r = +a[1];
        function m(a2) {
          return 96 < a2 ? a2 - 87 : 64 < a2 ? a2 - 29 : a2 - 48;
        }
        function c(a2) {
          var i2 = 0, e2 = a2.split("."), r2 = e2[0], c2 = e2[1] || "", o2 = 1, A2 = 0, n2 = 1;
          for (45 === a2.charCodeAt(0) && (n2 = -(i2 = 1)); i2 < r2.length; i2++)
            A2 = 60 * A2 + m(r2.charCodeAt(i2));
          for (i2 = 0; i2 < c2.length; i2++)
            o2 /= 60, A2 += m(c2.charCodeAt(i2)) * o2;
          return A2 * n2;
        }
        function f(a2) {
          for (var i2 = 0; i2 < a2.length; i2++)
            a2[i2] = c(a2[i2]);
        }
        function l(a2, i2) {
          var e2, r2 = [];
          for (e2 = 0; e2 < i2.length; e2++)
            r2[e2] = a2[i2[e2]];
          return r2;
        }
        function p(a2) {
          var i2 = a2.split("|"), e2 = i2[2].split(" "), r2 = i2[3].split(""), c2 = i2[4].split(" ");
          return f(e2), f(r2), f(c2), function(a3, i3) {
            for (var e3 = 0; e3 < i3; e3++)
              a3[e3] = Math.round((a3[e3 - 1] || 0) + 6e4 * a3[e3]);
            a3[i3 - 1] = 1 / 0;
          }(c2, r2.length), { name: i2[0], abbrs: l(i2[1].split(" "), r2), offsets: l(e2, r2), untils: c2, population: 0 | i2[5] };
        }
        function M(a2) {
          a2 && this._set(p(a2));
        }
        function b(a2, i2) {
          this.name = a2, this.zones = i2;
        }
        function d(a2) {
          var i2 = a2.toTimeString(), e2 = i2.match(/\([a-z ]+\)/i);
          "GMT" === (e2 = e2 && e2[0] ? (e2 = e2[0].match(/[A-Z]/g)) ? e2.join("") : void 0 : (e2 = i2.match(/[A-Z]{3,5}/g)) ? e2[0] : void 0) && (e2 = void 0), this.at = +a2, this.abbr = e2, this.offset = a2.getTimezoneOffset();
        }
        function h(a2) {
          this.zone = a2, this.offsetScore = 0, this.abbrScore = 0;
        }
        function E(a2, i2) {
          for (var e2, r2; r2 = 6e4 * ((i2.at - a2.at) / 12e4 | 0); )
            (e2 = new d(new Date(a2.at + r2))).offset === a2.offset ? a2 = e2 : i2 = e2;
          return a2;
        }
        function g(a2, i2) {
          return a2.offsetScore !== i2.offsetScore ? a2.offsetScore - i2.offsetScore : a2.abbrScore !== i2.abbrScore ? a2.abbrScore - i2.abbrScore : a2.zone.population !== i2.zone.population ? i2.zone.population - a2.zone.population : i2.zone.name.localeCompare(a2.zone.name);
        }
        function P(a2, i2) {
          var e2, r2;
          for (f(i2), e2 = 0; e2 < i2.length; e2++)
            r2 = i2[e2], u[r2] = u[r2] || {}, u[r2][a2] = true;
        }
        function z() {
          try {
            var a2 = Intl.DateTimeFormat().resolvedOptions().timeZone;
            if (a2 && 3 < a2.length) {
              var i2 = s[T(a2)];
              if (i2)
                return i2;
              N("Moment Timezone found " + a2 + " from the Intl api, but did not have that data loaded.");
            }
          } catch (a3) {
          }
          var e2, r2, c2, o2 = function() {
            var a3, i3, e3, r3 = (/* @__PURE__ */ new Date()).getFullYear() - 2, c3 = new d(new Date(r3, 0, 1)), o3 = [c3];
            for (e3 = 1; e3 < 48; e3++)
              (i3 = new d(new Date(r3, e3, 1))).offset !== c3.offset && (a3 = E(c3, i3), o3.push(a3), o3.push(new d(new Date(a3.at + 6e4)))), c3 = i3;
            for (e3 = 0; e3 < 4; e3++)
              o3.push(new d(new Date(r3 + e3, 0, 1))), o3.push(new d(new Date(r3 + e3, 6, 1)));
            return o3;
          }(), A2 = o2.length, n2 = function(a3) {
            var i3, e3, r3, c3 = a3.length, o3 = {}, A3 = [];
            for (i3 = 0; i3 < c3; i3++)
              for (e3 in r3 = u[a3[i3].offset] || {})
                r3.hasOwnProperty(e3) && (o3[e3] = true);
            for (i3 in o3)
              o3.hasOwnProperty(i3) && A3.push(s[i3]);
            return A3;
          }(o2), t2 = [];
          for (r2 = 0; r2 < n2.length; r2++) {
            for (e2 = new h(S(n2[r2]), A2), c2 = 0; c2 < A2; c2++)
              e2.scoreOffsetAt(o2[c2]);
            t2.push(e2);
          }
          return t2.sort(g), 0 < t2.length ? t2[0].zone.name : void 0;
        }
        function T(a2) {
          return (a2 || "").toLowerCase().replace(/\//g, "_");
        }
        function _(a2) {
          var i2, e2, r2, c2;
          for ("string" == typeof a2 && (a2 = [a2]), i2 = 0; i2 < a2.length; i2++)
            c2 = T(e2 = (r2 = a2[i2].split("|"))[0]), A[c2] = a2[i2], s[c2] = e2, P(c2, r2[2].split(" "));
        }
        function S(a2, i2) {
          a2 = T(a2);
          var e2, r2 = A[a2];
          return r2 instanceof M ? r2 : "string" == typeof r2 ? (r2 = new M(r2), A[a2] = r2) : n[a2] && i2 !== S && (e2 = S(n[a2], S)) ? ((r2 = A[a2] = new M())._set(e2), r2.name = s[a2], r2) : null;
        }
        function k(a2) {
          var i2, e2, r2, c2;
          for ("string" == typeof a2 && (a2 = [a2]), i2 = 0; i2 < a2.length; i2++)
            r2 = T((e2 = a2[i2].split("|"))[0]), c2 = T(e2[1]), n[r2] = c2, s[r2] = e2[0], n[c2] = r2, s[c2] = e2[1];
        }
        function C(a2) {
          _(a2.zones), k(a2.links), function(a3) {
            var i2, e2, r2, c2;
            if (a3 && a3.length)
              for (i2 = 0; i2 < a3.length; i2++)
                e2 = (c2 = a3[i2].split("|"))[0].toUpperCase(), r2 = c2[1].split(" "), t[e2] = new b(e2, r2);
          }(a2.countries), G.dataVersion = a2.version;
        }
        function B(a2) {
          var i2 = "X" === a2._f || "x" === a2._f;
          return !(!a2._a || void 0 !== a2._tzm || i2);
        }
        function N(a2) {
          "undefined" != typeof console && "function" == typeof console.error && console.error(a2);
        }
        function G(a2) {
          var i2 = Array.prototype.slice.call(arguments, 0, -1), e2 = arguments[arguments.length - 1], r2 = S(e2), c2 = o.utc.apply(null, i2);
          return r2 && !o.isMoment(a2) && B(c2) && c2.add(r2.parse(c2), "minutes"), c2.tz(e2), c2;
        }
        (e < 2 || 2 == e && r < 6) && N("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js " + o.version + ". See momentjs.com"), M.prototype = { _set: function(a2) {
          this.name = a2.name, this.abbrs = a2.abbrs, this.untils = a2.untils, this.offsets = a2.offsets, this.population = a2.population;
        }, _index: function(a2) {
          var i2, e2 = +a2, r2 = this.untils;
          for (i2 = 0; i2 < r2.length; i2++)
            if (e2 < r2[i2])
              return i2;
        }, countries: function() {
          var i2 = this.name;
          return Object.keys(t).filter(function(a2) {
            return -1 !== t[a2].zones.indexOf(i2);
          });
        }, parse: function(a2) {
          var i2, e2, r2, c2, o2 = +a2, A2 = this.offsets, n2 = this.untils, t2 = n2.length - 1;
          for (c2 = 0; c2 < t2; c2++)
            if (i2 = A2[c2], e2 = A2[c2 + 1], r2 = A2[c2 ? c2 - 1 : c2], i2 < e2 && G.moveAmbiguousForward ? i2 = e2 : r2 < i2 && G.moveInvalidForward && (i2 = r2), o2 < n2[c2] - 6e4 * i2)
              return A2[c2];
          return A2[t2];
        }, abbr: function(a2) {
          return this.abbrs[this._index(a2)];
        }, offset: function(a2) {
          return N("zone.offset has been deprecated in favor of zone.utcOffset"), this.offsets[this._index(a2)];
        }, utcOffset: function(a2) {
          return this.offsets[this._index(a2)];
        } }, h.prototype.scoreOffsetAt = function(a2) {
          this.offsetScore += Math.abs(this.zone.utcOffset(a2.at) - a2.offset), this.zone.abbr(a2.at).replace(/[^A-Z]/g, "") !== a2.abbr && this.abbrScore++;
        }, G.version = "0.5.36", G.dataVersion = "", G._zones = A, G._links = n, G._names = s, G._countries = t, G.add = _, G.link = k, G.load = C, G.zone = S, G.zoneExists = function a2(i2) {
          return a2.didShowError || (a2.didShowError = true, N("moment.tz.zoneExists('" + i2 + "') has been deprecated in favor of !moment.tz.zone('" + i2 + "')")), !!S(i2);
        }, G.guess = function(a2) {
          return i && !a2 || (i = z()), i;
        }, G.names = function() {
          var a2, i2 = [];
          for (a2 in s)
            s.hasOwnProperty(a2) && (A[a2] || A[n[a2]]) && s[a2] && i2.push(s[a2]);
          return i2.sort();
        }, G.Zone = M, G.unpack = p, G.unpackBase60 = c, G.needsOffset = B, G.moveInvalidForward = true, G.moveAmbiguousForward = false, G.countries = function() {
          return Object.keys(t);
        }, G.zonesForCountry = function(a2, i2) {
          if (!(a2 = function(a3) {
            return a3 = a3.toUpperCase(), t[a3] || null;
          }(a2)))
            return null;
          var e2 = a2.zones.sort();
          return i2 ? e2.map(function(a3) {
            return { name: a3, offset: S(a3).utcOffset(/* @__PURE__ */ new Date()) };
          }) : e2;
        };
        var y, L = o.fn;
        function D(a2) {
          return function() {
            return this._z ? this._z.abbr(this) : a2.call(this);
          };
        }
        function O(a2) {
          return function() {
            return this._z = null, a2.apply(this, arguments);
          };
        }
        o.tz = G, o.defaultZone = null, o.updateOffset = function(a2, i2) {
          var e2, r2 = o.defaultZone;
          if (void 0 === a2._z && (r2 && B(a2) && !a2._isUTC && (a2._d = o.utc(a2._a)._d, a2.utc().add(r2.parse(a2), "minutes")), a2._z = r2), a2._z)
            if (e2 = a2._z.utcOffset(a2), Math.abs(e2) < 16 && (e2 /= 60), void 0 !== a2.utcOffset) {
              var c2 = a2._z;
              a2.utcOffset(-e2, i2), a2._z = c2;
            } else
              a2.zone(e2, i2);
        }, L.tz = function(a2, i2) {
          if (a2) {
            if ("string" != typeof a2)
              throw new Error("Time zone name must be a string, got " + a2 + " [" + typeof a2 + "]");
            return this._z = S(a2), this._z ? o.updateOffset(this, i2) : N("Moment Timezone has no data for " + a2 + ". See http://momentjs.com/timezone/docs/#/data-loading/."), this;
          }
          if (this._z)
            return this._z.name;
        }, L.zoneName = D(L.zoneName), L.zoneAbbr = D(L.zoneAbbr), L.utc = O(L.utc), L.local = O(L.local), L.utcOffset = (y = L.utcOffset, function() {
          return 0 < arguments.length && (this._z = null), y.apply(this, arguments);
        }), o.tz.setDefault = function(a2) {
          return (e < 2 || 2 == e && r < 9) && N("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js " + o.version + "."), o.defaultZone = a2 ? S(a2) : null, o;
        };
        var v = o.momentProperties;
        return "[object Array]" === Object.prototype.toString.call(v) ? (v.push("_z"), v.push("_a")) : v && (v._z = null), C({ version: "2022c", zones: ["Africa/Abidjan|GMT|0|0||48e5", "Africa/Nairobi|EAT|-30|0||47e5", "Africa/Algiers|CET|-10|0||26e5", "Africa/Lagos|WAT|-10|0||17e6", "Africa/Maputo|CAT|-20|0||26e5", "Africa/Cairo|EET EEST|-20 -30|01010|1M2m0 gL0 e10 mn0|15e6", "Africa/Casablanca|+00 +01|0 -10|010101010101010101010101010101010101|1H3C0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0|32e5", "Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|11e6", "Africa/Johannesburg|SAST|-20|0||84e5", "Africa/Juba|EAT CAT|-30 -20|01|24nx0|", "Africa/Khartoum|EAT CAT|-30 -20|01|1Usl0|51e5", "Africa/Sao_Tome|GMT WAT|0 -10|010|1UQN0 2q00|", "Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5", "Africa/Windhoek|CAT WAT|-20 -10|0101010101010|1GQo0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0|32e4", "America/Adak|HST HDT|a0 90|01010101010101010101010|1GIc0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|326", "America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1GIb0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|30e4", "America/Santo_Domingo|AST|40|0||29e5", "America/Araguaina|-03 -02|30 20|010|1IdD0 Lz0|14e4", "America/Fortaleza|-03|30|0||34e5", "America/Asuncion|-03 -04|30 40|01010101010101010101010|1GTf0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0|28e5", "America/Panama|EST|50|0||15e5", "America/Mexico_City|CST CDT|60 50|01010101010101010101010|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|20e6", "America/Bahia|-02 -03|20 30|01|1GCq0|27e5", "America/Managua|CST|60|0||22e5", "America/La_Paz|-04|40|0||19e5", "America/Lima|-05|50|0||11e6", "America/Denver|MST MDT|70 60|01010101010101010101010|1GI90 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|26e5", "America/Campo_Grande|-03 -04|30 40|0101010101010101|1GCr0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4", "America/Cancun|CST CDT EST|60 50 50|01010102|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4", "America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5", "America/Chicago|CST CDT|60 50|01010101010101010101010|1GI80 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|92e5", "America/Chihuahua|MST MDT|70 60|01010101010101010101010|1GQx0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|81e4", "America/Phoenix|MST|70|0||42e5", "America/Whitehorse|PST PDT MST|80 70 70|0101010101010101012|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1z90|23e3", "America/New_York|EST EDT|50 40|01010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|21e6", "America/Rio_Branco|-04 -05|40 50|01|1KLE0|31e4", "America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|15e6", "America/Fort_Nelson|PST PDT MST|80 70 70|01010102|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2", "America/Halifax|AST ADT|40 30|01010101010101010101010|1GI60 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|39e4", "America/Godthab|-03 -02|30 20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|17e3", "America/Grand_Turk|EST EDT AST|50 40 40|010101021010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 7jA0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|37e2", "America/Havana|CST CDT|50 40|01010101010101010101010|1GQt0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0|21e5", "America/Metlakatla|PST AKST AKDT|80 90 80|01212120121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|14e2", "America/Miquelon|-03 -02|30 20|01010101010101010101010|1GI50 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|61e2", "America/Montevideo|-02 -03|20 30|01010101|1GI40 1o10 11z0 1o10 11z0 1o10 11z0|17e5", "America/Noronha|-02|20|0||30e2", "America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|23e5", "Antarctica/Palmer|-03 -04|30 40|010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40", "America/Santiago|-03 -04|30 40|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0|62e5", "America/Sao_Paulo|-02 -03|20 30|0101010101010101|1GCq0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6", "Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e4", "America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1GI5u 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|11e4", "Antarctica/Casey|+11 +08|-b0 -80|010101010|1GAF0 blz0 3m10 1o30 14k0 1kr0 12l0 1o01|10", "Antarctica/Davis|+05 +07|-50 -70|01|1GAI0|70", "Pacific/Port_Moresby|+10|-a0|0||25e4", "Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1GQg0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|40e5", "Asia/Tashkent|+05|-50|0||23e5", "Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|14e5", "Asia/Baghdad|+03|-30|0||66e5", "Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|40", "Asia/Dhaka|+06|-60|0||16e6", "Asia/Amman|EET EEST|-20 -30|010101010101010101010|1GPy0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 LA0 1C00|25e5", "Asia/Kamchatka|+12|-c0|0||18e4", "Asia/Baku|+04 +05|-40 -50|010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5", "Asia/Bangkok|+07|-70|0||15e6", "Asia/Barnaul|+07 +06|-70 -60|010|1N7v0 3rd0|", "Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1GNy0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|22e5", "Asia/Kuala_Lumpur|+08|-80|0||71e5", "Asia/Kolkata|IST|-5u|0||15e6", "Asia/Chita|+10 +08 +09|-a0 -80 -90|012|1N7s0 3re0|33e4", "Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5", "Asia/Shanghai|CST|-80|0||23e6", "Asia/Colombo|+0530|-5u|0||22e5", "Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1GPy0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|26e5", "Asia/Dili|+09|-90|0||19e4", "Asia/Dubai|+04|-40|0||39e5", "Asia/Famagusta|EET EEST +03|-20 -30 -30|0101010101201010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|", "Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1GPy0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nA0 1210 1qL0 WN0 1qL0 WN0 1qL0 11c0 1on0 11B0 1o00 11A0 1qo0 XA0 1q00|18e5", "Asia/Hong_Kong|HKT|-80|0||73e5", "Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3", "Asia/Irkutsk|+09 +08|-90 -80|01|1N7t0|60e4", "Europe/Istanbul|EET EEST +03|-20 -30 -30|01010101012|1GNB0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6", "Asia/Jakarta|WIB|-70|0||31e6", "Asia/Jayapura|WIT|-90|0||26e4", "Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1GPA0 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0|81e4", "Asia/Kabul|+0430|-4u|0||46e5", "Asia/Karachi|PKT|-50|0||24e6", "Asia/Kathmandu|+0545|-5J|0||12e5", "Asia/Yakutsk|+10 +09|-a0 -90|01|1N7s0|28e4", "Asia/Krasnoyarsk|+08 +07|-80 -70|01|1N7u0|10e5", "Asia/Magadan|+12 +10 +11|-c0 -a0 -b0|012|1N7q0 3Cq0|95e3", "Asia/Makassar|WITA|-80|0||15e5", "Asia/Manila|PST|-80|0||24e6", "Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|35e5", "Asia/Novosibirsk|+07 +06|-70 -60|010|1N7v0 4eN0|15e5", "Asia/Omsk|+07 +06|-70 -60|01|1N7v0|12e5", "Asia/Pyongyang|KST KST|-90 -8u|010|1P4D0 6BA0|29e5", "Asia/Qyzylorda|+06 +05|-60 -50|01|1Xei0|73e4", "Asia/Rangoon|+0630|-6u|0||48e5", "Asia/Sakhalin|+11 +10|-b0 -a0|010|1N7r0 3rd0|58e4", "Asia/Seoul|KST|-90|0||23e6", "Asia/Srednekolymsk|+12 +11|-c0 -b0|01|1N7q0|35e2", "Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1GLUu 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0|14e6", "Asia/Tokyo|JST|-90|0||38e6", "Asia/Tomsk|+07 +06|-70 -60|010|1N7v0 3Qp0|10e5", "Asia/Vladivostok|+11 +10|-b0 -a0|01|1N7r0|60e4", "Asia/Yekaterinburg|+06 +05|-60 -50|01|1N7w0|14e5", "Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|27e5", "Atlantic/Cape_Verde|-01|10|0||50e4", "Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1GQgu 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|11e5", "Australia/Brisbane|AEST|-a0|0||20e5", "Australia/Darwin|ACST|-9u|0||12e4", "Australia/Eucla|+0845|-8J|0||368", "Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1GQf0 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu|347", "Australia/Perth|AWST|-80|0||18e5", "Pacific/Easter|-05 -06|50 60|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0|30e2", "Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|12e5", "Etc/GMT-1|+01|-10|0||", "Pacific/Guadalcanal|+11|-b0|0||11e4", "Pacific/Fakaofo|+13|-d0|0||483", "Pacific/Kiritimati|+14|-e0|0||51e2", "Etc/GMT-2|+02|-20|0||", "Pacific/Tahiti|-10|a0|0||18e4", "Pacific/Niue|-11|b0|0||12e2", "Etc/GMT+12|-12|c0|0||", "Pacific/Galapagos|-06|60|0||25e3", "Etc/GMT+7|-07|70|0||", "Pacific/Pitcairn|-08|80|0||56", "Pacific/Gambier|-09|90|0||125", "Etc/UTC|UTC|0|0||", "Europe/Ulyanovsk|+04 +03|-40 -30|010|1N7y0 3rd0|13e5", "Europe/London|GMT BST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|10e6", "Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|67e4", "Europe/Kaliningrad|+03 EET|-30 -20|01|1N7z0|44e4", "Europe/Kirov|+04 +03|-40 -30|01|1N7y0|48e4", "Europe/Moscow|MSK MSK|-40 -30|01|1N7y0|16e6", "Europe/Saratov|+04 +03|-40 -30|010|1N7y0 5810|", "Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|0101023|1GNB0 1qM0 11A0 1o00 11z0 1nW0|33e4", "Europe/Volgograd|+04 +03|-40 -30|0101|1N7y0 9Jd0 5gn0|10e5", "Pacific/Honolulu|HST|a0|0||37e4", "MET|MET MEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|", "Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|600", "Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0|37e3", "Pacific/Bougainville|+10 +11|-a0 -b0|01|1NwE0|18e4", "Pacific/Fiji|+13 +12|-d0 -c0|010101010101010101010|1Goe0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 20o0 pc0 2hc0 bc0 4q00|88e4", "Pacific/Guam|ChST|-a0|0||17e4", "Pacific/Marquesas|-0930|9u|0||86e2", "Pacific/Pago_Pago|SST|b0|0||37e2", "Pacific/Norfolk|+1130 +11 +12|-bu -b0 -c0|012121212|1PoCu 9Jcu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|25e4", "Pacific/Tongatapu|+13 +14|-d0 -e0|010|1S4d0 s00|75e3"], links: ["Africa/Abidjan|Africa/Accra", "Africa/Abidjan|Africa/Bamako", "Africa/Abidjan|Africa/Banjul", "Africa/Abidjan|Africa/Bissau", "Africa/Abidjan|Africa/Conakry", "Africa/Abidjan|Africa/Dakar", "Africa/Abidjan|Africa/Freetown", "Africa/Abidjan|Africa/Lome", "Africa/Abidjan|Africa/Monrovia", "Africa/Abidjan|Africa/Nouakchott", "Africa/Abidjan|Africa/Ouagadougou", "Africa/Abidjan|Africa/Timbuktu", "Africa/Abidjan|America/Danmarkshavn", "Africa/Abidjan|Atlantic/Reykjavik", "Africa/Abidjan|Atlantic/St_Helena", "Africa/Abidjan|Etc/GMT", "Africa/Abidjan|Etc/GMT+0", "Africa/Abidjan|Etc/GMT-0", "Africa/Abidjan|Etc/GMT0", "Africa/Abidjan|Etc/Greenwich", "Africa/Abidjan|GMT", "Africa/Abidjan|GMT+0", "Africa/Abidjan|GMT-0", "Africa/Abidjan|GMT0", "Africa/Abidjan|Greenwich", "Africa/Abidjan|Iceland", "Africa/Algiers|Africa/Tunis", "Africa/Cairo|Egypt", "Africa/Casablanca|Africa/El_Aaiun", "Africa/Johannesburg|Africa/Maseru", "Africa/Johannesburg|Africa/Mbabane", "Africa/Lagos|Africa/Bangui", "Africa/Lagos|Africa/Brazzaville", "Africa/Lagos|Africa/Douala", "Africa/Lagos|Africa/Kinshasa", "Africa/Lagos|Africa/Libreville", "Africa/Lagos|Africa/Luanda", "Africa/Lagos|Africa/Malabo", "Africa/Lagos|Africa/Ndjamena", "Africa/Lagos|Africa/Niamey", "Africa/Lagos|Africa/Porto-Novo", "Africa/Maputo|Africa/Blantyre", "Africa/Maputo|Africa/Bujumbura", "Africa/Maputo|Africa/Gaborone", "Africa/Maputo|Africa/Harare", "Africa/Maputo|Africa/Kigali", "Africa/Maputo|Africa/Lubumbashi", "Africa/Maputo|Africa/Lusaka", "Africa/Nairobi|Africa/Addis_Ababa", "Africa/Nairobi|Africa/Asmara", "Africa/Nairobi|Africa/Asmera", "Africa/Nairobi|Africa/Dar_es_Salaam", "Africa/Nairobi|Africa/Djibouti", "Africa/Nairobi|Africa/Kampala", "Africa/Nairobi|Africa/Mogadishu", "Africa/Nairobi|Indian/Antananarivo", "Africa/Nairobi|Indian/Comoro", "Africa/Nairobi|Indian/Mayotte", "Africa/Tripoli|Libya", "America/Adak|America/Atka", "America/Adak|US/Aleutian", "America/Anchorage|America/Juneau", "America/Anchorage|America/Nome", "America/Anchorage|America/Sitka", "America/Anchorage|America/Yakutat", "America/Anchorage|US/Alaska", "America/Campo_Grande|America/Cuiaba", "America/Chicago|America/Indiana/Knox", "America/Chicago|America/Indiana/Tell_City", "America/Chicago|America/Knox_IN", "America/Chicago|America/Matamoros", "America/Chicago|America/Menominee", "America/Chicago|America/North_Dakota/Beulah", "America/Chicago|America/North_Dakota/Center", "America/Chicago|America/North_Dakota/New_Salem", "America/Chicago|America/Rainy_River", "America/Chicago|America/Rankin_Inlet", "America/Chicago|America/Resolute", "America/Chicago|America/Winnipeg", "America/Chicago|CST6CDT", "America/Chicago|Canada/Central", "America/Chicago|US/Central", "America/Chicago|US/Indiana-Starke", "America/Chihuahua|America/Mazatlan", "America/Chihuahua|Mexico/BajaSur", "America/Denver|America/Boise", "America/Denver|America/Cambridge_Bay", "America/Denver|America/Edmonton", "America/Denver|America/Inuvik", "America/Denver|America/Ojinaga", "America/Denver|America/Shiprock", "America/Denver|America/Yellowknife", "America/Denver|Canada/Mountain", "America/Denver|MST7MDT", "America/Denver|Navajo", "America/Denver|US/Mountain", "America/Fortaleza|America/Argentina/Buenos_Aires", "America/Fortaleza|America/Argentina/Catamarca", "America/Fortaleza|America/Argentina/ComodRivadavia", "America/Fortaleza|America/Argentina/Cordoba", "America/Fortaleza|America/Argentina/Jujuy", "America/Fortaleza|America/Argentina/La_Rioja", "America/Fortaleza|America/Argentina/Mendoza", "America/Fortaleza|America/Argentina/Rio_Gallegos", "America/Fortaleza|America/Argentina/Salta", "America/Fortaleza|America/Argentina/San_Juan", "America/Fortaleza|America/Argentina/San_Luis", "America/Fortaleza|America/Argentina/Tucuman", "America/Fortaleza|America/Argentina/Ushuaia", "America/Fortaleza|America/Belem", "America/Fortaleza|America/Buenos_Aires", "America/Fortaleza|America/Catamarca", "America/Fortaleza|America/Cayenne", "America/Fortaleza|America/Cordoba", "America/Fortaleza|America/Jujuy", "America/Fortaleza|America/Maceio", "America/Fortaleza|America/Mendoza", "America/Fortaleza|America/Paramaribo", "America/Fortaleza|America/Recife", "America/Fortaleza|America/Rosario", "America/Fortaleza|America/Santarem", "America/Fortaleza|Antarctica/Rothera", "America/Fortaleza|Atlantic/Stanley", "America/Fortaleza|Etc/GMT+3", "America/Godthab|America/Nuuk", "America/Halifax|America/Glace_Bay", "America/Halifax|America/Goose_Bay", "America/Halifax|America/Moncton", "America/Halifax|America/Thule", "America/Halifax|Atlantic/Bermuda", "America/Halifax|Canada/Atlantic", "America/Havana|Cuba", "America/La_Paz|America/Boa_Vista", "America/La_Paz|America/Guyana", "America/La_Paz|America/Manaus", "America/La_Paz|America/Porto_Velho", "America/La_Paz|Brazil/West", "America/La_Paz|Etc/GMT+4", "America/Lima|America/Bogota", "America/Lima|America/Guayaquil", "America/Lima|Etc/GMT+5", "America/Los_Angeles|America/Ensenada", "America/Los_Angeles|America/Santa_Isabel", "America/Los_Angeles|America/Tijuana", "America/Los_Angeles|America/Vancouver", "America/Los_Angeles|Canada/Pacific", "America/Los_Angeles|Mexico/BajaNorte", "America/Los_Angeles|PST8PDT", "America/Los_Angeles|US/Pacific", "America/Managua|America/Belize", "America/Managua|America/Costa_Rica", "America/Managua|America/El_Salvador", "America/Managua|America/Guatemala", "America/Managua|America/Regina", "America/Managua|America/Swift_Current", "America/Managua|America/Tegucigalpa", "America/Managua|Canada/Saskatchewan", "America/Mexico_City|America/Bahia_Banderas", "America/Mexico_City|America/Merida", "America/Mexico_City|America/Monterrey", "America/Mexico_City|Mexico/General", "America/New_York|America/Detroit", "America/New_York|America/Fort_Wayne", "America/New_York|America/Indiana/Indianapolis", "America/New_York|America/Indiana/Marengo", "America/New_York|America/Indiana/Petersburg", "America/New_York|America/Indiana/Vevay", "America/New_York|America/Indiana/Vincennes", "America/New_York|America/Indiana/Winamac", "America/New_York|America/Indianapolis", "America/New_York|America/Iqaluit", "America/New_York|America/Kentucky/Louisville", "America/New_York|America/Kentucky/Monticello", "America/New_York|America/Louisville", "America/New_York|America/Montreal", "America/New_York|America/Nassau", "America/New_York|America/Nipigon", "America/New_York|America/Pangnirtung", "America/New_York|America/Thunder_Bay", "America/New_York|America/Toronto", "America/New_York|Canada/Eastern", "America/New_York|EST5EDT", "America/New_York|US/East-Indiana", "America/New_York|US/Eastern", "America/New_York|US/Michigan", "America/Noronha|Atlantic/South_Georgia", "America/Noronha|Brazil/DeNoronha", "America/Noronha|Etc/GMT+2", "America/Panama|America/Atikokan", "America/Panama|America/Cayman", "America/Panama|America/Coral_Harbour", "America/Panama|America/Jamaica", "America/Panama|EST", "America/Panama|Jamaica", "America/Phoenix|America/Creston", "America/Phoenix|America/Dawson_Creek", "America/Phoenix|America/Hermosillo", "America/Phoenix|MST", "America/Phoenix|US/Arizona", "America/Rio_Branco|America/Eirunepe", "America/Rio_Branco|America/Porto_Acre", "America/Rio_Branco|Brazil/Acre", "America/Santiago|Chile/Continental", "America/Santo_Domingo|America/Anguilla", "America/Santo_Domingo|America/Antigua", "America/Santo_Domingo|America/Aruba", "America/Santo_Domingo|America/Barbados", "America/Santo_Domingo|America/Blanc-Sablon", "America/Santo_Domingo|America/Curacao", "America/Santo_Domingo|America/Dominica", "America/Santo_Domingo|America/Grenada", "America/Santo_Domingo|America/Guadeloupe", "America/Santo_Domingo|America/Kralendijk", "America/Santo_Domingo|America/Lower_Princes", "America/Santo_Domingo|America/Marigot", "America/Santo_Domingo|America/Martinique", "America/Santo_Domingo|America/Montserrat", "America/Santo_Domingo|America/Port_of_Spain", "America/Santo_Domingo|America/Puerto_Rico", "America/Santo_Domingo|America/St_Barthelemy", "America/Santo_Domingo|America/St_Kitts", "America/Santo_Domingo|America/St_Lucia", "America/Santo_Domingo|America/St_Thomas", "America/Santo_Domingo|America/St_Vincent", "America/Santo_Domingo|America/Tortola", "America/Santo_Domingo|America/Virgin", "America/Sao_Paulo|Brazil/East", "America/St_Johns|Canada/Newfoundland", "America/Whitehorse|America/Dawson", "America/Whitehorse|Canada/Yukon", "Antarctica/Palmer|America/Punta_Arenas", "Asia/Baghdad|Antarctica/Syowa", "Asia/Baghdad|Asia/Aden", "Asia/Baghdad|Asia/Bahrain", "Asia/Baghdad|Asia/Kuwait", "Asia/Baghdad|Asia/Qatar", "Asia/Baghdad|Asia/Riyadh", "Asia/Baghdad|Etc/GMT-3", "Asia/Baghdad|Europe/Minsk", "Asia/Bangkok|Asia/Ho_Chi_Minh", "Asia/Bangkok|Asia/Novokuznetsk", "Asia/Bangkok|Asia/Phnom_Penh", "Asia/Bangkok|Asia/Saigon", "Asia/Bangkok|Asia/Vientiane", "Asia/Bangkok|Etc/GMT-7", "Asia/Bangkok|Indian/Christmas", "Asia/Dhaka|Antarctica/Vostok", "Asia/Dhaka|Asia/Almaty", "Asia/Dhaka|Asia/Bishkek", "Asia/Dhaka|Asia/Dacca", "Asia/Dhaka|Asia/Kashgar", "Asia/Dhaka|Asia/Qostanay", "Asia/Dhaka|Asia/Thimbu", "Asia/Dhaka|Asia/Thimphu", "Asia/Dhaka|Asia/Urumqi", "Asia/Dhaka|Etc/GMT-6", "Asia/Dhaka|Indian/Chagos", "Asia/Dili|Etc/GMT-9", "Asia/Dili|Pacific/Palau", "Asia/Dubai|Asia/Muscat", "Asia/Dubai|Asia/Tbilisi", "Asia/Dubai|Asia/Yerevan", "Asia/Dubai|Etc/GMT-4", "Asia/Dubai|Europe/Samara", "Asia/Dubai|Indian/Mahe", "Asia/Dubai|Indian/Mauritius", "Asia/Dubai|Indian/Reunion", "Asia/Gaza|Asia/Hebron", "Asia/Hong_Kong|Hongkong", "Asia/Jakarta|Asia/Pontianak", "Asia/Jerusalem|Asia/Tel_Aviv", "Asia/Jerusalem|Israel", "Asia/Kamchatka|Asia/Anadyr", "Asia/Kamchatka|Etc/GMT-12", "Asia/Kamchatka|Kwajalein", "Asia/Kamchatka|Pacific/Funafuti", "Asia/Kamchatka|Pacific/Kwajalein", "Asia/Kamchatka|Pacific/Majuro", "Asia/Kamchatka|Pacific/Nauru", "Asia/Kamchatka|Pacific/Tarawa", "Asia/Kamchatka|Pacific/Wake", "Asia/Kamchatka|Pacific/Wallis", "Asia/Kathmandu|Asia/Katmandu", "Asia/Kolkata|Asia/Calcutta", "Asia/Kuala_Lumpur|Asia/Brunei", "Asia/Kuala_Lumpur|Asia/Kuching", "Asia/Kuala_Lumpur|Asia/Singapore", "Asia/Kuala_Lumpur|Etc/GMT-8", "Asia/Kuala_Lumpur|Singapore", "Asia/Makassar|Asia/Ujung_Pandang", "Asia/Rangoon|Asia/Yangon", "Asia/Rangoon|Indian/Cocos", "Asia/Seoul|ROK", "Asia/Shanghai|Asia/Chongqing", "Asia/Shanghai|Asia/Chungking", "Asia/Shanghai|Asia/Harbin", "Asia/Shanghai|Asia/Macao", "Asia/Shanghai|Asia/Macau", "Asia/Shanghai|Asia/Taipei", "Asia/Shanghai|PRC", "Asia/Shanghai|ROC", "Asia/Tashkent|Antarctica/Mawson", "Asia/Tashkent|Asia/Aqtau", "Asia/Tashkent|Asia/Aqtobe", "Asia/Tashkent|Asia/Ashgabat", "Asia/Tashkent|Asia/Ashkhabad", "Asia/Tashkent|Asia/Atyrau", "Asia/Tashkent|Asia/Dushanbe", "Asia/Tashkent|Asia/Oral", "Asia/Tashkent|Asia/Samarkand", "Asia/Tashkent|Etc/GMT-5", "Asia/Tashkent|Indian/Kerguelen", "Asia/Tashkent|Indian/Maldives", "Asia/Tehran|Iran", "Asia/Tokyo|Japan", "Asia/Ulaanbaatar|Asia/Choibalsan", "Asia/Ulaanbaatar|Asia/Ulan_Bator", "Asia/Vladivostok|Asia/Ust-Nera", "Asia/Yakutsk|Asia/Khandyga", "Atlantic/Azores|America/Scoresbysund", "Atlantic/Cape_Verde|Etc/GMT+1", "Australia/Adelaide|Australia/Broken_Hill", "Australia/Adelaide|Australia/South", "Australia/Adelaide|Australia/Yancowinna", "Australia/Brisbane|Australia/Lindeman", "Australia/Brisbane|Australia/Queensland", "Australia/Darwin|Australia/North", "Australia/Lord_Howe|Australia/LHI", "Australia/Perth|Australia/West", "Australia/Sydney|Antarctica/Macquarie", "Australia/Sydney|Australia/ACT", "Australia/Sydney|Australia/Canberra", "Australia/Sydney|Australia/Currie", "Australia/Sydney|Australia/Hobart", "Australia/Sydney|Australia/Melbourne", "Australia/Sydney|Australia/NSW", "Australia/Sydney|Australia/Tasmania", "Australia/Sydney|Australia/Victoria", "Etc/UTC|Etc/UCT", "Etc/UTC|Etc/Universal", "Etc/UTC|Etc/Zulu", "Etc/UTC|UCT", "Etc/UTC|UTC", "Etc/UTC|Universal", "Etc/UTC|Zulu", "Europe/Athens|Asia/Nicosia", "Europe/Athens|EET", "Europe/Athens|Europe/Bucharest", "Europe/Athens|Europe/Helsinki", "Europe/Athens|Europe/Kiev", "Europe/Athens|Europe/Kyiv", "Europe/Athens|Europe/Mariehamn", "Europe/Athens|Europe/Nicosia", "Europe/Athens|Europe/Riga", "Europe/Athens|Europe/Sofia", "Europe/Athens|Europe/Tallinn", "Europe/Athens|Europe/Uzhgorod", "Europe/Athens|Europe/Vilnius", "Europe/Athens|Europe/Zaporozhye", "Europe/Chisinau|Europe/Tiraspol", "Europe/Dublin|Eire", "Europe/Istanbul|Asia/Istanbul", "Europe/Istanbul|Turkey", "Europe/Lisbon|Atlantic/Canary", "Europe/Lisbon|Atlantic/Faeroe", "Europe/Lisbon|Atlantic/Faroe", "Europe/Lisbon|Atlantic/Madeira", "Europe/Lisbon|Portugal", "Europe/Lisbon|WET", "Europe/London|Europe/Belfast", "Europe/London|Europe/Guernsey", "Europe/London|Europe/Isle_of_Man", "Europe/London|Europe/Jersey", "Europe/London|GB", "Europe/London|GB-Eire", "Europe/Moscow|W-SU", "Europe/Paris|Africa/Ceuta", "Europe/Paris|Arctic/Longyearbyen", "Europe/Paris|Atlantic/Jan_Mayen", "Europe/Paris|CET", "Europe/Paris|Europe/Amsterdam", "Europe/Paris|Europe/Andorra", "Europe/Paris|Europe/Belgrade", "Europe/Paris|Europe/Berlin", "Europe/Paris|Europe/Bratislava", "Europe/Paris|Europe/Brussels", "Europe/Paris|Europe/Budapest", "Europe/Paris|Europe/Busingen", "Europe/Paris|Europe/Copenhagen", "Europe/Paris|Europe/Gibraltar", "Europe/Paris|Europe/Ljubljana", "Europe/Paris|Europe/Luxembourg", "Europe/Paris|Europe/Madrid", "Europe/Paris|Europe/Malta", "Europe/Paris|Europe/Monaco", "Europe/Paris|Europe/Oslo", "Europe/Paris|Europe/Podgorica", "Europe/Paris|Europe/Prague", "Europe/Paris|Europe/Rome", "Europe/Paris|Europe/San_Marino", "Europe/Paris|Europe/Sarajevo", "Europe/Paris|Europe/Skopje", "Europe/Paris|Europe/Stockholm", "Europe/Paris|Europe/Tirane", "Europe/Paris|Europe/Vaduz", "Europe/Paris|Europe/Vatican", "Europe/Paris|Europe/Vienna", "Europe/Paris|Europe/Warsaw", "Europe/Paris|Europe/Zagreb", "Europe/Paris|Europe/Zurich", "Europe/Paris|Poland", "Europe/Ulyanovsk|Europe/Astrakhan", "Pacific/Auckland|Antarctica/McMurdo", "Pacific/Auckland|Antarctica/South_Pole", "Pacific/Auckland|NZ", "Pacific/Chatham|NZ-CHAT", "Pacific/Easter|Chile/EasterIsland", "Pacific/Fakaofo|Etc/GMT-13", "Pacific/Fakaofo|Pacific/Enderbury", "Pacific/Fakaofo|Pacific/Kanton", "Pacific/Galapagos|Etc/GMT+6", "Pacific/Gambier|Etc/GMT+9", "Pacific/Guadalcanal|Etc/GMT-11", "Pacific/Guadalcanal|Pacific/Efate", "Pacific/Guadalcanal|Pacific/Kosrae", "Pacific/Guadalcanal|Pacific/Noumea", "Pacific/Guadalcanal|Pacific/Pohnpei", "Pacific/Guadalcanal|Pacific/Ponape", "Pacific/Guam|Pacific/Saipan", "Pacific/Honolulu|HST", "Pacific/Honolulu|Pacific/Johnston", "Pacific/Honolulu|US/Hawaii", "Pacific/Kiritimati|Etc/GMT-14", "Pacific/Niue|Etc/GMT+11", "Pacific/Pago_Pago|Pacific/Midway", "Pacific/Pago_Pago|Pacific/Samoa", "Pacific/Pago_Pago|US/Samoa", "Pacific/Pitcairn|Etc/GMT+8", "Pacific/Port_Moresby|Antarctica/DumontDUrville", "Pacific/Port_Moresby|Etc/GMT-10", "Pacific/Port_Moresby|Pacific/Chuuk", "Pacific/Port_Moresby|Pacific/Truk", "Pacific/Port_Moresby|Pacific/Yap", "Pacific/Tahiti|Etc/GMT+10", "Pacific/Tahiti|Pacific/Rarotonga"], countries: ["AD|Europe/Andorra", "AE|Asia/Dubai", "AF|Asia/Kabul", "AG|America/Puerto_Rico America/Antigua", "AI|America/Puerto_Rico America/Anguilla", "AL|Europe/Tirane", "AM|Asia/Yerevan", "AO|Africa/Lagos Africa/Luanda", "AQ|Antarctica/Casey Antarctica/Davis Antarctica/Mawson Antarctica/Palmer Antarctica/Rothera Antarctica/Troll Asia/Urumqi Pacific/Auckland Pacific/Port_Moresby Asia/Riyadh Antarctica/McMurdo Antarctica/DumontDUrville Antarctica/Syowa Antarctica/Vostok", "AR|America/Argentina/Buenos_Aires America/Argentina/Cordoba America/Argentina/Salta America/Argentina/Jujuy America/Argentina/Tucuman America/Argentina/Catamarca America/Argentina/La_Rioja America/Argentina/San_Juan America/Argentina/Mendoza America/Argentina/San_Luis America/Argentina/Rio_Gallegos America/Argentina/Ushuaia", "AS|Pacific/Pago_Pago", "AT|Europe/Vienna", "AU|Australia/Lord_Howe Antarctica/Macquarie Australia/Hobart Australia/Melbourne Australia/Sydney Australia/Broken_Hill Australia/Brisbane Australia/Lindeman Australia/Adelaide Australia/Darwin Australia/Perth Australia/Eucla", "AW|America/Puerto_Rico America/Aruba", "AX|Europe/Helsinki Europe/Mariehamn", "AZ|Asia/Baku", "BA|Europe/Belgrade Europe/Sarajevo", "BB|America/Barbados", "BD|Asia/Dhaka", "BE|Europe/Brussels", "BF|Africa/Abidjan Africa/Ouagadougou", "BG|Europe/Sofia", "BH|Asia/Qatar Asia/Bahrain", "BI|Africa/Maputo Africa/Bujumbura", "BJ|Africa/Lagos Africa/Porto-Novo", "BL|America/Puerto_Rico America/St_Barthelemy", "BM|Atlantic/Bermuda", "BN|Asia/Kuching Asia/Brunei", "BO|America/La_Paz", "BQ|America/Puerto_Rico America/Kralendijk", "BR|America/Noronha America/Belem America/Fortaleza America/Recife America/Araguaina America/Maceio America/Bahia America/Sao_Paulo America/Campo_Grande America/Cuiaba America/Santarem America/Porto_Velho America/Boa_Vista America/Manaus America/Eirunepe America/Rio_Branco", "BS|America/Toronto America/Nassau", "BT|Asia/Thimphu", "BW|Africa/Maputo Africa/Gaborone", "BY|Europe/Minsk", "BZ|America/Belize", "CA|America/St_Johns America/Halifax America/Glace_Bay America/Moncton America/Goose_Bay America/Toronto America/Nipigon America/Thunder_Bay America/Iqaluit America/Pangnirtung America/Winnipeg America/Rainy_River America/Resolute America/Rankin_Inlet America/Regina America/Swift_Current America/Edmonton America/Cambridge_Bay America/Yellowknife America/Inuvik America/Dawson_Creek America/Fort_Nelson America/Whitehorse America/Dawson America/Vancouver America/Panama America/Puerto_Rico America/Phoenix America/Blanc-Sablon America/Atikokan America/Creston", "CC|Asia/Yangon Indian/Cocos", "CD|Africa/Maputo Africa/Lagos Africa/Kinshasa Africa/Lubumbashi", "CF|Africa/Lagos Africa/Bangui", "CG|Africa/Lagos Africa/Brazzaville", "CH|Europe/Zurich", "CI|Africa/Abidjan", "CK|Pacific/Rarotonga", "CL|America/Santiago America/Punta_Arenas Pacific/Easter", "CM|Africa/Lagos Africa/Douala", "CN|Asia/Shanghai Asia/Urumqi", "CO|America/Bogota", "CR|America/Costa_Rica", "CU|America/Havana", "CV|Atlantic/Cape_Verde", "CW|America/Puerto_Rico America/Curacao", "CX|Asia/Bangkok Indian/Christmas", "CY|Asia/Nicosia Asia/Famagusta", "CZ|Europe/Prague", "DE|Europe/Zurich Europe/Berlin Europe/Busingen", "DJ|Africa/Nairobi Africa/Djibouti", "DK|Europe/Berlin Europe/Copenhagen", "DM|America/Puerto_Rico America/Dominica", "DO|America/Santo_Domingo", "DZ|Africa/Algiers", "EC|America/Guayaquil Pacific/Galapagos", "EE|Europe/Tallinn", "EG|Africa/Cairo", "EH|Africa/El_Aaiun", "ER|Africa/Nairobi Africa/Asmara", "ES|Europe/Madrid Africa/Ceuta Atlantic/Canary", "ET|Africa/Nairobi Africa/Addis_Ababa", "FI|Europe/Helsinki", "FJ|Pacific/Fiji", "FK|Atlantic/Stanley", "FM|Pacific/Kosrae Pacific/Port_Moresby Pacific/Guadalcanal Pacific/Chuuk Pacific/Pohnpei", "FO|Atlantic/Faroe", "FR|Europe/Paris", "GA|Africa/Lagos Africa/Libreville", "GB|Europe/London", "GD|America/Puerto_Rico America/Grenada", "GE|Asia/Tbilisi", "GF|America/Cayenne", "GG|Europe/London Europe/Guernsey", "GH|Africa/Abidjan Africa/Accra", "GI|Europe/Gibraltar", "GL|America/Nuuk America/Danmarkshavn America/Scoresbysund America/Thule", "GM|Africa/Abidjan Africa/Banjul", "GN|Africa/Abidjan Africa/Conakry", "GP|America/Puerto_Rico America/Guadeloupe", "GQ|Africa/Lagos Africa/Malabo", "GR|Europe/Athens", "GS|Atlantic/South_Georgia", "GT|America/Guatemala", "GU|Pacific/Guam", "GW|Africa/Bissau", "GY|America/Guyana", "HK|Asia/Hong_Kong", "HN|America/Tegucigalpa", "HR|Europe/Belgrade Europe/Zagreb", "HT|America/Port-au-Prince", "HU|Europe/Budapest", "ID|Asia/Jakarta Asia/Pontianak Asia/Makassar Asia/Jayapura", "IE|Europe/Dublin", "IL|Asia/Jerusalem", "IM|Europe/London Europe/Isle_of_Man", "IN|Asia/Kolkata", "IO|Indian/Chagos", "IQ|Asia/Baghdad", "IR|Asia/Tehran", "IS|Africa/Abidjan Atlantic/Reykjavik", "IT|Europe/Rome", "JE|Europe/London Europe/Jersey", "JM|America/Jamaica", "JO|Asia/Amman", "JP|Asia/Tokyo", "KE|Africa/Nairobi", "KG|Asia/Bishkek", "KH|Asia/Bangkok Asia/Phnom_Penh", "KI|Pacific/Tarawa Pacific/Kanton Pacific/Kiritimati", "KM|Africa/Nairobi Indian/Comoro", "KN|America/Puerto_Rico America/St_Kitts", "KP|Asia/Pyongyang", "KR|Asia/Seoul", "KW|Asia/Riyadh Asia/Kuwait", "KY|America/Panama America/Cayman", "KZ|Asia/Almaty Asia/Qyzylorda Asia/Qostanay Asia/Aqtobe Asia/Aqtau Asia/Atyrau Asia/Oral", "LA|Asia/Bangkok Asia/Vientiane", "LB|Asia/Beirut", "LC|America/Puerto_Rico America/St_Lucia", "LI|Europe/Zurich Europe/Vaduz", "LK|Asia/Colombo", "LR|Africa/Monrovia", "LS|Africa/Johannesburg Africa/Maseru", "LT|Europe/Vilnius", "LU|Europe/Brussels Europe/Luxembourg", "LV|Europe/Riga", "LY|Africa/Tripoli", "MA|Africa/Casablanca", "MC|Europe/Paris Europe/Monaco", "MD|Europe/Chisinau", "ME|Europe/Belgrade Europe/Podgorica", "MF|America/Puerto_Rico America/Marigot", "MG|Africa/Nairobi Indian/Antananarivo", "MH|Pacific/Tarawa Pacific/Kwajalein Pacific/Majuro", "MK|Europe/Belgrade Europe/Skopje", "ML|Africa/Abidjan Africa/Bamako", "MM|Asia/Yangon", "MN|Asia/Ulaanbaatar Asia/Hovd Asia/Choibalsan", "MO|Asia/Macau", "MP|Pacific/Guam Pacific/Saipan", "MQ|America/Martinique", "MR|Africa/Abidjan Africa/Nouakchott", "MS|America/Puerto_Rico America/Montserrat", "MT|Europe/Malta", "MU|Indian/Mauritius", "MV|Indian/Maldives", "MW|Africa/Maputo Africa/Blantyre", "MX|America/Mexico_City America/Cancun America/Merida America/Monterrey America/Matamoros America/Mazatlan America/Chihuahua America/Ojinaga America/Hermosillo America/Tijuana America/Bahia_Banderas", "MY|Asia/Kuching Asia/Singapore Asia/Kuala_Lumpur", "MZ|Africa/Maputo", "NA|Africa/Windhoek", "NC|Pacific/Noumea", "NE|Africa/Lagos Africa/Niamey", "NF|Pacific/Norfolk", "NG|Africa/Lagos", "NI|America/Managua", "NL|Europe/Brussels Europe/Amsterdam", "NO|Europe/Berlin Europe/Oslo", "NP|Asia/Kathmandu", "NR|Pacific/Nauru", "NU|Pacific/Niue", "NZ|Pacific/Auckland Pacific/Chatham", "OM|Asia/Dubai Asia/Muscat", "PA|America/Panama", "PE|America/Lima", "PF|Pacific/Tahiti Pacific/Marquesas Pacific/Gambier", "PG|Pacific/Port_Moresby Pacific/Bougainville", "PH|Asia/Manila", "PK|Asia/Karachi", "PL|Europe/Warsaw", "PM|America/Miquelon", "PN|Pacific/Pitcairn", "PR|America/Puerto_Rico", "PS|Asia/Gaza Asia/Hebron", "PT|Europe/Lisbon Atlantic/Madeira Atlantic/Azores", "PW|Pacific/Palau", "PY|America/Asuncion", "QA|Asia/Qatar", "RE|Asia/Dubai Indian/Reunion", "RO|Europe/Bucharest", "RS|Europe/Belgrade", "RU|Europe/Kaliningrad Europe/Moscow Europe/Simferopol Europe/Kirov Europe/Volgograd Europe/Astrakhan Europe/Saratov Europe/Ulyanovsk Europe/Samara Asia/Yekaterinburg Asia/Omsk Asia/Novosibirsk Asia/Barnaul Asia/Tomsk Asia/Novokuznetsk Asia/Krasnoyarsk Asia/Irkutsk Asia/Chita Asia/Yakutsk Asia/Khandyga Asia/Vladivostok Asia/Ust-Nera Asia/Magadan Asia/Sakhalin Asia/Srednekolymsk Asia/Kamchatka Asia/Anadyr", "RW|Africa/Maputo Africa/Kigali", "SA|Asia/Riyadh", "SB|Pacific/Guadalcanal", "SC|Asia/Dubai Indian/Mahe", "SD|Africa/Khartoum", "SE|Europe/Berlin Europe/Stockholm", "SG|Asia/Singapore", "SH|Africa/Abidjan Atlantic/St_Helena", "SI|Europe/Belgrade Europe/Ljubljana", "SJ|Europe/Berlin Arctic/Longyearbyen", "SK|Europe/Prague Europe/Bratislava", "SL|Africa/Abidjan Africa/Freetown", "SM|Europe/Rome Europe/San_Marino", "SN|Africa/Abidjan Africa/Dakar", "SO|Africa/Nairobi Africa/Mogadishu", "SR|America/Paramaribo", "SS|Africa/Juba", "ST|Africa/Sao_Tome", "SV|America/El_Salvador", "SX|America/Puerto_Rico America/Lower_Princes", "SY|Asia/Damascus", "SZ|Africa/Johannesburg Africa/Mbabane", "TC|America/Grand_Turk", "TD|Africa/Ndjamena", "TF|Asia/Dubai Indian/Maldives Indian/Kerguelen", "TG|Africa/Abidjan Africa/Lome", "TH|Asia/Bangkok", "TJ|Asia/Dushanbe", "TK|Pacific/Fakaofo", "TL|Asia/Dili", "TM|Asia/Ashgabat", "TN|Africa/Tunis", "TO|Pacific/Tongatapu", "TR|Europe/Istanbul", "TT|America/Puerto_Rico America/Port_of_Spain", "TV|Pacific/Tarawa Pacific/Funafuti", "TW|Asia/Taipei", "TZ|Africa/Nairobi Africa/Dar_es_Salaam", "UA|Europe/Simferopol Europe/Kyiv Europe/Uzhgorod Europe/Zaporozhye", "UG|Africa/Nairobi Africa/Kampala", "UM|Pacific/Pago_Pago Pacific/Tarawa Pacific/Honolulu Pacific/Midway Pacific/Wake", "US|America/New_York America/Detroit America/Kentucky/Louisville America/Kentucky/Monticello America/Indiana/Indianapolis America/Indiana/Vincennes America/Indiana/Winamac America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Vevay America/Chicago America/Indiana/Tell_City America/Indiana/Knox America/Menominee America/North_Dakota/Center America/North_Dakota/New_Salem America/North_Dakota/Beulah America/Denver America/Boise America/Phoenix America/Los_Angeles America/Anchorage America/Juneau America/Sitka America/Metlakatla America/Yakutat America/Nome America/Adak Pacific/Honolulu", "UY|America/Montevideo", "UZ|Asia/Samarkand Asia/Tashkent", "VA|Europe/Rome Europe/Vatican", "VC|America/Puerto_Rico America/St_Vincent", "VE|America/Caracas", "VG|America/Puerto_Rico America/Tortola", "VI|America/Puerto_Rico America/St_Thomas", "VN|Asia/Bangkok Asia/Ho_Chi_Minh", "VU|Pacific/Efate", "WF|Pacific/Tarawa Pacific/Wallis", "WS|Pacific/Apia", "YE|Asia/Riyadh Asia/Aden", "YT|Africa/Nairobi Indian/Mayotte", "ZA|Africa/Johannesburg", "ZM|Africa/Maputo Africa/Lusaka", "ZW|Africa/Maputo Africa/Harare"] }), o;
      });
    }
  });

  // node_modules/moment-parseformat/lib/parseformat.js
  var require_parseformat = __commonJS({
    "node_modules/moment-parseformat/lib/parseformat.js"(exports, module) {
      module.exports = parseFormat;
      var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      var abbreviatedDayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      var shortestDayNames = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
      var monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      var abbreviatedMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      var regexDayNames = new RegExp(dayNames.join("|"), "i");
      var regexAbbreviatedDayNames = new RegExp(abbreviatedDayNames.join("|"), "i");
      var regexShortestDayNames = new RegExp("\\b(" + shortestDayNames.join("|") + ")\\b", "i");
      var regexMonthNames = new RegExp(monthNames.join("|"), "i");
      var regexAbbreviatedMonthNames = new RegExp(abbreviatedMonthNames.join("|"), "i");
      var regexFirstSecondThirdFourth = /(\d+)(st|nd|rd|th)\b/i;
      var regexEndian = /(\d{1,4})([/.-])(\d{1,2})[/.-](\d{1,4})/;
      var regexTimezone = /((\+|-)\d\d:?\d\d)$/;
      var amOrPm = "(" + ["AM?", "PM?"].join("|") + ")";
      var regexHoursWithLeadingZeroDigitMinutesSecondsAmPm = new RegExp("0\\d\\:\\d{1,2}\\:\\d{1,2}(\\s*)" + amOrPm, "i");
      var regexHoursWithLeadingZeroDigitMinutesAmPm = new RegExp("0\\d\\:\\d{1,2}(\\s*)" + amOrPm, "i");
      var regexHoursWithLeadingZeroDigitAmPm = new RegExp("0\\d(\\s*)" + amOrPm, "i");
      var regexHoursMinutesSecondsAmPm = new RegExp("\\d{1,2}\\:\\d{1,2}\\:\\d{1,2}(\\s*)" + amOrPm, "i");
      var regexHoursMinutesAmPm = new RegExp("\\d{1,2}\\:\\d{1,2}(\\s*)" + amOrPm, "i");
      var regexHoursAmPm = new RegExp("\\d{1,2}(\\s*)" + amOrPm, "i");
      var regexISO8601HoursWithLeadingZeroMinutesSecondsMilliseconds = /\d{2}:\d{2}:\d{2}\.\d{3}/;
      var regexISO8601HoursWithLeadingZeroMinutesSecondsCentiSeconds = /\d{2}:\d{2}:\d{2}\.\d{2}/;
      var regexISO8601HoursWithLeadingZeroMinutesSecondsDeciSeconds = /\d{2}:\d{2}:\d{2}\.\d{1}/;
      var regexHoursWithLeadingZeroMinutesSeconds = /0\d:\d{2}:\d{2}/;
      var regexHoursWithLeadingZeroMinutes = /0\d:\d{2}/;
      var regexHoursMinutesSeconds = /\d{1,2}:\d{2}:\d{2}/;
      var regexHoursMinutesSecondsMilliseconds = /\d{1,2}:\d{2}:\d{2}\.\d{3}/;
      var regexHoursMinutesSecondsCentiSeconds = /\d{1,2}:\d{2}:\d{2}\.\d{2}/;
      var regexHoursMinutesSecondsDeciSeconds = /\d{1,2}:\d{2}:\d{2}\.\d{1}/;
      var regexHoursMinutes = /\d{1,2}:\d{2}/;
      var regexYearLong = /\d{4}/;
      var regexDayLeadingZero = /0\d/;
      var regexDay = /\d{1,2}/;
      var regexYearShort = /\d{2}/;
      var regexDayShortMonthShort = /^([1-9])\/([1-9]|0[1-9])$/;
      var regexDayShortMonth = /^([1-9])\/(1[012])$/;
      var regexDayMonthShort = /^(0[1-9]|[12][0-9]|3[01])\/([1-9])$/;
      var regexDayMonth = /^(0[1-9]|[12][0-9]|3[01])\/(1[012]|0[1-9])$/;
      var regexMonthShortYearShort = /^([1-9])\/([1-9][0-9])$/;
      var regexMonthYearShort = /^(0[1-9]|1[012])\/([1-9][0-9])$/;
      var formatIncludesMonth = /([/][M]|[M][/]|[MM]|[MMMM])/;
      var regexFillingWords = /\b(at)\b/i;
      var regexUnixMillisecondTimestamp = /\d{13}/;
      var regexUnixTimestamp = /\d{10}/;
      var defaultOrder = {
        "/": "MDY",
        ".": "DMY",
        "-": "YMD"
      };
      function parseFormat(dateString, options) {
        var format = dateString.toString();
        options = options || {};
        options.preferredOrder = options.preferredOrder || defaultOrder;
        format = format.replace(regexUnixMillisecondTimestamp, "x");
        format = format.replace(regexUnixTimestamp, "X");
        format = format.replace(regexFillingWords, "[$1]");
        format = format.replace(regexDayNames, "dddd");
        format = format.replace(regexAbbreviatedDayNames, "ddd");
        format = format.replace(regexShortestDayNames, "dd");
        format = format.replace(regexFirstSecondThirdFourth, "Do");
        format = format.replace(regexMonthNames, "MMMM");
        format = format.replace(regexAbbreviatedMonthNames, "MMM");
        format = format.replace(regexEndian, replaceEndian.bind(null, options));
        format = format.replace(regexTimezone, "Z");
        format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsMilliseconds, "HH:mm:ss.SSS");
        format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsCentiSeconds, "HH:mm:ss.SS");
        format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsDeciSeconds, "HH:mm:ss.S");
        function replaceWithAmPm(timeFormat) {
          return function(match, whitespace, amPm) {
            return timeFormat + whitespace + (amPm[0].toUpperCase() === amPm[0] ? "A" : "a");
          };
        }
        format = format.replace(regexHoursWithLeadingZeroDigitMinutesSecondsAmPm, replaceWithAmPm("hh:mm:ss"));
        format = format.replace(regexHoursMinutesSecondsAmPm, replaceWithAmPm("h:mm:ss"));
        format = format.replace(regexHoursWithLeadingZeroDigitMinutesAmPm, replaceWithAmPm("hh:mm"));
        format = format.replace(regexHoursMinutesAmPm, replaceWithAmPm("h:mm"));
        format = format.replace(regexHoursWithLeadingZeroDigitAmPm, replaceWithAmPm("hh"));
        format = format.replace(regexHoursAmPm, replaceWithAmPm("h"));
        format = format.replace(regexHoursWithLeadingZeroMinutesSeconds, "HH:mm:ss");
        format = format.replace(regexHoursMinutesSecondsMilliseconds, "H:mm:ss.SSS");
        format = format.replace(regexHoursMinutesSecondsCentiSeconds, "H:mm:ss.SS");
        format = format.replace(regexHoursMinutesSecondsDeciSeconds, "H:mm:ss.S");
        format = format.replace(regexHoursMinutesSeconds, "H:mm:ss");
        format = format.replace(regexHoursWithLeadingZeroMinutes, "HH:mm");
        format = format.replace(regexHoursMinutes, "H:mm");
        format = format.replace(regexYearLong, "YYYY");
        format = format.replace(regexDayShortMonthShort, "D/M");
        format = format.replace(regexDayShortMonth, "D/MM");
        format = format.replace(regexDayMonthShort, "DD/M");
        format = format.replace(regexDayMonth, "DD/MM");
        format = format.replace(regexMonthShortYearShort, "M/YY");
        format = format.replace(regexMonthYearShort, "MM/YY");
        if (format.match(formatIncludesMonth)) {
          var regexHoursDotWithLeadingZeroOrDoubleDigitMinutes = /0\d.\d{2}|\d{2}.\d{2}/;
          var regexHoursDotMinutes = /\d{1}.\d{2}/;
          format = format.replace(regexHoursDotWithLeadingZeroOrDoubleDigitMinutes, "H.mm");
          format = format.replace(regexHoursDotMinutes, "h.mm");
        }
        format = format.replace(regexDayLeadingZero, "DD");
        format = format.replace(regexDay, "D");
        format = format.replace(regexYearShort, "YY");
        if (format.length < 1) {
          format = void 0;
        }
        return format;
      }
      function replaceEndian(options, matchedPart, first, separator, second, third) {
        var parts;
        var hasSingleDigit = Math.min(first.length, second.length, third.length) === 1;
        var hasQuadDigit = Math.max(first.length, second.length, third.length) === 4;
        var preferredOrder = typeof options.preferredOrder === "string" ? options.preferredOrder : options.preferredOrder[separator];
        first = parseInt(first, 10);
        second = parseInt(second, 10);
        third = parseInt(third, 10);
        parts = [first, second, third];
        preferredOrder = preferredOrder.toUpperCase();
        if (first > 31) {
          parts[0] = hasQuadDigit ? "YYYY" : "YY";
          parts[1] = hasSingleDigit ? "M" : "MM";
          parts[2] = hasSingleDigit ? "D" : "DD";
          return parts.join(separator);
        }
        if (second > 12) {
          parts[0] = hasSingleDigit ? "M" : "MM";
          parts[1] = hasSingleDigit ? "D" : "DD";
          parts[2] = hasQuadDigit ? "YYYY" : "YY";
          return parts.join(separator);
        }
        if (third > 31) {
          parts[2] = hasQuadDigit ? "YYYY" : "YY";
          if (preferredOrder[0] === "M" && first < 13) {
            parts[0] = hasSingleDigit ? "M" : "MM";
            parts[1] = hasSingleDigit ? "D" : "DD";
            return parts.join(separator);
          }
          parts[0] = hasSingleDigit ? "D" : "DD";
          parts[1] = hasSingleDigit ? "M" : "MM";
          return parts.join(separator);
        }
        parts[preferredOrder.indexOf("D")] = hasSingleDigit ? "D" : "DD";
        parts[preferredOrder.indexOf("M")] = hasSingleDigit ? "M" : "MM";
        parts[preferredOrder.indexOf("Y")] = hasQuadDigit ? "YYYY" : "YY";
        return parts.join(separator);
      }
    }
  });

  // node_modules/moment-parseformat/index.js
  var require_moment_parseformat = __commonJS({
    "node_modules/moment-parseformat/index.js"(exports, module) {
      var parseFormat = require_parseformat();
      module.exports = parseFormat;
      if (typeof window !== "undefined" && window.moment) {
        window.moment.parseFormat = parseFormat;
      }
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array2(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape2(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape2;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/wuzzy/index.js
  var require_wuzzy = __commonJS({
    "node_modules/wuzzy/index.js"(exports) {
      var _ = require_lodash();
      function sum(arr) {
        return arr.reduce(function(p, c, i, a) {
          return p + c;
        });
      }
      function ensureArr(arr) {
        if (_.isArray(arr)) {
          return arr;
        } else if (typeof arr === "string") {
          return arr.split("");
        } else {
          throw Error("Parameter must be a string or array.");
        }
      }
      exports.jarowinkler = function(a, b, t) {
        a = ensureArr(a);
        b = ensureArr(b);
        var max, min;
        if (a.length > b.length) {
          max = a;
          min = b;
        } else {
          max = b;
          min = a;
        }
        var threshold = t ? t : 0.7;
        var weight = 0.1;
        var range = Math.floor(Math.max(max.length / 2 - 1, 0));
        var mIdx = [];
        var mFlg = [];
        var mi, xi, xn, c1;
        var matches = 0;
        for (mi = 0; mi < min.length; mi++) {
          c1 = min[mi];
          for (xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max.length); xi < xn; xi++) {
            if (!mFlg[xi] && c1 === max[xi]) {
              mIdx[mi] = xi;
              mFlg[xi] = true;
              matches++;
              break;
            }
          }
        }
        var ma = [];
        var mb = [];
        var i, si;
        var trans = 0;
        var prefix = 0;
        for (i = 0, si = 0; i < min.length; i++) {
          if (mIdx[i] > -1) {
            ma[si] = min[i];
            si++;
          }
        }
        for (i = 0, si = 0; i < max.length; i++) {
          if (mFlg[i]) {
            mb[si] = max[i];
            si++;
          }
        }
        for (mi = 0; mi < ma.length; mi++) {
          if (ma[mi] !== mb[mi]) {
            trans++;
          }
        }
        for (mi = 0; mi < min.length; mi++) {
          if (a[mi] === b[mi]) {
            prefix++;
          } else {
            break;
          }
        }
        var m = matches;
        var t = trans / 2;
        if (!m) {
          return 0;
        } else {
          var j = (m / a.length + m / b.length + (m - t) / m) / 3;
          var jw = j < threshold ? j : j + Math.min(weight, 1 / max.length) * prefix * (1 - j);
          return jw;
        }
      };
      exports.levenshtein = function(a, b, w) {
        a = ensureArr(a);
        b = ensureArr(b);
        if (a.length === 0) {
          return b.length;
        }
        if (b.length === 0) {
          return a.length;
        }
        var weights = w ? w : {
          d: 1,
          i: 1,
          s: 1
        };
        var v0 = [];
        var v1 = [];
        var vlen = b.length + 1;
        var i, j;
        var cost;
        var mlen;
        for (i = 0; i < vlen; i++) {
          v0[i] = i;
        }
        for (i = 0; i < a.length; i++) {
          v1[0] = i + 1;
          for (j = 0; j < b.length; j++) {
            cost = a[i] === b[j] ? 0 : weights.s;
            v1[j + 1] = Math.min(
              v1[j] + weights.d,
              v0[j + 1] + weights.i,
              v0[j] + cost
            );
          }
          for (j = 0; j < vlen; j++) {
            v0[j] = v1[j];
          }
        }
        mlen = Math.max(a.length, b.length);
        return (mlen - v1[b.length]) / mlen;
      };
      exports.ngram = function(a, b, ng) {
        a = ensureArr(a);
        b = ensureArr(b);
        var al = a.length;
        var bl = b.length;
        var n = ng ? ng : 2;
        var cost;
        var i, j, ni, ti, tn, ec;
        var sa = [];
        var p = [];
        var d = [];
        var _d = [];
        var t_j = [];
        var pdl = al + 1;
        if (al === 0 || bl === 0) {
          if (al === bl) {
            return 1;
          } else {
            return 0;
          }
        }
        cost = 0;
        if (al < n || bl < n) {
          for (i = 0, ni = Math.min(al, bl); i < ni; i++) {
            if (a[i] === b[i]) {
              cost++;
            }
          }
          return cost / Math.max(al, bl);
        }
        for (i = 0; i < al + n - 1; i++) {
          if (i < n - 1) {
            sa[i] = 0;
          } else {
            sa[i] = a[i - n + 1];
          }
        }
        for (i = 0; i <= al; i++) {
          p[i] = i;
        }
        for (j = 1; j <= bl; j++) {
          if (j < n) {
            for (ti = 0; ti < n - j; ti++) {
              t_j[ti] = 0;
            }
            for (ti = n - j; ti < n; ti++) {
              t_j[ti] = b[ti - (n - j)];
            }
          } else {
            t_j = b.slice(j - n, j);
          }
          d[0] = j;
          for (i = 1; i <= al; i++) {
            cost = 0;
            tn = n;
            for (ni = 0; ni < n; ni++) {
              if (sa[i - 1 + ni] !== t_j[ni]) {
                cost++;
              } else if (sa[i - 1 + ni] === 0) {
                tn--;
              }
            }
            ec = cost / tn;
            d[i] = Math.min(
              Math.min(
                d[i - 1] + 1,
                p[i] + 1
              ),
              p[i - 1] + ec
            );
          }
          _d = p;
          p = d;
          d = _d;
        }
        return 1 - p[al] / Math.max(al, bl);
      };
      exports.pearson = function(a, b) {
        var sk = [];
        Object.keys(a).forEach(function(k) {
          if (b[k]) {
            sk.push(k);
          }
        });
        var n = sk.length;
        if (n === 0) {
          return 0;
        }
        var sa = sum(sk.map(function(k) {
          return a[k];
        }));
        var sb = sum(sk.map(function(k) {
          return b[k];
        }));
        var sas = sum(sk.map(function(k) {
          return Math.pow(a[k], 2);
        }));
        var sbs = sum(sk.map(function(k) {
          return Math.pow(b[k], 2);
        }));
        var sp = sum(sk.map(function(k) {
          return a[k] * b[k];
        }));
        var num = sp - sa * sb / n;
        var den = Math.sqrt((sas - Math.pow(sa, 2) / n) * (sbs - Math.pow(sb, 2) / n));
        if (den === 0) {
          return 0;
        } else {
          return num / den;
        }
      };
      exports.jaccard = function(a, b) {
        a = ensureArr(a);
        b = ensureArr(b);
        return _.intersection(a, b).length / _.union(a, b).length;
      };
      exports.tanimoto = function(a, b) {
        a = ensureArr(a);
        b = ensureArr(b);
        var both = _.intersection(a, b).length;
        return both / (a.length + b.length - both);
      };
    }
  });

  // node_modules/heap/lib/heap.js
  var require_heap = __commonJS({
    "node_modules/heap/lib/heap.js"(exports, module) {
      (function() {
        var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
        floor = Math.floor, min = Math.min;
        defaultCmp = function(x, y) {
          if (x < y) {
            return -1;
          }
          if (x > y) {
            return 1;
          }
          return 0;
        };
        insort = function(a, x, lo, hi, cmp) {
          var mid;
          if (lo == null) {
            lo = 0;
          }
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (lo < 0) {
            throw new Error("lo must be non-negative");
          }
          if (hi == null) {
            hi = a.length;
          }
          while (lo < hi) {
            mid = floor((lo + hi) / 2);
            if (cmp(x, a[mid]) < 0) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
        };
        heappush = function(array, item, cmp) {
          if (cmp == null) {
            cmp = defaultCmp;
          }
          array.push(item);
          return _siftdown(array, 0, array.length - 1, cmp);
        };
        heappop = function(array, cmp) {
          var lastelt, returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          lastelt = array.pop();
          if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
          } else {
            returnitem = lastelt;
          }
          return returnitem;
        };
        heapreplace = function(array, item, cmp) {
          var returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          returnitem = array[0];
          array[0] = item;
          _siftup(array, 0, cmp);
          return returnitem;
        };
        heappushpop = function(array, item, cmp) {
          var _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (array.length && cmp(array[0], item) < 0) {
            _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
          }
          return item;
        };
        heapify = function(array, cmp) {
          var i, _i, _j, _len, _ref, _ref1, _results, _results1;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          _ref1 = function() {
            _results1 = [];
            for (var _j2 = 0, _ref2 = floor(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
              _results1.push(_j2);
            }
            return _results1;
          }.apply(this).reverse();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            i = _ref1[_i];
            _results.push(_siftup(array, i, cmp));
          }
          return _results;
        };
        updateItem = function(array, item, cmp) {
          var pos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          pos = array.indexOf(item);
          if (pos === -1) {
            return;
          }
          _siftdown(array, 0, pos, cmp);
          return _siftup(array, pos, cmp);
        };
        nlargest = function(array, n, cmp) {
          var elem, result, _i, _len, _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          result = array.slice(0, n);
          if (!result.length) {
            return result;
          }
          heapify(result, cmp);
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            heappushpop(result, elem, cmp);
          }
          return result.sort(cmp).reverse();
        };
        nsmallest = function(array, n, cmp) {
          var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (n * 10 <= array.length) {
            result = array.slice(0, n).sort(cmp);
            if (!result.length) {
              return result;
            }
            los = result[result.length - 1];
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem = _ref[_i];
              if (cmp(elem, los) < 0) {
                insort(result, elem, 0, null, cmp);
                result.pop();
                los = result[result.length - 1];
              }
            }
            return result;
          }
          heapify(array, cmp);
          _results = [];
          for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(heappop(array, cmp));
          }
          return _results;
        };
        _siftdown = function(array, startpos, pos, cmp) {
          var newitem, parent, parentpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          newitem = array[pos];
          while (pos > startpos) {
            parentpos = pos - 1 >> 1;
            parent = array[parentpos];
            if (cmp(newitem, parent) < 0) {
              array[pos] = parent;
              pos = parentpos;
              continue;
            }
            break;
          }
          return array[pos] = newitem;
        };
        _siftup = function(array, pos, cmp) {
          var childpos, endpos, newitem, rightpos, startpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          endpos = array.length;
          startpos = pos;
          newitem = array[pos];
          childpos = 2 * pos + 1;
          while (childpos < endpos) {
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
              childpos = rightpos;
            }
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
          }
          array[pos] = newitem;
          return _siftdown(array, startpos, pos, cmp);
        };
        Heap = function() {
          Heap2.push = heappush;
          Heap2.pop = heappop;
          Heap2.replace = heapreplace;
          Heap2.pushpop = heappushpop;
          Heap2.heapify = heapify;
          Heap2.updateItem = updateItem;
          Heap2.nlargest = nlargest;
          Heap2.nsmallest = nsmallest;
          function Heap2(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
          }
          Heap2.prototype.push = function(x) {
            return heappush(this.nodes, x, this.cmp);
          };
          Heap2.prototype.pop = function() {
            return heappop(this.nodes, this.cmp);
          };
          Heap2.prototype.peek = function() {
            return this.nodes[0];
          };
          Heap2.prototype.contains = function(x) {
            return this.nodes.indexOf(x) !== -1;
          };
          Heap2.prototype.replace = function(x) {
            return heapreplace(this.nodes, x, this.cmp);
          };
          Heap2.prototype.pushpop = function(x) {
            return heappushpop(this.nodes, x, this.cmp);
          };
          Heap2.prototype.heapify = function() {
            return heapify(this.nodes, this.cmp);
          };
          Heap2.prototype.updateItem = function(x) {
            return updateItem(this.nodes, x, this.cmp);
          };
          Heap2.prototype.clear = function() {
            return this.nodes = [];
          };
          Heap2.prototype.empty = function() {
            return this.nodes.length === 0;
          };
          Heap2.prototype.size = function() {
            return this.nodes.length;
          };
          Heap2.prototype.clone = function() {
            var heap;
            heap = new Heap2();
            heap.nodes = this.nodes.slice(0);
            return heap;
          };
          Heap2.prototype.toArray = function() {
            return this.nodes.slice(0);
          };
          Heap2.prototype.insert = Heap2.prototype.push;
          Heap2.prototype.top = Heap2.prototype.peek;
          Heap2.prototype.front = Heap2.prototype.peek;
          Heap2.prototype.has = Heap2.prototype.contains;
          Heap2.prototype.copy = Heap2.prototype.clone;
          return Heap2;
        }();
        (function(root, factory) {
          if (typeof define === "function" && define.amd) {
            return define([], factory);
          } else if (typeof exports === "object") {
            return module.exports = factory();
          } else {
            return root.Heap = factory();
          }
        })(this, function() {
          return Heap;
        });
      }).call(exports);
    }
  });

  // node_modules/heap/index.js
  var require_heap2 = __commonJS({
    "node_modules/heap/index.js"(exports, module) {
      module.exports = require_heap();
    }
  });

  // node_modules/difflib/lib/difflib.js
  var require_difflib = __commonJS({
    "node_modules/difflib/lib/difflib.js"(exports) {
      (function() {
        var Differ, Heap, IS_CHARACTER_JUNK, IS_LINE_JUNK, SequenceMatcher, contextDiff, floor, getCloseMatches, max, min, ndiff, restore, unifiedDiff, _any, _arrayCmp, _calculateRatio, _countLeading, _formatRangeContext, _formatRangeUnified, _has, __indexOf = [].indexOf || function(item) {
          for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        };
        floor = Math.floor, max = Math.max, min = Math.min;
        Heap = require_heap2();
        _calculateRatio = function(matches, length) {
          if (length) {
            return 2 * matches / length;
          } else {
            return 1;
          }
        };
        _arrayCmp = function(a, b) {
          var i, la, lb, _i, _ref, _ref1;
          _ref = [a.length, b.length], la = _ref[0], lb = _ref[1];
          for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            if (a[i] < b[i]) {
              return -1;
            }
            if (a[i] > b[i]) {
              return 1;
            }
          }
          return la - lb;
        };
        _has = function(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        };
        _any = function(items) {
          var item, _i, _len;
          for (_i = 0, _len = items.length; _i < _len; _i++) {
            item = items[_i];
            if (item) {
              return true;
            }
          }
          return false;
        };
        SequenceMatcher = function() {
          function SequenceMatcher2(isjunk, a, b, autojunk) {
            this.isjunk = isjunk;
            if (a == null) {
              a = "";
            }
            if (b == null) {
              b = "";
            }
            this.autojunk = autojunk != null ? autojunk : true;
            this.a = this.b = null;
            this.setSeqs(a, b);
          }
          SequenceMatcher2.prototype.setSeqs = function(a, b) {
            this.setSeq1(a);
            return this.setSeq2(b);
          };
          SequenceMatcher2.prototype.setSeq1 = function(a) {
            if (a === this.a) {
              return;
            }
            this.a = a;
            return this.matchingBlocks = this.opcodes = null;
          };
          SequenceMatcher2.prototype.setSeq2 = function(b) {
            if (b === this.b) {
              return;
            }
            this.b = b;
            this.matchingBlocks = this.opcodes = null;
            this.fullbcount = null;
            return this._chainB();
          };
          SequenceMatcher2.prototype._chainB = function() {
            var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref;
            b = this.b;
            this.b2j = b2j = {};
            for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {
              elt = b[i];
              indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = [];
              indices.push(i);
            }
            junk = {};
            isjunk = this.isjunk;
            if (isjunk) {
              _ref = Object.keys(b2j);
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                elt = _ref[_j];
                if (isjunk(elt)) {
                  junk[elt] = true;
                  delete b2j[elt];
                }
              }
            }
            popular = {};
            n = b.length;
            if (this.autojunk && n >= 200) {
              ntest = floor(n / 100) + 1;
              for (elt in b2j) {
                idxs = b2j[elt];
                if (idxs.length > ntest) {
                  popular[elt] = true;
                  delete b2j[elt];
                }
              }
            }
            this.isbjunk = function(b2) {
              return _has(junk, b2);
            };
            return this.isbpopular = function(b2) {
              return _has(popular, b2);
            };
          };
          SequenceMatcher2.prototype.findLongestMatch = function(alo, ahi, blo, bhi) {
            var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
            _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3];
            _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2];
            j2len = {};
            for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) {
              newj2len = {};
              _ref2 = _has(b2j, a[i]) ? b2j[a[i]] : [];
              for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                j = _ref2[_j];
                if (j < blo) {
                  continue;
                }
                if (j >= bhi) {
                  break;
                }
                k = newj2len[j] = (j2len[j - 1] || 0) + 1;
                if (k > bestsize) {
                  _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2];
                }
              }
              j2len = newj2len;
            }
            while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {
              _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2];
            }
            while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {
              bestsize++;
            }
            while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {
              _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2];
            }
            while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {
              bestsize++;
            }
            return [besti, bestj, bestsize];
          };
          SequenceMatcher2.prototype.getMatchingBlocks = function() {
            var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
            if (this.matchingBlocks) {
              return this.matchingBlocks;
            }
            _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];
            queue = [[0, la, 0, lb]];
            matchingBlocks = [];
            while (queue.length) {
              _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3];
              _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2];
              if (k) {
                matchingBlocks.push(x);
                if (alo < i && blo < j) {
                  queue.push([alo, i, blo, j]);
                }
                if (i + k < ahi && j + k < bhi) {
                  queue.push([i + k, ahi, j + k, bhi]);
                }
              }
            }
            matchingBlocks.sort(_arrayCmp);
            i1 = j1 = k1 = 0;
            nonAdjacent = [];
            for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) {
              _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2];
              if (i1 + k1 === i2 && j1 + k1 === j2) {
                k1 += k2;
              } else {
                if (k1) {
                  nonAdjacent.push([i1, j1, k1]);
                }
                _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2];
              }
            }
            if (k1) {
              nonAdjacent.push([i1, j1, k1]);
            }
            nonAdjacent.push([la, lb, 0]);
            return this.matchingBlocks = nonAdjacent;
          };
          SequenceMatcher2.prototype.getOpcodes = function() {
            var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2;
            if (this.opcodes) {
              return this.opcodes;
            }
            i = j = 0;
            this.opcodes = answer = [];
            _ref = this.getMatchingBlocks();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2];
              tag = "";
              if (i < ai && j < bj) {
                tag = "replace";
              } else if (i < ai) {
                tag = "delete";
              } else if (j < bj) {
                tag = "insert";
              }
              if (tag) {
                answer.push([tag, i, ai, j, bj]);
              }
              _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1];
              if (size) {
                answer.push(["equal", ai, i, bj, j]);
              }
            }
            return answer;
          };
          SequenceMatcher2.prototype.getGroupedOpcodes = function(n) {
            var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3;
            if (n == null) {
              n = 3;
            }
            codes = this.getOpcodes();
            if (!codes.length) {
              codes = [["equal", 0, 1, 0, 1]];
            }
            if (codes[0][0] === "equal") {
              _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4];
              codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2];
            }
            if (codes[codes.length - 1][0] === "equal") {
              _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4];
              codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)];
            }
            nn = n + n;
            groups = [];
            group = [];
            for (_i = 0, _len = codes.length; _i < _len; _i++) {
              _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4];
              if (tag === "equal" && i2 - i1 > nn) {
                group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]);
                groups.push(group);
                group = [];
                _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1];
              }
              group.push([tag, i1, i2, j1, j2]);
            }
            if (group.length && !(group.length === 1 && group[0][0] === "equal")) {
              groups.push(group);
            }
            return groups;
          };
          SequenceMatcher2.prototype.ratio = function() {
            var match, matches, _i, _len, _ref;
            matches = 0;
            _ref = this.getMatchingBlocks();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              match = _ref[_i];
              matches += match[2];
            }
            return _calculateRatio(matches, this.a.length + this.b.length);
          };
          SequenceMatcher2.prototype.quickRatio = function() {
            var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1;
            if (!this.fullbcount) {
              this.fullbcount = fullbcount = {};
              _ref = this.b;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                elt = _ref[_i];
                fullbcount[elt] = (fullbcount[elt] || 0) + 1;
              }
            }
            fullbcount = this.fullbcount;
            avail = {};
            matches = 0;
            _ref1 = this.a;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              elt = _ref1[_j];
              if (_has(avail, elt)) {
                numb = avail[elt];
              } else {
                numb = fullbcount[elt] || 0;
              }
              avail[elt] = numb - 1;
              if (numb > 0) {
                matches++;
              }
            }
            return _calculateRatio(matches, this.a.length + this.b.length);
          };
          SequenceMatcher2.prototype.realQuickRatio = function() {
            var la, lb, _ref;
            _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];
            return _calculateRatio(min(la, lb), la + lb);
          };
          return SequenceMatcher2;
        }();
        getCloseMatches = function(word, possibilities, n, cutoff) {
          var result, s, score, x, _i, _j, _len, _len1, _ref, _results;
          if (n == null) {
            n = 3;
          }
          if (cutoff == null) {
            cutoff = 0.6;
          }
          if (!(n > 0)) {
            throw new Error("n must be > 0: (" + n + ")");
          }
          if (!(0 <= cutoff && cutoff <= 1)) {
            throw new Error("cutoff must be in [0.0, 1.0]: (" + cutoff + ")");
          }
          result = [];
          s = new SequenceMatcher();
          s.setSeq2(word);
          for (_i = 0, _len = possibilities.length; _i < _len; _i++) {
            x = possibilities[_i];
            s.setSeq1(x);
            if (s.realQuickRatio() >= cutoff && s.quickRatio() >= cutoff && s.ratio() >= cutoff) {
              result.push([s.ratio(), x]);
            }
          }
          result = Heap.nlargest(result, n, _arrayCmp);
          _results = [];
          for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
            _ref = result[_j], score = _ref[0], x = _ref[1];
            _results.push(x);
          }
          return _results;
        };
        _countLeading = function(line, ch) {
          var i, n, _ref;
          _ref = [0, line.length], i = _ref[0], n = _ref[1];
          while (i < n && line[i] === ch) {
            i++;
          }
          return i;
        };
        Differ = function() {
          function Differ2(linejunk, charjunk) {
            this.linejunk = linejunk;
            this.charjunk = charjunk;
          }
          Differ2.prototype.compare = function(a, b) {
            var ahi, alo, bhi, blo, cruncher, g, line, lines, tag, _i, _j, _len, _len1, _ref, _ref1;
            cruncher = new SequenceMatcher(this.linejunk, a, b);
            lines = [];
            _ref = cruncher.getOpcodes();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              _ref1 = _ref[_i], tag = _ref1[0], alo = _ref1[1], ahi = _ref1[2], blo = _ref1[3], bhi = _ref1[4];
              switch (tag) {
                case "replace":
                  g = this._fancyReplace(a, alo, ahi, b, blo, bhi);
                  break;
                case "delete":
                  g = this._dump("-", a, alo, ahi);
                  break;
                case "insert":
                  g = this._dump("+", b, blo, bhi);
                  break;
                case "equal":
                  g = this._dump(" ", a, alo, ahi);
                  break;
                default:
                  throw new Error("unknow tag (" + tag + ")");
              }
              for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
                line = g[_j];
                lines.push(line);
              }
            }
            return lines;
          };
          Differ2.prototype._dump = function(tag, x, lo, hi) {
            var i, _i, _results;
            _results = [];
            for (i = _i = lo; lo <= hi ? _i < hi : _i > hi; i = lo <= hi ? ++_i : --_i) {
              _results.push("" + tag + " " + x[i]);
            }
            return _results;
          };
          Differ2.prototype._plainReplace = function(a, alo, ahi, b, blo, bhi) {
            var first, g, line, lines, second, _i, _j, _len, _len1, _ref;
            if (bhi - blo < ahi - alo) {
              first = this._dump("+", b, blo, bhi);
              second = this._dump("-", a, alo, ahi);
            } else {
              first = this._dump("-", a, alo, ahi);
              second = this._dump("+", b, blo, bhi);
            }
            lines = [];
            _ref = [first, second];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              g = _ref[_i];
              for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
                line = g[_j];
                lines.push(line);
              }
            }
            return lines;
          };
          Differ2.prototype._fancyReplace = function(a, alo, ahi, b, blo, bhi) {
            var aelt, ai, ai1, ai2, atags, belt, bestRatio, besti, bestj, bj, bj1, bj2, btags, cruncher, cutoff, eqi, eqj, i, j, la, lb, line, lines, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
            _ref = [0.74, 0.75], bestRatio = _ref[0], cutoff = _ref[1];
            cruncher = new SequenceMatcher(this.charjunk);
            _ref1 = [null, null], eqi = _ref1[0], eqj = _ref1[1];
            lines = [];
            for (j = _i = blo; blo <= bhi ? _i < bhi : _i > bhi; j = blo <= bhi ? ++_i : --_i) {
              bj = b[j];
              cruncher.setSeq2(bj);
              for (i = _j = alo; alo <= ahi ? _j < ahi : _j > ahi; i = alo <= ahi ? ++_j : --_j) {
                ai = a[i];
                if (ai === bj) {
                  if (eqi === null) {
                    _ref2 = [i, j], eqi = _ref2[0], eqj = _ref2[1];
                  }
                  continue;
                }
                cruncher.setSeq1(ai);
                if (cruncher.realQuickRatio() > bestRatio && cruncher.quickRatio() > bestRatio && cruncher.ratio() > bestRatio) {
                  _ref3 = [cruncher.ratio(), i, j], bestRatio = _ref3[0], besti = _ref3[1], bestj = _ref3[2];
                }
              }
            }
            if (bestRatio < cutoff) {
              if (eqi === null) {
                _ref4 = this._plainReplace(a, alo, ahi, b, blo, bhi);
                for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
                  line = _ref4[_k];
                  lines.push(line);
                }
                return lines;
              }
              _ref5 = [eqi, eqj, 1], besti = _ref5[0], bestj = _ref5[1], bestRatio = _ref5[2];
            } else {
              eqi = null;
            }
            _ref6 = this._fancyHelper(a, alo, besti, b, blo, bestj);
            for (_l = 0, _len1 = _ref6.length; _l < _len1; _l++) {
              line = _ref6[_l];
              lines.push(line);
            }
            _ref7 = [a[besti], b[bestj]], aelt = _ref7[0], belt = _ref7[1];
            if (eqi === null) {
              atags = btags = "";
              cruncher.setSeqs(aelt, belt);
              _ref8 = cruncher.getOpcodes();
              for (_m = 0, _len2 = _ref8.length; _m < _len2; _m++) {
                _ref9 = _ref8[_m], tag = _ref9[0], ai1 = _ref9[1], ai2 = _ref9[2], bj1 = _ref9[3], bj2 = _ref9[4];
                _ref10 = [ai2 - ai1, bj2 - bj1], la = _ref10[0], lb = _ref10[1];
                switch (tag) {
                  case "replace":
                    atags += Array(la + 1).join("^");
                    btags += Array(lb + 1).join("^");
                    break;
                  case "delete":
                    atags += Array(la + 1).join("-");
                    break;
                  case "insert":
                    btags += Array(lb + 1).join("+");
                    break;
                  case "equal":
                    atags += Array(la + 1).join(" ");
                    btags += Array(lb + 1).join(" ");
                    break;
                  default:
                    throw new Error("unknow tag (" + tag + ")");
                }
              }
              _ref11 = this._qformat(aelt, belt, atags, btags);
              for (_n = 0, _len3 = _ref11.length; _n < _len3; _n++) {
                line = _ref11[_n];
                lines.push(line);
              }
            } else {
              lines.push("  " + aelt);
            }
            _ref12 = this._fancyHelper(a, besti + 1, ahi, b, bestj + 1, bhi);
            for (_o = 0, _len4 = _ref12.length; _o < _len4; _o++) {
              line = _ref12[_o];
              lines.push(line);
            }
            return lines;
          };
          Differ2.prototype._fancyHelper = function(a, alo, ahi, b, blo, bhi) {
            var g;
            g = [];
            if (alo < ahi) {
              if (blo < bhi) {
                g = this._fancyReplace(a, alo, ahi, b, blo, bhi);
              } else {
                g = this._dump("-", a, alo, ahi);
              }
            } else if (blo < bhi) {
              g = this._dump("+", b, blo, bhi);
            }
            return g;
          };
          Differ2.prototype._qformat = function(aline, bline, atags, btags) {
            var common, lines;
            lines = [];
            common = min(_countLeading(aline, "	"), _countLeading(bline, "	"));
            common = min(common, _countLeading(atags.slice(0, common), " "));
            common = min(common, _countLeading(btags.slice(0, common), " "));
            atags = atags.slice(common).replace(/\s+$/, "");
            btags = btags.slice(common).replace(/\s+$/, "");
            lines.push("- " + aline);
            if (atags.length) {
              lines.push("? " + Array(common + 1).join("	") + atags + "\n");
            }
            lines.push("+ " + bline);
            if (btags.length) {
              lines.push("? " + Array(common + 1).join("	") + btags + "\n");
            }
            return lines;
          };
          return Differ2;
        }();
        IS_LINE_JUNK = function(line, pat) {
          if (pat == null) {
            pat = /^\s*#?\s*$/;
          }
          return pat.test(line);
        };
        IS_CHARACTER_JUNK = function(ch, ws) {
          if (ws == null) {
            ws = " 	";
          }
          return __indexOf.call(ws, ch) >= 0;
        };
        _formatRangeUnified = function(start, stop) {
          var beginning, length;
          beginning = start + 1;
          length = stop - start;
          if (length === 1) {
            return "" + beginning;
          }
          if (!length) {
            beginning--;
          }
          return "" + beginning + "," + length;
        };
        unifiedDiff = function(a, b, _arg) {
          var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, started, tag, todate, tofile, tofiledate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
          _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;
          if (fromfile == null) {
            fromfile = "";
          }
          if (tofile == null) {
            tofile = "";
          }
          if (fromfiledate == null) {
            fromfiledate = "";
          }
          if (tofiledate == null) {
            tofiledate = "";
          }
          if (n == null) {
            n = 3;
          }
          if (lineterm == null) {
            lineterm = "\n";
          }
          lines = [];
          started = false;
          _ref1 = new SequenceMatcher(null, a, b).getGroupedOpcodes();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            group = _ref1[_i];
            if (!started) {
              started = true;
              fromdate = fromfiledate ? "	" + fromfiledate : "";
              todate = tofiledate ? "	" + tofiledate : "";
              lines.push("--- " + fromfile + fromdate + lineterm);
              lines.push("+++ " + tofile + todate + lineterm);
            }
            _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];
            file1Range = _formatRangeUnified(first[1], last[2]);
            file2Range = _formatRangeUnified(first[3], last[4]);
            lines.push("@@ -" + file1Range + " +" + file2Range + " @@" + lineterm);
            for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
              _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], j1 = _ref3[3], j2 = _ref3[4];
              if (tag === "equal") {
                _ref4 = a.slice(i1, i2);
                for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                  line = _ref4[_k];
                  lines.push(" " + line);
                }
                continue;
              }
              if (tag === "replace" || tag === "delete") {
                _ref5 = a.slice(i1, i2);
                for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
                  line = _ref5[_l];
                  lines.push("-" + line);
                }
              }
              if (tag === "replace" || tag === "insert") {
                _ref6 = b.slice(j1, j2);
                for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
                  line = _ref6[_m];
                  lines.push("+" + line);
                }
              }
            }
          }
          return lines;
        };
        _formatRangeContext = function(start, stop) {
          var beginning, length;
          beginning = start + 1;
          length = stop - start;
          if (!length) {
            beginning--;
          }
          if (length <= 1) {
            return "" + beginning;
          }
          return "" + beginning + "," + (beginning + length - 1);
        };
        contextDiff = function(a, b, _arg) {
          var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, prefix, started, tag, todate, tofile, tofiledate, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
          _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;
          if (fromfile == null) {
            fromfile = "";
          }
          if (tofile == null) {
            tofile = "";
          }
          if (fromfiledate == null) {
            fromfiledate = "";
          }
          if (tofiledate == null) {
            tofiledate = "";
          }
          if (n == null) {
            n = 3;
          }
          if (lineterm == null) {
            lineterm = "\n";
          }
          prefix = {
            insert: "+ ",
            "delete": "- ",
            replace: "! ",
            equal: "  "
          };
          started = false;
          lines = [];
          _ref1 = new SequenceMatcher(null, a, b).getGroupedOpcodes();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            group = _ref1[_i];
            if (!started) {
              started = true;
              fromdate = fromfiledate ? "	" + fromfiledate : "";
              todate = tofiledate ? "	" + tofiledate : "";
              lines.push("*** " + fromfile + fromdate + lineterm);
              lines.push("--- " + tofile + todate + lineterm);
              _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];
              lines.push("***************" + lineterm);
              file1Range = _formatRangeContext(first[1], last[2]);
              lines.push("*** " + file1Range + " ****" + lineterm);
              if (_any(function() {
                var _j2, _len12, _ref32, _results;
                _results = [];
                for (_j2 = 0, _len12 = group.length; _j2 < _len12; _j2++) {
                  _ref32 = group[_j2], tag = _ref32[0], _ = _ref32[1], _ = _ref32[2], _ = _ref32[3], _ = _ref32[4];
                  _results.push(tag === "replace" || tag === "delete");
                }
                return _results;
              }())) {
                for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
                  _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], _ = _ref3[3], _ = _ref3[4];
                  if (tag !== "insert") {
                    _ref4 = a.slice(i1, i2);
                    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                      line = _ref4[_k];
                      lines.push(prefix[tag] + line);
                    }
                  }
                }
              }
              file2Range = _formatRangeContext(first[3], last[4]);
              lines.push("--- " + file2Range + " ----" + lineterm);
              if (_any(function() {
                var _l2, _len32, _ref52, _results;
                _results = [];
                for (_l2 = 0, _len32 = group.length; _l2 < _len32; _l2++) {
                  _ref52 = group[_l2], tag = _ref52[0], _ = _ref52[1], _ = _ref52[2], _ = _ref52[3], _ = _ref52[4];
                  _results.push(tag === "replace" || tag === "insert");
                }
                return _results;
              }())) {
                for (_l = 0, _len3 = group.length; _l < _len3; _l++) {
                  _ref5 = group[_l], tag = _ref5[0], _ = _ref5[1], _ = _ref5[2], j1 = _ref5[3], j2 = _ref5[4];
                  if (tag !== "delete") {
                    _ref6 = b.slice(j1, j2);
                    for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
                      line = _ref6[_m];
                      lines.push(prefix[tag] + line);
                    }
                  }
                }
              }
            }
          }
          return lines;
        };
        ndiff = function(a, b, linejunk, charjunk) {
          if (charjunk == null) {
            charjunk = IS_CHARACTER_JUNK;
          }
          return new Differ(linejunk, charjunk).compare(a, b);
        };
        restore = function(delta, which) {
          var line, lines, prefixes, tag, _i, _len, _ref;
          tag = {
            1: "- ",
            2: "+ "
          }[which];
          if (!tag) {
            throw new Error("unknow delta choice (must be 1 or 2): " + which);
          }
          prefixes = ["  ", tag];
          lines = [];
          for (_i = 0, _len = delta.length; _i < _len; _i++) {
            line = delta[_i];
            if (_ref = line.slice(0, 2), __indexOf.call(prefixes, _ref) >= 0) {
              lines.push(line.slice(2));
            }
          }
          return lines;
        };
        exports._arrayCmp = _arrayCmp;
        exports.SequenceMatcher = SequenceMatcher;
        exports.getCloseMatches = getCloseMatches;
        exports._countLeading = _countLeading;
        exports.Differ = Differ;
        exports.IS_LINE_JUNK = IS_LINE_JUNK;
        exports.IS_CHARACTER_JUNK = IS_CHARACTER_JUNK;
        exports._formatRangeUnified = _formatRangeUnified;
        exports.unifiedDiff = unifiedDiff;
        exports._formatRangeContext = _formatRangeContext;
        exports.contextDiff = contextDiff;
        exports.ndiff = ndiff;
        exports.restore = restore;
      }).call(exports);
    }
  });

  // node_modules/difflib/index.js
  var require_difflib2 = __commonJS({
    "node_modules/difflib/index.js"(exports, module) {
      module.exports = require_difflib();
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/array/from.js
  var require_from2 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/array/from.js"(exports, module) {
      module.exports = require_from();
    }
  });

  // node_modules/ellipsize/index.js
  var require_ellipsize = __commonJS({
    "node_modules/ellipsize/index.js"(exports, module) {
      "use strict";
      var defaults = {
        ellipse: "\u2026",
        chars: [" ", "-"],
        max: 140,
        truncate: true
      };
      function ellipsize(str, max, ellipse, chars, truncate) {
        if (str.length < max)
          return str;
        var last = 0, c = "", midMax = Math.floor(max / 2), computedMax = truncate === "middle" ? midMax : max;
        for (var i = 0, len = str.length; i < len; i++) {
          c = str.charAt(i);
          if (chars.indexOf(c) !== -1 && truncate !== "middle") {
            last = i;
          }
          if (i < computedMax)
            continue;
          if (last === 0) {
            return !truncate ? "" : str.substring(0, computedMax - 1) + ellipse + (truncate === "middle" ? str.substring(str.length - midMax, str.length) : "");
          }
          return str.substring(0, last) + ellipse;
        }
        return str;
      }
      module.exports = function(str, max, opts) {
        if (typeof str !== "string" || str.length === 0)
          return "";
        if (max === 0)
          return "";
        opts = opts || {};
        for (var key in defaults) {
          if (opts[key] === null || typeof opts[key] === "undefined") {
            opts[key] = defaults[key];
          }
        }
        opts.max = max || opts.max;
        return ellipsize(str, opts.max, opts.ellipse, opts.chars, opts.truncate);
      };
    }
  });

  // node_modules/@babel/runtime-corejs2/core-js/array/is-array.js
  var require_is_array3 = __commonJS({
    "node_modules/@babel/runtime-corejs2/core-js/array/is-array.js"(exports, module) {
      module.exports = require_is_array2();
    }
  });

  // node_modules/@postlight/parser/dist/mercury.js
  var require_mercury = __commonJS({
    "node_modules/@postlight/parser/dist/mercury.js"(exports, module) {
      "use strict";
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      var _regeneratorRuntime = _interopDefault(require_regenerator());
      var _objectSpread = _interopDefault(require_objectSpread());
      var _objectWithoutProperties = _interopDefault(require_objectWithoutProperties());
      var _asyncToGenerator = _interopDefault(require_asyncToGenerator());
      var URL = _interopDefault(require_url());
      var cheerio = _interopDefault((init_cheerio_query(), __toCommonJS(cheerio_query_exports)));
      var TurndownService = _interopDefault(require_turndown_browser_cjs());
      var iconv2 = _interopDefault((init_iconv_lite(), __toCommonJS(iconv_lite_exports)));
      var _parseInt = _interopDefault(require_parse_int3());
      var _slicedToArray = _interopDefault(require_slicedToArray());
      var _Promise = _interopDefault(require_promise2());
      var request2 = _interopDefault(require_browser_request());
      var _Reflect$ownKeys = _interopDefault(require_own_keys3());
      var _toConsumableArray = _interopDefault(require_toConsumableArray());
      var _defineProperty = _interopDefault(require_defineProperty());
      var _parseFloat = _interopDefault(require_parse_float3());
      var _Set = _interopDefault(require_set2());
      var _typeof = _interopDefault(require_typeof());
      var _getIterator = _interopDefault(require_get_iterator2());
      var _Object$assign = _interopDefault(require_assign2());
      var _Object$keys = _interopDefault(require_keys2());
      var stringDirection = _interopDefault(require_string_direction());
      var validUrl = _interopDefault(require_valid_url());
      var moment = _interopDefault(require_moment_timezone_with_data_2012_2022_min());
      var parseFormat = _interopDefault(require_moment_parseformat());
      var wuzzy = _interopDefault(require_wuzzy());
      var difflib = _interopDefault(require_difflib2());
      var _Array$from = _interopDefault(require_from2());
      var ellipsize = _interopDefault(require_ellipsize());
      var _Array$isArray = _interopDefault(require_is_array3());
      var NORMALIZE_RE = /\s{2,}(?![^<>]*<\/(pre|code|textarea)>)/g;
      function normalizeSpaces(text) {
        return text.replace(NORMALIZE_RE, " ").trim();
      }
      function extractFromUrl(url, regexList) {
        var matchRe = regexList.find(function(re) {
          return re.test(url);
        });
        if (matchRe) {
          return matchRe.exec(url)[1];
        }
        return null;
      }
      var PAGE_IN_HREF_RE = new RegExp("(page|paging|(p(a|g|ag)?(e|enum|ewanted|ing|ination)))?(=|/)([0-9]{1,3})", "i");
      var HAS_ALPHA_RE = /[a-z]/i;
      var IS_ALPHA_RE = /^[a-z]+$/i;
      var IS_DIGIT_RE = /^[0-9]+$/i;
      var ENCODING_RE = /charset=([\w-]+)\b/;
      var DEFAULT_ENCODING = "utf-8";
      function pageNumFromUrl(url) {
        var matches = url.match(PAGE_IN_HREF_RE);
        if (!matches)
          return null;
        var pageNum = _parseInt(matches[6], 10);
        return pageNum < 100 ? pageNum : null;
      }
      function removeAnchor(url) {
        return url.split("#")[0].replace(/\/$/, "");
      }
      function isGoodSegment(segment, index, firstSegmentHasLetters) {
        var goodSegment = true;
        if (index < 2 && IS_DIGIT_RE.test(segment) && segment.length < 3) {
          goodSegment = true;
        }
        if (index === 0 && segment.toLowerCase() === "index") {
          goodSegment = false;
        }
        if (index < 2 && segment.length < 3 && !firstSegmentHasLetters) {
          goodSegment = false;
        }
        return goodSegment;
      }
      function articleBaseUrl(url, parsed) {
        var parsedUrl = parsed || URL.parse(url);
        var protocol = parsedUrl.protocol, host = parsedUrl.host, path = parsedUrl.path;
        var firstSegmentHasLetters = false;
        var cleanedSegments = path.split("/").reverse().reduce(function(acc, rawSegment, index) {
          var segment = rawSegment;
          if (segment.includes(".")) {
            var _segment$split = segment.split("."), _segment$split2 = _slicedToArray(_segment$split, 2), possibleSegment = _segment$split2[0], fileExt = _segment$split2[1];
            if (IS_ALPHA_RE.test(fileExt)) {
              segment = possibleSegment;
            }
          }
          if (PAGE_IN_HREF_RE.test(segment) && index < 2) {
            segment = segment.replace(PAGE_IN_HREF_RE, "");
          }
          if (index === 0) {
            firstSegmentHasLetters = HAS_ALPHA_RE.test(segment);
          }
          if (isGoodSegment(segment, index, firstSegmentHasLetters)) {
            acc.push(segment);
          }
          return acc;
        }, []);
        return "".concat(protocol, "//").concat(host).concat(cleanedSegments.reverse().join("/"));
      }
      var SENTENCE_END_RE = new RegExp(".( |$)");
      function hasSentenceEnd(text) {
        return SENTENCE_END_RE.test(text);
      }
      function excerptContent(content) {
        var words = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
        return content.trim().split(/\s+/).slice(0, words).join(" ");
      }
      function getEncoding(str) {
        var encoding = DEFAULT_ENCODING;
        var matches = ENCODING_RE.exec(str);
        if (matches !== null) {
          var _matches = _slicedToArray(matches, 2);
          str = _matches[1];
        }
        if (iconv2.encodingExists(str)) {
          encoding = str;
        }
        return encoding;
      }
      var REQUEST_HEADERS = cheerio.browser ? {} : {
        "User-Agent": "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"
      };
      var FETCH_TIMEOUT = 1e4;
      var BAD_CONTENT_TYPES = ["audio/mpeg", "image/gif", "image/jpeg", "image/jpg"];
      var BAD_CONTENT_TYPES_RE = new RegExp("^(".concat(BAD_CONTENT_TYPES.join("|"), ")$"), "i");
      var MAX_CONTENT_LENGTH = 5242880;
      function get(options) {
        return new _Promise(function(resolve, reject) {
          request2(options, function(err, response, body) {
            if (err) {
              reject(err);
            } else {
              resolve({
                body,
                response
              });
            }
          });
        });
      }
      function validateResponse(response) {
        var parseNon200 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (response.statusMessage && response.statusMessage !== "OK" || response.statusCode !== 200) {
          if (!response.statusCode) {
            throw new Error("Unable to fetch content. Original exception was ".concat(response.error));
          } else if (!parseNon200) {
            throw new Error("Resource returned a response status code of ".concat(response.statusCode, " and resource was instructed to reject non-200 status codes."));
          }
        }
        var _response$headers = response.headers, contentType = _response$headers["content-type"], contentLength = _response$headers["content-length"];
        if (BAD_CONTENT_TYPES_RE.test(contentType)) {
          throw new Error("Content-type for this resource was ".concat(contentType, " and is not allowed."));
        }
        if (contentLength > MAX_CONTENT_LENGTH) {
          throw new Error("Content for this resource was too large. Maximum content length is ".concat(MAX_CONTENT_LENGTH, "."));
        }
        return true;
      }
      function fetchResource(_x, _x2) {
        return _fetchResource.apply(this, arguments);
      }
      function _fetchResource() {
        _fetchResource = _asyncToGenerator(
          /* @__PURE__ */ _regeneratorRuntime.mark(function _callee(url, parsedUrl) {
            var headers, options, _ref2, response, body, _args = arguments;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    headers = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
                    parsedUrl = parsedUrl || URL.parse(encodeURI(url));
                    options = _objectSpread({
                      url: parsedUrl.href,
                      headers: _objectSpread({}, REQUEST_HEADERS, headers),
                      timeout: FETCH_TIMEOUT,
                      // Accept cookies
                      jar: true,
                      // Set to null so the response returns as binary and body as buffer
                      // https://github.com/request/request#requestoptions-callback
                      encoding: null,
                      // Accept and decode gzip
                      gzip: true,
                      // Follow any non-GET redirects
                      followAllRedirects: true
                    }, typeof window !== "undefined" ? {} : {
                      // Follow GET redirects; this option is for Node only
                      followRedirect: true
                    });
                    _context.next = 5;
                    return get(options);
                  case 5:
                    _ref2 = _context.sent;
                    response = _ref2.response;
                    body = _ref2.body;
                    _context.prev = 8;
                    validateResponse(response);
                    return _context.abrupt("return", {
                      body,
                      response
                    });
                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](8);
                    return _context.abrupt("return", {
                      error: true,
                      message: _context.t0.message
                    });
                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[8, 13]]);
          })
        );
        return _fetchResource.apply(this, arguments);
      }
      function convertMetaProp($2, from, to) {
        $2("meta[".concat(from, "]")).each(function(_, node) {
          var $node = $2(node);
          var value = $node.attr(from);
          $node.attr(to, value);
          $node.removeAttr(from);
        });
        return $2;
      }
      function normalizeMetaTags($2) {
        $2 = convertMetaProp($2, "content", "value");
        $2 = convertMetaProp($2, "property", "name");
        return $2;
      }
      var SPACER_RE = new RegExp("transparent|spacer|blank", "i");
      var KEEP_CLASS = "mercury-parser-keep";
      var KEEP_SELECTORS = ['iframe[src^="https://www.youtube.com"]', 'iframe[src^="https://www.youtube-nocookie.com"]', 'iframe[src^="http://www.youtube.com"]', 'iframe[src^="https://player.vimeo"]', 'iframe[src^="http://player.vimeo"]', 'iframe[src^="https://www.redditmedia.com"]'];
      var STRIP_OUTPUT_TAGS = ["title", "script", "noscript", "link", "style", "hr", "embed", "iframe", "object"];
      var WHITELIST_ATTRS = ["src", "srcset", "sizes", "type", "href", "class", "id", "alt", "xlink:href", "width", "height"];
      var WHITELIST_ATTRS_RE = new RegExp("^(".concat(WHITELIST_ATTRS.join("|"), ")$"), "i");
      var CLEAN_CONDITIONALLY_TAGS = ["ul", "ol", "table", "div", "button", "form"].join(",");
      var HEADER_TAGS = ["h2", "h3", "h4", "h5", "h6"];
      var HEADER_TAG_LIST = HEADER_TAGS.join(",");
      var UNLIKELY_CANDIDATES_BLACKLIST = [
        "ad-break",
        "adbox",
        "advert",
        "addthis",
        "agegate",
        "aux",
        "blogger-labels",
        "combx",
        "comment",
        "conversation",
        "disqus",
        "entry-unrelated",
        "extra",
        "foot",
        // 'form', // This is too generic, has too many false positives
        "header",
        "hidden",
        "loader",
        "login",
        // Note: This can hit 'blogindex'.
        "menu",
        "meta",
        "nav",
        "outbrain",
        "pager",
        "pagination",
        "predicta",
        // readwriteweb inline ad box
        "presence_control_external",
        // lifehacker.com container full of false positives
        "popup",
        "printfriendly",
        "related",
        "remove",
        "remark",
        "rss",
        "share",
        "shoutbox",
        "sidebar",
        "sociable",
        "sponsor",
        "taboola",
        "tools"
      ];
      var UNLIKELY_CANDIDATES_WHITELIST = [
        "and",
        "article",
        "body",
        "blogindex",
        "column",
        "content",
        "entry-content-asset",
        "format",
        // misuse of form
        "hfeed",
        "hentry",
        "hatom",
        "main",
        "page",
        "posts",
        "shadow"
      ];
      var DIV_TO_P_BLOCK_TAGS = ["a", "blockquote", "dl", "div", "img", "p", "pre", "table"].join(",");
      var POSITIVE_SCORE_HINTS = [
        "article",
        "articlecontent",
        "instapaper_body",
        "blog",
        "body",
        "content",
        "entry-content-asset",
        "entry",
        "hentry",
        "main",
        "Normal",
        "page",
        "pagination",
        "permalink",
        "post",
        "story",
        "text",
        "[-_]copy",
        // usatoday
        "\\Bcopy"
      ];
      var POSITIVE_SCORE_RE = new RegExp(POSITIVE_SCORE_HINTS.join("|"), "i");
      var NEGATIVE_SCORE_HINTS = [
        "adbox",
        "advert",
        "author",
        "bio",
        "bookmark",
        "bottom",
        "byline",
        "clear",
        "com-",
        "combx",
        "comment",
        "comment\\B",
        "contact",
        "copy",
        "credit",
        "crumb",
        "date",
        "deck",
        "excerpt",
        "featured",
        // tnr.com has a featured_content which throws us off
        "foot",
        "footer",
        "footnote",
        "graf",
        "head",
        "info",
        "infotext",
        // newscientist.com copyright
        "instapaper_ignore",
        "jump",
        "linebreak",
        "link",
        "masthead",
        "media",
        "meta",
        "modal",
        "outbrain",
        // slate.com junk
        "promo",
        "pr_",
        // autoblog - press release
        "related",
        "respond",
        "roundcontent",
        // lifehacker restricted content warning
        "scroll",
        "secondary",
        "share",
        "shopping",
        "shoutbox",
        "side",
        "sidebar",
        "sponsor",
        "stamp",
        "sub",
        "summary",
        "tags",
        "tools",
        "widget"
      ];
      var NEGATIVE_SCORE_RE = new RegExp(NEGATIVE_SCORE_HINTS.join("|"), "i");
      var IS_WP_SELECTOR = "meta[name=generator][value^=WordPress]";
      var PAGE_RE = new RegExp("pag(e|ing|inat)", "i");
      var BLOCK_LEVEL_TAGS = ["article", "aside", "blockquote", "body", "br", "button", "canvas", "caption", "col", "colgroup", "dd", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "map", "object", "ol", "output", "p", "pre", "progress", "section", "table", "tbody", "textarea", "tfoot", "th", "thead", "tr", "ul", "video"];
      var BLOCK_LEVEL_TAGS_RE = new RegExp("^(".concat(BLOCK_LEVEL_TAGS.join("|"), ")$"), "i");
      var candidatesBlacklist = UNLIKELY_CANDIDATES_BLACKLIST.join("|");
      var CANDIDATES_BLACKLIST = new RegExp(candidatesBlacklist, "i");
      var candidatesWhitelist = UNLIKELY_CANDIDATES_WHITELIST.join("|");
      var CANDIDATES_WHITELIST = new RegExp(candidatesWhitelist, "i");
      function stripUnlikelyCandidates($2) {
        $2("*").not("a").each(function(index, node) {
          var $node = $2(node);
          var classes = $node.attr("class");
          var id = $node.attr("id");
          if (!id && !classes)
            return;
          var classAndId = "".concat(classes || "", " ").concat(id || "");
          if (CANDIDATES_WHITELIST.test(classAndId)) {
            return;
          }
          if (CANDIDATES_BLACKLIST.test(classAndId)) {
            $node.remove();
          }
        });
        return $2;
      }
      function brsToPs$$1($2) {
        var collapsing = false;
        $2("br").each(function(index, element) {
          var $element = $2(element);
          var nextElement = $element.next().get(0);
          if (nextElement && nextElement.tagName.toLowerCase() === "br") {
            collapsing = true;
            $element.remove();
          } else if (collapsing) {
            collapsing = false;
            paragraphize(element, $2, true);
          }
        });
        return $2;
      }
      function paragraphize(node, $2) {
        var br = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var $node = $2(node);
        if (br) {
          var sibling = node.nextSibling;
          var p = $2("<p></p>");
          while (sibling && !(sibling.tagName && BLOCK_LEVEL_TAGS_RE.test(sibling.tagName))) {
            var _sibling = sibling, nextSibling = _sibling.nextSibling;
            $2(sibling).appendTo(p);
            sibling = nextSibling;
          }
          $node.replaceWith(p);
          $node.remove();
          return $2;
        }
        return $2;
      }
      function convertDivs($2) {
        $2("div").each(function(index, div) {
          var $div = $2(div);
          var convertible = $div.children(DIV_TO_P_BLOCK_TAGS).length === 0;
          if (convertible) {
            convertNodeTo$$1($div, $2, "p");
          }
        });
        return $2;
      }
      function convertSpans($2) {
        $2("span").each(function(index, span) {
          var $span = $2(span);
          var convertible = $span.parents("p, div, li, figcaption").length === 0;
          if (convertible) {
            convertNodeTo$$1($span, $2, "p");
          }
        });
        return $2;
      }
      function convertToParagraphs$$1($2) {
        $2 = brsToPs$$1($2);
        $2 = convertDivs($2);
        $2 = convertSpans($2);
        return $2;
      }
      function convertNodeTo$$1($node, $2) {
        var tag = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "p";
        var node = $node.get(0);
        if (!node) {
          return $2;
        }
        var attrs = getAttrs(node) || {};
        var attribString = _Reflect$ownKeys(attrs).map(function(key) {
          return "".concat(key, "=").concat(attrs[key]);
        }).join(" ");
        var html;
        if ($2.browser) {
          html = node.tagName.toLowerCase() === "noscript" ? $node.text() : $node.html();
        } else {
          html = $node.contents();
        }
        $node.replaceWith("<".concat(tag, " ").concat(attribString, ">").concat(html, "</").concat(tag, ">"));
        return $2;
      }
      function cleanForHeight($img, $2) {
        var height = _parseInt($img.attr("height"), 10);
        var width = _parseInt($img.attr("width"), 10) || 20;
        if ((height || 20) < 10 || width < 10) {
          $img.remove();
        } else if (height) {
          $img.removeAttr("height");
        }
        return $2;
      }
      function removeSpacers($img, $2) {
        if (SPACER_RE.test($img.attr("src"))) {
          $img.remove();
        }
        return $2;
      }
      function cleanImages($article, $2) {
        $article.find("img").each(function(index, img) {
          var $img = $2(img);
          cleanForHeight($img, $2);
          removeSpacers($img, $2);
        });
        return $2;
      }
      function markToKeep(article, $2, url) {
        var tags = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
        if (tags.length === 0) {
          tags = KEEP_SELECTORS;
        }
        if (url) {
          var _URL$parse = URL.parse(url), protocol = _URL$parse.protocol, hostname = _URL$parse.hostname;
          tags = [].concat(_toConsumableArray(tags), ['iframe[src^="'.concat(protocol, "//").concat(hostname, '"]')]);
        }
        $2(tags.join(","), article).addClass(KEEP_CLASS);
        return $2;
      }
      function stripJunkTags(article, $2) {
        var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        if (tags.length === 0) {
          tags = STRIP_OUTPUT_TAGS;
        }
        $2(tags.join(","), article).not(".".concat(KEEP_CLASS)).remove();
        return $2;
      }
      function cleanHOnes$$1(article, $2) {
        var $hOnes = $2("h1", article);
        if ($hOnes.length < 3) {
          $hOnes.each(function(index, node) {
            return $2(node).remove();
          });
        } else {
          $hOnes.each(function(index, node) {
            convertNodeTo$$1($2(node), $2, "h2");
          });
        }
        return $2;
      }
      function removeAllButWhitelist($article, $2) {
        $article.find("*").each(function(index, node) {
          var attrs = getAttrs(node);
          setAttrs(node, _Reflect$ownKeys(attrs).reduce(function(acc, attr) {
            if (WHITELIST_ATTRS_RE.test(attr)) {
              return _objectSpread({}, acc, _defineProperty({}, attr, attrs[attr]));
            }
            return acc;
          }, {}));
        });
        $2(".".concat(KEEP_CLASS), $article).removeClass(KEEP_CLASS);
        return $article;
      }
      function cleanAttributes$$1($article, $2) {
        return removeAllButWhitelist($article.parent().length ? $article.parent() : $article, $2);
      }
      function removeEmpty($article, $2) {
        $article.find("p").each(function(index, p) {
          var $p = $2(p);
          if ($p.find("iframe, img").length === 0 && $p.text().trim() === "")
            $p.remove();
        });
        return $2;
      }
      var NON_TOP_CANDIDATE_TAGS$1 = ["br", "b", "i", "label", "hr", "area", "base", "basefont", "input", "img", "link", "meta"];
      var NON_TOP_CANDIDATE_TAGS_RE$1 = new RegExp("^(".concat(NON_TOP_CANDIDATE_TAGS$1.join("|"), ")$"), "i");
      var HNEWS_CONTENT_SELECTORS$1 = [[".hentry", ".entry-content"], ["entry", ".entry-content"], [".entry", ".entry_content"], [".post", ".postbody"], [".post", ".post_body"], [".post", ".post-body"]];
      var PHOTO_HINTS$1 = ["figure", "photo", "image", "caption"];
      var PHOTO_HINTS_RE$1 = new RegExp(PHOTO_HINTS$1.join("|"), "i");
      var POSITIVE_SCORE_HINTS$1 = [
        "article",
        "articlecontent",
        "instapaper_body",
        "blog",
        "body",
        "content",
        "entry-content-asset",
        "entry",
        "hentry",
        "main",
        "Normal",
        "page",
        "pagination",
        "permalink",
        "post",
        "story",
        "text",
        "[-_]copy",
        // usatoday
        "\\Bcopy"
      ];
      var POSITIVE_SCORE_RE$1 = new RegExp(POSITIVE_SCORE_HINTS$1.join("|"), "i");
      var READABILITY_ASSET$1 = new RegExp("entry-content-asset", "i");
      var NEGATIVE_SCORE_HINTS$1 = [
        "adbox",
        "advert",
        "author",
        "bio",
        "bookmark",
        "bottom",
        "byline",
        "clear",
        "com-",
        "combx",
        "comment",
        "comment\\B",
        "contact",
        "copy",
        "credit",
        "crumb",
        "date",
        "deck",
        "excerpt",
        "featured",
        // tnr.com has a featured_content which throws us off
        "foot",
        "footer",
        "footnote",
        "graf",
        "head",
        "info",
        "infotext",
        // newscientist.com copyright
        "instapaper_ignore",
        "jump",
        "linebreak",
        "link",
        "masthead",
        "media",
        "meta",
        "modal",
        "outbrain",
        // slate.com junk
        "promo",
        "pr_",
        // autoblog - press release
        "related",
        "respond",
        "roundcontent",
        // lifehacker restricted content warning
        "scroll",
        "secondary",
        "share",
        "shopping",
        "shoutbox",
        "side",
        "sidebar",
        "sponsor",
        "stamp",
        "sub",
        "summary",
        "tags",
        "tools",
        "widget"
      ];
      var NEGATIVE_SCORE_RE$1 = new RegExp(NEGATIVE_SCORE_HINTS$1.join("|"), "i");
      var PARAGRAPH_SCORE_TAGS$1 = new RegExp("^(p|li|span|pre)$", "i");
      var CHILD_CONTENT_TAGS$1 = new RegExp("^(td|blockquote|ol|ul|dl)$", "i");
      var BAD_TAGS$1 = new RegExp("^(address|form)$", "i");
      function getWeight(node) {
        var classes = node.attr("class");
        var id = node.attr("id");
        var score = 0;
        if (id) {
          if (POSITIVE_SCORE_RE$1.test(id)) {
            score += 25;
          }
          if (NEGATIVE_SCORE_RE$1.test(id)) {
            score -= 25;
          }
        }
        if (classes) {
          if (score === 0) {
            if (POSITIVE_SCORE_RE$1.test(classes)) {
              score += 25;
            }
            if (NEGATIVE_SCORE_RE$1.test(classes)) {
              score -= 25;
            }
          }
          if (PHOTO_HINTS_RE$1.test(classes)) {
            score += 10;
          }
          if (READABILITY_ASSET$1.test(classes)) {
            score += 25;
          }
        }
        return score;
      }
      function getScore($node) {
        return _parseFloat($node.attr("score")) || null;
      }
      function scoreCommas(text) {
        return (text.match(/,/g) || []).length;
      }
      var idkRe = new RegExp("^(p|pre)$", "i");
      function scoreLength(textLength2) {
        var tagName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "p";
        var chunks = textLength2 / 50;
        if (chunks > 0) {
          var lengthBonus;
          if (idkRe.test(tagName)) {
            lengthBonus = chunks - 2;
          } else {
            lengthBonus = chunks - 1.25;
          }
          return Math.min(Math.max(lengthBonus, 0), 3);
        }
        return 0;
      }
      function scoreParagraph$$1(node) {
        var score = 1;
        var text = node.text().trim();
        var textLength2 = text.length;
        if (textLength2 < 25) {
          return 0;
        }
        score += scoreCommas(text);
        score += scoreLength(textLength2);
        if (text.slice(-1) === ":") {
          score -= 1;
        }
        return score;
      }
      function setScore($node, $2, score) {
        $node.attr("score", score);
        return $node;
      }
      function addScore$$1($node, $2, amount) {
        try {
          var score = getOrInitScore$$1($node, $2) + amount;
          setScore($node, $2, score);
        } catch (e) {
        }
        return $node;
      }
      function addToParent$$1(node, $2, score) {
        var parent = node.parent();
        if (parent) {
          addScore$$1(parent, $2, score * 0.25);
        }
        return node;
      }
      function getOrInitScore$$1($node, $2) {
        var weightNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var score = getScore($node);
        if (score) {
          return score;
        }
        score = scoreNode$$1($node);
        if (weightNodes) {
          score += getWeight($node);
        }
        addToParent$$1($node, $2, score);
        return score;
      }
      function scoreNode$$1($node) {
        var _$node$get = $node.get(0), tagName = _$node$get.tagName;
        if (PARAGRAPH_SCORE_TAGS$1.test(tagName)) {
          return scoreParagraph$$1($node);
        }
        if (tagName.toLowerCase() === "div") {
          return 5;
        }
        if (CHILD_CONTENT_TAGS$1.test(tagName)) {
          return 3;
        }
        if (BAD_TAGS$1.test(tagName)) {
          return -3;
        }
        if (tagName.toLowerCase() === "th") {
          return -5;
        }
        return 0;
      }
      function convertSpans$1($node, $2) {
        if ($node.get(0)) {
          var _$node$get = $node.get(0), tagName = _$node$get.tagName;
          if (tagName === "span") {
            convertNodeTo$$1($node, $2, "div");
          }
        }
      }
      function addScoreTo($node, $2, score) {
        if ($node) {
          convertSpans$1($node, $2);
          addScore$$1($node, $2, score);
        }
      }
      function scorePs($2, weightNodes) {
        $2("p, pre").not("[score]").each(function(index, node) {
          var $node = $2(node);
          $node = setScore($node, $2, getOrInitScore$$1($node, $2, weightNodes));
          var $parent = $node.parent();
          var rawScore = scoreNode$$1($node);
          addScoreTo($parent, $2, rawScore, weightNodes);
          if ($parent) {
            addScoreTo($parent.parent(), $2, rawScore / 2, weightNodes);
          }
        });
        return $2;
      }
      function scoreContent$$1($2) {
        var weightNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        HNEWS_CONTENT_SELECTORS$1.forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), parentSelector = _ref2[0], childSelector = _ref2[1];
          $2("".concat(parentSelector, " ").concat(childSelector)).each(function(index, node) {
            addScore$$1($2(node).parent(parentSelector), $2, 80);
          });
        });
        scorePs($2, weightNodes);
        scorePs($2, weightNodes);
        return $2;
      }
      function mergeSiblings($candidate, topScore, $2) {
        if (!$candidate.parent().length) {
          return $candidate;
        }
        var siblingScoreThreshold = Math.max(10, topScore * 0.25);
        var wrappingDiv = $2("<div></div>");
        $candidate.parent().children().each(function(index, sibling) {
          var $sibling = $2(sibling);
          if (NON_TOP_CANDIDATE_TAGS_RE$1.test(sibling.tagName)) {
            return null;
          }
          var siblingScore = getScore($sibling);
          if (siblingScore) {
            if ($sibling.get(0) === $candidate.get(0)) {
              wrappingDiv.append($sibling);
            } else {
              var contentBonus = 0;
              var density = linkDensity($sibling);
              if (density < 0.05) {
                contentBonus += 20;
              }
              if (density >= 0.5) {
                contentBonus -= 20;
              }
              if ($sibling.attr("class") === $candidate.attr("class")) {
                contentBonus += topScore * 0.2;
              }
              var newScore = siblingScore + contentBonus;
              if (newScore >= siblingScoreThreshold) {
                return wrappingDiv.append($sibling);
              }
              if (sibling.tagName === "p") {
                var siblingContent = $sibling.text();
                var siblingContentLength = textLength(siblingContent);
                if (siblingContentLength > 80 && density < 0.25) {
                  return wrappingDiv.append($sibling);
                }
                if (siblingContentLength <= 80 && density === 0 && hasSentenceEnd(siblingContent)) {
                  return wrappingDiv.append($sibling);
                }
              }
            }
          }
          return null;
        });
        if (wrappingDiv.children().length === 1 && wrappingDiv.children().first().get(0) === $candidate.get(0)) {
          return $candidate;
        }
        return wrappingDiv;
      }
      function findTopCandidate$$1($2) {
        var $candidate;
        var topScore = 0;
        $2("[score]").each(function(index, node) {
          if (NON_TOP_CANDIDATE_TAGS_RE$1.test(node.tagName)) {
            return;
          }
          var $node = $2(node);
          var score = getScore($node);
          if (score > topScore) {
            topScore = score;
            $candidate = $node;
          }
        });
        if (!$candidate) {
          return $2("body") || $2("*").first();
        }
        $candidate = mergeSiblings($candidate, topScore, $2);
        return $candidate;
      }
      function removeUnlessContent($node, $2, weight) {
        if ($node.hasClass("entry-content-asset")) {
          return;
        }
        var content = normalizeSpaces($node.text());
        if (scoreCommas(content) < 10) {
          var pCount = $2("p", $node).length;
          var inputCount = $2("input", $node).length;
          if (inputCount > pCount / 3) {
            $node.remove();
            return;
          }
          var contentLength = content.length;
          var imgCount = $2("img", $node).length;
          if (contentLength < 25 && imgCount === 0) {
            $node.remove();
            return;
          }
          var density = linkDensity($node);
          if (weight < 25 && density > 0.2 && contentLength > 75) {
            $node.remove();
            return;
          }
          if (weight >= 25 && density > 0.5) {
            var tagName = $node.get(0).tagName.toLowerCase();
            var nodeIsList = tagName === "ol" || tagName === "ul";
            if (nodeIsList) {
              var previousNode = $node.prev();
              if (previousNode && normalizeSpaces(previousNode.text()).slice(-1) === ":") {
                return;
              }
            }
            $node.remove();
            return;
          }
          var scriptCount = $2("script", $node).length;
          if (scriptCount > 0 && contentLength < 150) {
            $node.remove();
          }
        }
      }
      function cleanTags$$1($article, $2) {
        $2(CLEAN_CONDITIONALLY_TAGS, $article).each(function(index, node) {
          var $node = $2(node);
          if ($node.hasClass(KEEP_CLASS) || $node.find(".".concat(KEEP_CLASS)).length > 0)
            return;
          var weight = getScore($node);
          if (!weight) {
            weight = getOrInitScore$$1($node, $2);
            setScore($node, $2, weight);
          }
          if (weight < 0) {
            $node.remove();
          } else {
            removeUnlessContent($node, $2, weight);
          }
        });
        return $2;
      }
      function cleanHeaders($article, $2) {
        var title = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        $2(HEADER_TAG_LIST, $article).each(function(index, header) {
          var $header = $2(header);
          if ($2($header, $article).prevAll("p").length === 0) {
            return $header.remove();
          }
          if (normalizeSpaces($2(header).text()) === title) {
            return $header.remove();
          }
          if (getWeight($2(header)) < 0) {
            return $header.remove();
          }
          return $header;
        });
        return $2;
      }
      function rewriteTopLevel$$1(article, $2) {
        $2 = convertNodeTo$$1($2("html"), $2, "div");
        $2 = convertNodeTo$$1($2("body"), $2, "div");
        return $2;
      }
      function absolutize($2, rootUrl, attr) {
        var baseUrl = $2("base").attr("href");
        $2("[".concat(attr, "]")).each(function(_, node) {
          var attrs = getAttrs(node);
          var url = attrs[attr];
          if (!url)
            return;
          var absoluteUrl = URL.resolve(baseUrl || rootUrl, url);
          setAttr(node, attr, absoluteUrl);
        });
      }
      function absolutizeSet($2, rootUrl, $content) {
        $2("[srcset]", $content).each(function(_, node) {
          var attrs = getAttrs(node);
          var urlSet = attrs.srcset;
          if (urlSet) {
            var candidates = urlSet.match(/(?:\s*)(\S+(?:\s*[\d.]+[wx])?)(?:\s*,\s*)?/g);
            if (!candidates)
              return;
            var absoluteCandidates = candidates.map(function(candidate) {
              var parts = candidate.trim().replace(/,$/, "").split(/\s+/);
              parts[0] = URL.resolve(rootUrl, parts[0]);
              return parts.join(" ");
            });
            var absoluteUrlSet = _toConsumableArray(new _Set(absoluteCandidates)).join(", ");
            setAttr(node, "srcset", absoluteUrlSet);
          }
        });
      }
      function makeLinksAbsolute$$1($content, $2, url) {
        ["href", "src"].forEach(function(attr) {
          return absolutize($2, url, attr);
        });
        absolutizeSet($2, url, $content);
        return $content;
      }
      function textLength(text) {
        return text.trim().replace(/\s+/g, " ").length;
      }
      function linkDensity($node) {
        var totalTextLength = textLength($node.text());
        var linkText = $node.find("a").text();
        var linkLength = textLength(linkText);
        if (totalTextLength > 0) {
          return linkLength / totalTextLength;
        }
        if (totalTextLength === 0 && linkLength > 0) {
          return 1;
        }
        return 0;
      }
      function extractFromMeta$$1($2, metaNames, cachedNames) {
        var cleanTags = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        var foundNames = metaNames.filter(function(name) {
          return cachedNames.indexOf(name) !== -1;
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          var _loop = function _loop2() {
            var name = _step.value;
            var type = "name";
            var value = "value";
            var nodes = $2("meta[".concat(type, '="').concat(name, '"]'));
            var values = nodes.map(function(index, node) {
              return $2(node).attr(value);
            }).toArray().filter(function(text) {
              return text !== "";
            });
            if (values.length === 1) {
              var metaValue;
              if (cleanTags) {
                metaValue = stripTags(values[0], $2);
              } else {
                var _values = _slicedToArray(values, 1);
                metaValue = _values[0];
              }
              return {
                v: metaValue
              };
            }
          };
          for (var _iterator = _getIterator(foundNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ret = _loop();
            if (_typeof(_ret) === "object")
              return _ret.v;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return null;
      }
      function isGoodNode($node, maxChildren) {
        if ($node.children().length > maxChildren) {
          return false;
        }
        if (withinComment$$1($node)) {
          return false;
        }
        return true;
      }
      function extractFromSelectors$$1($2, selectors) {
        var maxChildren = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var textOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = _getIterator(selectors), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var selector = _step.value;
            var nodes = $2(selector);
            if (nodes.length === 1) {
              var $node = $2(nodes[0]);
              if (isGoodNode($node, maxChildren)) {
                var content = void 0;
                if (textOnly) {
                  content = $node.text();
                } else {
                  content = $node.html();
                }
                if (content) {
                  return content;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        return null;
      }
      function stripTags(text, $2) {
        var cleanText = $2("<span>".concat(text, "</span>")).text();
        return cleanText === "" ? text : cleanText;
      }
      function withinComment$$1($node) {
        var parents = $node.parents().toArray();
        var commentParent = parents.find(function(parent) {
          var attrs = getAttrs(parent);
          var nodeClass = attrs.class, id = attrs.id;
          var classAndId = "".concat(nodeClass, " ").concat(id);
          return classAndId.includes("comment");
        });
        return commentParent !== void 0;
      }
      function nodeIsSufficient($node) {
        return $node.text().trim().length >= 100;
      }
      function isWordpress($2) {
        return $2(IS_WP_SELECTOR).length > 0;
      }
      function getAttrs(node) {
        var attribs = node.attribs, attributes = node.attributes;
        if (!attribs && attributes) {
          var attrs = _Reflect$ownKeys(attributes).reduce(function(acc, index) {
            var attr = attributes[index];
            if (!attr.name || !attr.value)
              return acc;
            acc[attr.name] = attr.value;
            return acc;
          }, {});
          return attrs;
        }
        return attribs;
      }
      function setAttr(node, attr, val) {
        if (node.attribs) {
          node.attribs[attr] = val;
        } else if (node.attributes) {
          node.setAttribute(attr, val);
        }
        return node;
      }
      function setAttrs(node, attrs) {
        if (node.attribs) {
          node.attribs = attrs;
        } else if (node.attributes) {
          while (node.attributes.length > 0) {
            node.removeAttribute(node.attributes[0].name);
          }
          _Reflect$ownKeys(attrs).forEach(function(key) {
            node.setAttribute(key, attrs[key]);
          });
        }
        return node;
      }
      var IS_LINK = new RegExp("https?://", "i");
      var IMAGE_RE = ".(png|gif|jpe?g)";
      var IS_IMAGE = new RegExp("".concat(IMAGE_RE), "i");
      var IS_SRCSET = new RegExp("".concat(IMAGE_RE, "(\\?\\S+)?(\\s*[\\d.]+[wx])"), "i");
      var TAGS_TO_REMOVE = ["script", "style", "form"].join(",");
      function convertLazyLoadedImages($2) {
        var extractSrcFromJSON = function extractSrcFromJSON2(str) {
          try {
            var _JSON$parse = JSON.parse(str), src = _JSON$parse.src;
            if (typeof src === "string")
              return src;
          } catch (e) {
            return false;
          }
          return false;
        };
        $2("img").each(function(_, img) {
          var attrs = getAttrs(img);
          _Reflect$ownKeys(attrs).forEach(function(attr) {
            var value = attrs[attr];
            if (attr !== "srcset" && IS_LINK.test(value) && IS_SRCSET.test(value)) {
              $2(img).attr("srcset", value);
            } else if (attr !== "src" && attr !== "srcset" && IS_LINK.test(value) && IS_IMAGE.test(value)) {
              var existingSrc = extractSrcFromJSON(value);
              if (existingSrc) {
                $2(img).attr("src", existingSrc);
              } else {
                $2(img).attr("src", value);
              }
            }
          });
        });
        return $2;
      }
      function isComment(index, node) {
        return node.type === "comment";
      }
      function cleanComments($2) {
        $2.root().find("*").contents().filter(isComment).remove();
        return $2;
      }
      function clean($2) {
        $2(TAGS_TO_REMOVE).remove();
        $2 = cleanComments($2);
        return $2;
      }
      var Resource = {
        // Create a Resource.
        //
        // :param url: The URL for the document we should retrieve.
        // :param response: If set, use as the response rather than
        //                  attempting to fetch it ourselves. Expects a
        //                  string.
        // :param headers: Custom headers to be included in the request
        create: function() {
          var _create = _asyncToGenerator(
            /* @__PURE__ */ _regeneratorRuntime.mark(function _callee(url, preparedResponse, parsedUrl) {
              var headers, result2, validResponse, _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      headers = _args.length > 3 && _args[3] !== void 0 ? _args[3] : {};
                      if (!preparedResponse) {
                        _context.next = 6;
                        break;
                      }
                      validResponse = {
                        statusMessage: "OK",
                        statusCode: 200,
                        headers: {
                          "content-type": "text/html",
                          "content-length": 500
                        }
                      };
                      result2 = {
                        body: preparedResponse,
                        response: validResponse,
                        alreadyDecoded: true
                      };
                      _context.next = 9;
                      break;
                    case 6:
                      _context.next = 8;
                      return fetchResource(url, parsedUrl, headers);
                    case 8:
                      result2 = _context.sent;
                    case 9:
                      if (!result2.error) {
                        _context.next = 12;
                        break;
                      }
                      result2.failed = true;
                      return _context.abrupt("return", result2);
                    case 12:
                      return _context.abrupt("return", this.generateDoc(result2));
                    case 13:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            })
          );
          function create(_x, _x2, _x3) {
            return _create.apply(this, arguments);
          }
          return create;
        }(),
        generateDoc: function generateDoc(_ref) {
          var content = _ref.body, response = _ref.response, _ref$alreadyDecoded = _ref.alreadyDecoded, alreadyDecoded = _ref$alreadyDecoded === void 0 ? false : _ref$alreadyDecoded;
          var _response$headers$con = response.headers["content-type"], contentType = _response$headers$con === void 0 ? "" : _response$headers$con;
          if (!contentType.includes("html") && !contentType.includes("text")) {
            throw new Error("Content does not appear to be text.");
          }
          var $2 = this.encodeDoc({
            content,
            contentType,
            alreadyDecoded
          });
          if ($2.root().children().length === 0) {
            throw new Error("No children, likely a bad parse.");
          }
          $2 = normalizeMetaTags($2);
          $2 = convertLazyLoadedImages($2);
          $2 = clean($2);
          return $2;
        },
        encodeDoc: function encodeDoc(_ref2) {
          var content = _ref2.content, contentType = _ref2.contentType, _ref2$alreadyDecoded = _ref2.alreadyDecoded, alreadyDecoded = _ref2$alreadyDecoded === void 0 ? false : _ref2$alreadyDecoded;
          if (alreadyDecoded) {
            return cheerio.load(content);
          }
          var encoding = getEncoding(contentType);
          var decodedContent = iconv2.decode(content, encoding);
          var $2 = cheerio.load(decodedContent);
          var contentTypeSelector = cheerio.browser ? "meta[http-equiv=content-type]" : "meta[http-equiv=content-type i]";
          var metaContentType = $2(contentTypeSelector).attr("content") || $2("meta[charset]").attr("charset");
          var properEncoding = getEncoding(metaContentType);
          if (metaContentType && properEncoding !== encoding) {
            decodedContent = iconv2.decode(content, properEncoding);
            $2 = cheerio.load(decodedContent);
          }
          return $2;
        }
      };
      var _marked = /* @__PURE__ */ _regeneratorRuntime.mark(range);
      function range() {
        var start, end, _args = arguments;
        return _regeneratorRuntime.wrap(function range$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                start = _args.length > 0 && _args[0] !== void 0 ? _args[0] : 1;
                end = _args.length > 1 && _args[1] !== void 0 ? _args[1] : 1;
              case 2:
                if (!(start <= end)) {
                  _context.next = 7;
                  break;
                }
                _context.next = 5;
                return start += 1;
              case 5:
                _context.next = 2;
                break;
              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _marked, this);
      }
      function validateUrl(_ref) {
        var hostname = _ref.hostname;
        return !!hostname;
      }
      var merge = function merge2(extractor, domains) {
        return domains.reduce(function(acc, domain) {
          acc[domain] = extractor;
          return acc;
        }, {});
      };
      function mergeSupportedDomains(extractor) {
        return extractor.supportedDomains ? merge(extractor, [extractor.domain].concat(_toConsumableArray(extractor.supportedDomains))) : merge(extractor, [extractor.domain]);
      }
      var apiExtractors = {};
      function addExtractor(extractor) {
        if (!extractor || !extractor.domain) {
          return {
            error: true,
            message: "Unable to add custom extractor. Invalid parameters."
          };
        }
        _Object$assign(apiExtractors, mergeSupportedDomains(extractor));
        return apiExtractors;
      }
      var BloggerExtractor = {
        domain: "blogspot.com",
        content: {
          // Blogger is insane and does not load its content
          // initially in the page, but it's all there
          // in noscript
          selectors: [".post-content noscript"],
          // Selectors to remove from the extracted content
          clean: [],
          // Convert the noscript tag to a div
          transforms: {
            noscript: "div"
          }
        },
        author: {
          selectors: [".post-author-name"]
        },
        title: {
          selectors: [".post h2.title"]
        },
        date_published: {
          selectors: ["span.publishdate"]
        }
      };
      var NYMagExtractor = {
        domain: "nymag.com",
        content: {
          // Order by most likely. Extractor will stop on first occurrence
          selectors: ["div.article-content", "section.body", "article.article"],
          // Selectors to remove from the extracted content
          clean: [".ad", ".single-related-story"],
          // Object of tranformations to make on matched elements
          // Each key is the selector, each value is the tag to
          // transform to.
          // If a function is given, it should return a string
          // to convert to or nothing (in which case it will not perform
          // the transformation.
          transforms: {
            // Convert h1s to h2s
            h1: "h2",
            // Convert lazy-loaded noscript images to figures
            noscript: function noscript($node, $2) {
              var $children = $2.browser ? $2($node.text()) : $node.children();
              if ($children.length === 1 && $children.get(0) !== void 0 && $children.get(0).tagName.toLowerCase() === "img") {
                return "figure";
              }
              return null;
            }
          }
        },
        title: {
          selectors: ["h1.lede-feature-title", "h1.headline-primary", "h1"]
        },
        author: {
          selectors: [".by-authors", ".lede-feature-author"]
        },
        dek: {
          selectors: [".lede-feature-teaser"]
        },
        date_published: {
          selectors: [["time.article-timestamp[datetime]", "datetime"], "time.article-timestamp"]
        }
      };
      var WikipediaExtractor = {
        domain: "wikipedia.org",
        content: {
          selectors: ["#mw-content-text"],
          defaultCleaner: false,
          // transform top infobox to an image with caption
          transforms: {
            ".infobox img": function infoboxImg($node) {
              var $parent = $node.parents(".infobox");
              if ($parent.children("img").length === 0) {
                $parent.prepend($node);
              }
            },
            ".infobox caption": "figcaption",
            ".infobox": "figure"
          },
          // Selectors to remove from the extracted content
          clean: [".mw-editsection", "figure tr, figure td, figure tbody", "#toc", ".navbox"]
        },
        author: "Wikipedia Contributors",
        title: {
          selectors: ["h2.title"]
        },
        date_published: {
          selectors: ["#footer-info-lastmod"]
        }
      };
      var TwitterExtractor = {
        domain: "twitter.com",
        content: {
          transforms: {
            // We're transforming essentially the whole page here.
            // Twitter doesn't have nice selectors, so our initial
            // selector grabs the whole page, then we're re-writing
            // it to fit our needs before we clean it up.
            ".permalink[role=main]": function permalinkRoleMain($node, $2) {
              var tweets = $node.find(".tweet");
              var $tweetContainer = $2('<div id="TWEETS_GO_HERE"></div>');
              $tweetContainer.append(tweets);
              $node.replaceWith($tweetContainer);
            },
            // Twitter wraps @ with s, which
            // renders as a strikethrough
            s: "span"
          },
          selectors: [".permalink[role=main]"],
          defaultCleaner: false,
          clean: [".stream-item-footer", "button", ".tweet-details-fixer"]
        },
        author: {
          selectors: [".tweet.permalink-tweet .username"]
        },
        date_published: {
          selectors: [[".permalink-tweet ._timestamp[data-time-ms]", "data-time-ms"]]
        }
      };
      var NYTimesExtractor = {
        domain: "www.nytimes.com",
        title: {
          selectors: ["h1.g-headline", 'h1[itemprop="headline"]', "h1.headline", "h1 .balancedHeadline"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"], ".g-byline", ".byline", ['meta[name="byl"]', "value"]]
        },
        content: {
          selectors: ["div.g-blocks", 'section[name="articleBody"]', "article#story"],
          transforms: {
            "img.g-lazy": function imgGLazy($node) {
              var src = $node.attr("src");
              var width = 640;
              src = src.replace("{{size}}", width);
              $node.attr("src", src);
            }
          },
          clean: [".ad", "header#story-header", ".story-body-1 .lede.video", ".visually-hidden", "#newsletter-promo", ".promo", ".comments-button", ".hidden", ".comments", ".supplemental", ".nocontent", ".story-footer-links"]
        },
        date_published: {
          selectors: [['meta[name="article:published"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: null,
        next_page_url: null,
        excerpt: null
      };
      var TheAtlanticExtractor = {
        domain: "www.theatlantic.com",
        title: {
          selectors: ["h1", ".c-article-header__hed"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"], ".c-byline__author"]
        },
        content: {
          selectors: ["article", ".article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".partner-box", ".callout", ".c-article-writer__image", ".c-article-writer__content", ".c-letters-cta__text", ".c-footer__logo", ".c-recirculation-link", ".twitter-tweet"]
        },
        dek: {
          selectors: [['meta[name="description"]', "value"]]
        },
        date_published: {
          selectors: [['time[itemprop="datePublished"]', "datetime"]]
        },
        lead_image_url: {
          selectors: [['img[itemprop="url"]', "src"]]
        },
        next_page_url: null,
        excerpt: null
      };
      var NewYorkerExtractor = {
        domain: "www.newyorker.com",
        title: {
          selectors: ['h1[class^="content-header"]', 'h1[class^="ArticleHeader__hed"]', ['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="author"]', "value"], 'div[class^="ArticleContributors"] a[rel="author"]', 'article header div[class*="Byline__multipleContributors"]']
        },
        content: {
          selectors: ["article.article.main-content", 'main[class^="Layout__content"]'],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ['footer[class^="ArticleFooter__footer"]']
        },
        date_published: {
          selectors: ["time.content-header__publish-date", ['meta[name="pubdate"]', "value"]],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: ["div.content-header__dek", 'h2[class^="ArticleHeader__dek"]']
        },
        next_page_url: null,
        excerpt: null
      };
      var WiredExtractor = {
        domain: "www.wired.com",
        title: {
          selectors: ["h1.content-header__hed", "h1.post-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"], 'a[rel="author"]']
        },
        content: {
          selectors: ["article.article.main-content", "article.content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".visually-hidden", "figcaption img.photo"]
        },
        date_published: {
          selectors: ["time.content-header__publish-date", ['meta[itemprop="datePublished"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: []
        },
        next_page_url: null,
        excerpt: null
      };
      var MSNExtractor = {
        domain: "www.msn.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: ["span.authorname-txt"]
        },
        content: {
          selectors: ["div.richtext"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["span.caption"]
        },
        date_published: {
          selectors: ["span.time"]
        },
        lead_image_url: {
          selectors: []
        },
        dek: {
          selectors: []
        },
        next_page_url: null,
        excerpt: null
      };
      var YahooExtractor = {
        domain: "www.yahoo.com",
        title: {
          selectors: ["header.canvas-header"]
        },
        author: {
          selectors: ["span.provider-name"]
        },
        content: {
          selectors: [
            // enter content selectors
            ".content-canvas"
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".figure-caption"]
        },
        date_published: {
          selectors: [["time.date[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: [
            // enter dek selectors
          ]
        },
        next_page_url: null,
        excerpt: null
      };
      var BuzzfeedExtractor = {
        domain: "www.buzzfeed.com",
        title: {
          selectors: ['h1[id="post-title"]']
        },
        author: {
          selectors: ['a[data-action="user/username"]', "byline__author"]
        },
        content: {
          selectors: [[".longform_custom_header_media", "#buzz_sub_buzz"], "#buzz_sub_buzz"],
          defaultCleaner: false,
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            h2: "b",
            "div.longform_custom_header_media": function divLongform_custom_header_media($node) {
              if ($node.has("img") && $node.has(".longform_header_image_source")) {
                return "figure";
              }
              return null;
            },
            "figure.longform_custom_header_media .longform_header_image_source": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".instapaper_ignore", ".suplist_list_hide .buzz_superlist_item .buzz_superlist_number_inline", ".share-box", ".print"]
        },
        date_published: {
          selectors: [".buzz-datetime"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: []
        },
        next_page_url: null,
        excerpt: null
      };
      var WikiaExtractor = {
        domain: "fandom.wikia.com",
        title: {
          selectors: ["h1.entry-title"]
        },
        author: {
          selectors: [".author vcard", ".fn"]
        },
        content: {
          selectors: [".grid-content", ".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: []
        },
        next_page_url: null,
        excerpt: null
      };
      var LittleThingsExtractor = {
        domain: "www.littlethings.com",
        title: {
          selectors: ["h1.post-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        content: {
          selectors: [
            // enter content selectors
            ".mainContentIntro",
            ".content-wrapper"
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        next_page_url: null,
        excerpt: null
      };
      var PoliticoExtractor = {
        domain: "www.politico.com",
        title: {
          selectors: [
            // enter title selectors
            ['meta[name="og:title"]', "value"]
          ]
        },
        author: {
          selectors: [".story-main-content .byline .vcard"]
        },
        content: {
          selectors: [
            // enter content selectors
            ".story-main-content",
            ".content-group",
            ".story-core",
            ".story-text"
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: [],
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["figcaption"]
        },
        date_published: {
          selectors: [[".story-main-content .timestamp time[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [
            // enter lead_image_url selectors
            ['meta[name="og:image"]', "value"]
          ]
        },
        dek: {
          selectors: []
        },
        next_page_url: null,
        excerpt: null
      };
      var DeadspinExtractor = {
        domain: "deadspin.com",
        supportedDomains: ["jezebel.com", "lifehacker.com", "kotaku.com", "gizmodo.com", "jalopnik.com", "kinja.com", "avclub.com", "clickhole.com", "splinternews.com", "theonion.com", "theroot.com", "thetakeout.com", "theinventory.com"],
        title: {
          selectors: ["h1.headline"]
        },
        author: {
          selectors: [".author"]
        },
        content: {
          selectors: [".post-content", ".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            'iframe.lazyload[data-recommend-id^="youtube://"]': function iframeLazyloadDataRecommendIdYoutube($node) {
              var youtubeId = $node.attr("id").split("youtube-")[1];
              $node.attr("src", "https://www.youtube.com/embed/".concat(youtubeId));
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".magnifier", ".lightbox"]
        },
        date_published: {
          selectors: [["time.updated[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        next_page_url: {
          selectors: [
            // enter selectors
          ]
        },
        excerpt: {
          selectors: [
            // enter selectors
          ]
        }
      };
      var BroadwayWorldExtractor = {
        domain: "www.broadwayworld.com",
        title: {
          selectors: ["h1.article-title"]
        },
        author: {
          selectors: ["span[itemprop=author]"]
        },
        content: {
          selectors: ["div[itemprop=articlebody]"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        },
        date_published: {
          selectors: [["meta[itemprop=datePublished]", "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: []
        },
        next_page_url: {
          selectors: [
            // enter selectors
          ]
        },
        excerpt: {
          selectors: [
            // enter selectors
          ]
        }
      };
      var ApartmentTherapyExtractor = {
        domain: "www.apartmenttherapy.com",
        title: {
          selectors: ["h1.headline"]
        },
        author: {
          selectors: [".PostByline__name"]
        },
        content: {
          selectors: ["div.post__content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            'div[data-render-react-id="images/LazyPicture"]': function divDataRenderReactIdImagesLazyPicture($node, $2) {
              var data = JSON.parse($node.attr("data-props"));
              var src = data.sources[0].src;
              var $img = $2("<img />").attr("src", src);
              $node.replaceWith($img);
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        },
        date_published: {
          selectors: [[".PostByline__timestamp[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: {
          selectors: []
        },
        next_page_url: {
          selectors: [
            // enter selectors
          ]
        },
        excerpt: {
          selectors: [
            // enter selectors
          ]
        }
      };
      var MediumExtractor = {
        domain: "medium.com",
        title: {
          selectors: ["h1", ['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        content: {
          selectors: ["article"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            // Allow drop cap character.
            "section span:first-of-type": function sectionSpanFirstOfType($node) {
              var $text = $node.html();
              if ($text.length === 1 && /^[a-zA-Z()]+$/.test($text)) {
                $node.replaceWith($text);
              }
            },
            // Re-write lazy-loaded youtube videos
            iframe: function iframe($node) {
              var ytRe = /https:\/\/i.embed.ly\/.+url=https:\/\/i\.ytimg\.com\/vi\/(\w+)\//;
              var thumb = decodeURIComponent($node.attr("data-thumbnail"));
              var $parent = $node.parents("figure");
              if (ytRe.test(thumb)) {
                var _thumb$match = thumb.match(ytRe), _thumb$match2 = _slicedToArray(_thumb$match, 2), _ = _thumb$match2[0], youtubeId = _thumb$match2[1];
                $node.attr("src", "https://www.youtube.com/embed/".concat(youtubeId));
                var $caption = $parent.find("figcaption");
                $parent.empty().append([$node, $caption]);
                return;
              }
              $parent.remove();
            },
            // rewrite figures to pull out image and caption, remove rest
            figure: function figure($node) {
              if ($node.find("iframe").length > 0)
                return;
              var $img = $node.find("img").slice(-1)[0];
              var $caption = $node.find("figcaption");
              $node.empty().append([$img, $caption]);
            },
            // Remove any smaller images that did not get caught by the generic image
            // cleaner (author photo 48px, leading sentence images 79px, etc.).
            img: function img($node) {
              var width = _parseInt($node.attr("width"), 10);
              if (width < 100)
                $node.remove();
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["span a", "svg"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        dek: null,
        next_page_url: {
          selectors: [
            // enter selectors
          ]
        },
        excerpt: {
          selectors: [
            // enter selectors
          ]
        }
      };
      var WwwTmzComExtractor = {
        domain: "www.tmz.com",
        title: {
          selectors: [".post-title-breadcrumb", "h1", ".headline"]
        },
        author: "TMZ STAFF",
        date_published: {
          selectors: [".article-posted-date"],
          timezone: "America/Los_Angeles"
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-content", ".all-post-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".lightbox-link"]
        }
      };
      var WwwWashingtonpostComExtractor = {
        domain: "www.washingtonpost.com",
        title: {
          selectors: ["h1", "#topper-headline-wrapper"]
        },
        author: {
          selectors: [".pb-author-name"]
        },
        date_published: {
          selectors: [['.author-timestamp[itemprop="datePublished"]', "content"]]
        },
        dek: {
          selectors: []
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "div.inline-content": function divInlineContent($node) {
              if ($node.has("img,iframe,video").length > 0) {
                return "figure";
              }
              $node.remove();
              return null;
            },
            ".pb-caption": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".interstitial-link", ".newsletter-inline-unit"]
        }
      };
      var WwwHuffingtonpostComExtractor = {
        domain: "www.huffingtonpost.com",
        title: {
          selectors: ["h1.headline__title"]
        },
        author: {
          selectors: ["span.author-card__details__name"]
        },
        date_published: {
          selectors: [['meta[name="article:modified_time"]', "value"], ['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.headline__subtitle"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.entry__body"],
          defaultCleaner: false,
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".pull-quote", ".tag-cloud", ".embed-asset", ".below-entry", ".entry-corrections", "#suggested-story"]
        }
      };
      var NewrepublicComExtractor = {
        domain: "newrepublic.com",
        title: {
          selectors: ["h1.article-headline", ".minutes-primary h1.minute-title"]
        },
        author: {
          selectors: ["div.author-list", ".minutes-primary h3.minute-byline"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]],
          timezone: "America/New_York"
        },
        dek: {
          selectors: ["h2.article-subhead"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".article-cover", "div.content-body"], [".minute-image", ".minutes-primary div.content-body"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["aside"]
        }
      };
      var MoneyCnnComExtractor = {
        domain: "money.cnn.com",
        title: {
          selectors: [".article-title"]
        },
        author: {
          selectors: [".byline a"]
        },
        date_published: {
          selectors: [['meta[name="date"]', "value"]],
          timezone: "GMT"
        },
        dek: {
          selectors: ["#storytext h2"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#storytext"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".inStoryHeading"]
        }
      };
      var WwwThevergeComExtractor = {
        domain: "www.theverge.com",
        supportedDomains: ["www.polygon.com"],
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.p-dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [
            // feature template multi-match
            [".c-entry-hero .e-image", ".c-entry-intro", ".c-entry-content"],
            // regular post multi-match
            [".e-image--hero", ".c-entry-content"],
            // feature template fallback
            ".l-wrapper .l-feature",
            // regular post fallback
            "div.c-entry-content"
          ],
          // Transform lazy-loaded images
          transforms: {
            noscript: function noscript($node) {
              var $children = $node.children();
              if ($children.length === 1 && $children.get(0).tagName === "img") {
                return "span";
              }
              return null;
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".aside", "img.c-dynamic-image"]
        }
      };
      var WwwCnnComExtractor = {
        domain: "www.cnn.com",
        title: {
          selectors: ["h1.pg-headline", "h1"]
        },
        author: {
          selectors: [".metadata__byline__author"]
        },
        date_published: {
          selectors: [['meta[name="pubdate"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [
            // a more specific selector to grab the lead image and the body
            [".media__video--thumbnail", ".zn-body-text"],
            // a fallback for the above
            ".zn-body-text",
            'div[itemprop="articleBody"]'
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".zn-body__paragraph, .el__leafmedia--sourced-paragraph": function znBody__paragraphEl__leafmediaSourcedParagraph($node) {
              var $text = $node.html();
              if ($text) {
                return "p";
              }
              return null;
            },
            // this transform cleans the short, all-link sections linking
            // to related content but not marked as such in any way.
            ".zn-body__paragraph": function znBody__paragraph($node) {
              if ($node.has("a")) {
                if ($node.text().trim() === $node.find("a").text().trim()) {
                  $node.remove();
                }
              }
            },
            ".media__video--thumbnail": "figure"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwAolComExtractor = {
        domain: "www.aol.com",
        title: {
          selectors: ["h1.p-article__title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [".p-article__byline__date"],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwYoutubeComExtractor = {
        domain: "www.youtube.com",
        title: {
          selectors: [".watch-title", "h1.watch-title-container"]
        },
        author: {
          selectors: [".yt-user-info"]
        },
        date_published: {
          selectors: [['meta[itemProp="datePublished"]', "value"]],
          timezone: "GMT"
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          defaultCleaner: false,
          selectors: [["#player-api", "#eow-description"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "#player-api": function playerApi($node, $2) {
              var videoId = $2('meta[itemProp="videoId"]').attr("value");
              $node.html('\n          <iframe src="https://www.youtube.com/embed/'.concat(videoId, '" frameborder="0" allowfullscreen></iframe>'));
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwTheguardianComExtractor = {
        domain: "www.theguardian.com",
        title: {
          selectors: [".content__headline"]
        },
        author: {
          selectors: ["p.byline"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".content__standfirst"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".content__article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".hide-on-mobile", ".inline-icon"]
        }
      };
      var WwwSbnationComExtractor = {
        domain: "www.sbnation.com",
        title: {
          selectors: ["h1.c-page-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.c-entry-summary.p-dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.c-entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwBloombergComExtractor = {
        domain: "www.bloomberg.com",
        title: {
          selectors: [
            // normal articles
            ".lede-headline",
            // /graphics/ template
            "h1.article-title",
            // /news/ template
            "h1.lede-text-only__hed"
          ]
        },
        author: {
          selectors: [
            ['meta[name="parsely-author"]', "value"],
            ".byline-details__link",
            // /graphics/ template
            ".bydek",
            // /news/ template
            ".author"
          ]
        },
        date_published: {
          selectors: [["time.published-at", "datetime"], ["time[datetime]", "datetime"], ['meta[name="date"]', "value"], ['meta[name="parsely-pub-date"]', "value"]]
        },
        dek: {
          selectors: []
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [
            ".article-body__content",
            // /graphics/ template
            ["section.copy-block"],
            // /news/ template
            ".body-copy"
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".inline-newsletter", ".page-ad"]
        }
      };
      var WwwBustleComExtractor = {
        domain: "www.bustle.com",
        title: {
          selectors: ["h1.post-page__title"]
        },
        author: {
          selectors: ["div.content-meta__author"]
        },
        date_published: {
          selectors: [["time.content-meta__published-date[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".post-page__body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwNprOrgExtractor = {
        domain: "www.npr.org",
        title: {
          selectors: ["h1", ".storytitle"]
        },
        author: {
          selectors: ["p.byline__name.byline__name--block"]
        },
        date_published: {
          selectors: [[".dateblock time[datetime]", "datetime"], ['meta[name="date"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"], ['meta[name="twitter:image:src"]', "value"]]
        },
        content: {
          selectors: [".storytext"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".bucketwrap.image": "figure",
            ".bucketwrap.image .credit-caption": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["div.enlarge_measure"]
        }
      };
      var WwwRecodeNetExtractor = {
        domain: "www.recode.net",
        title: {
          selectors: ["h1.c-page-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.c-entry-summary.p-dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["figure.e-image--hero", ".c-entry-content"], ".c-entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var QzComExtractor = {
        domain: "qz.com",
        title: {
          selectors: ["article header h1"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [["time[datetime]", "datetime"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"], ['meta[property="og:image"]', "content"], ['meta[name="twitter:image"]', "content"]]
        },
        content: {
          selectors: ["#article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwDmagazineComExtractor = {
        domain: "www.dmagazine.com",
        title: {
          selectors: ["h1.story__title"]
        },
        author: {
          selectors: [".story__info .story__info__item:first-child"]
        },
        date_published: {
          selectors: [
            // enter selectors
            ".story__info"
          ],
          timezone: "America/Chicago",
          format: "MMMM D, YYYY h:mm a"
        },
        dek: {
          selectors: [".story__subhead"]
        },
        lead_image_url: {
          selectors: [["article figure a:first-child", "href"]]
        },
        content: {
          selectors: [".story__content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwReutersComExtractor = {
        domain: "www.reuters.com",
        title: {
          selectors: ["h1.article-headline"]
        },
        author: {
          selectors: [".author"]
        },
        date_published: {
          selectors: [['meta[name="og:article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#article-text"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".article-subtitle": "h4"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["#article-byline .author"]
        }
      };
      var MashableComExtractor = {
        domain: "mashable.com",
        title: {
          selectors: ["h1.title"]
        },
        author: {
          selectors: ["span.author_name a"]
        },
        date_published: {
          selectors: [['meta[name="og:article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["section.article-content.blueprint"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".image-credit": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwChicagotribuneComExtractor = {
        domain: "www.chicagotribune.com",
        title: {
          selectors: ["h1.trb_ar_hl_t"]
        },
        author: {
          selectors: ["span.trb_ar_by_nm_au"]
        },
        date_published: {
          selectors: [['meta[itemprop="datePublished"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.trb_ar_page"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwVoxComExtractor = {
        domain: "www.vox.com",
        title: {
          selectors: ["h1.c-page-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".p-dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["figure.e-image--hero", ".c-entry-content"], ".c-entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "figure .e-image__image noscript": function figureEImage__imageNoscript($node) {
              var imgHtml = $node.html();
              $node.parents(".e-image__image").find(".c-dynamic-image").replaceWith(imgHtml);
            },
            "figure .e-image__meta": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var NewsNationalgeographicComExtractor = {
        domain: "news.nationalgeographic.com",
        title: {
          selectors: ["h1", "h1.main-title"]
        },
        author: {
          selectors: [".byline-component__contributors b span"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]],
          format: "ddd MMM DD HH:mm:ss zz YYYY",
          timezone: "EST"
        },
        dek: {
          selectors: [".article__deck"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".parsys.content", ".__image-lead__"], ".content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".parsys.content": function parsysContent($node, $2) {
              var $imgSrc = $node.find(".image.parbase.section").find(".picturefill").first().data("platform-src");
              if ($imgSrc) {
                $node.prepend($2('<img class="__image-lead__" src="'.concat($imgSrc, '"/>')));
              }
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".pull-quote.pull-quote--large"]
        }
      };
      var WwwNationalgeographicComExtractor = {
        domain: "www.nationalgeographic.com",
        title: {
          selectors: ["h1", "h1.main-title"]
        },
        author: {
          selectors: [".byline-component__contributors b span"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".article__deck"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".parsys.content", ".__image-lead__"], ".content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".parsys.content": function parsysContent($node, $2) {
              var $imageParent = $node.children().first();
              if ($imageParent.hasClass("imageGroup")) {
                var $dataAttrContainer = $imageParent.find(".media--medium__container").children().first();
                var imgPath1 = $dataAttrContainer.data("platform-image1-path");
                var imgPath2 = $dataAttrContainer.data("platform-image2-path");
                if (imgPath2 && imgPath1) {
                  $node.prepend($2('<div class="__image-lead__">\n                <img src="'.concat(imgPath1, '"/>\n                <img src="').concat(imgPath2, '"/>\n              </div>')));
                }
              } else {
                var $imgSrc = $node.find(".image.parbase.section").find(".picturefill").first().data("platform-src");
                if ($imgSrc) {
                  $node.prepend($2('<img class="__image-lead__" src="'.concat($imgSrc, '"/>')));
                }
              }
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".pull-quote.pull-quote--small"]
        }
      };
      var WwwLatimesComExtractor = {
        domain: "www.latimes.com",
        title: {
          selectors: [".trb_ar_hl"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[itemprop="datePublished"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".trb_ar_main"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".trb_ar_la": function trb_ar_la($node) {
              var $figure = $node.find("figure");
              $node.replaceWith($figure);
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".trb_ar_by", ".trb_ar_cr"]
        }
      };
      var PagesixComExtractor = {
        domain: "pagesix.com",
        supportedDomains: ["nypost.com"],
        title: {
          selectors: ["h1 a"]
        },
        author: {
          selectors: [".byline"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [['meta[name="description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["#featured-image-wrapper", ".entry-content"], ".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "#featured-image-wrapper": "figure",
            ".wp-caption-text": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".modal-trigger"]
        }
      };
      var ThefederalistpapersOrgExtractor = {
        domain: "thefederalistpapers.org",
        title: {
          selectors: ["h1.entry-title"]
        },
        author: {
          selectors: ["main span.entry-author-name"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [["p[style]"]]
        }
      };
      var WwwCbssportsComExtractor = {
        domain: "www.cbssports.com",
        title: {
          selectors: [".article-headline"]
        },
        author: {
          selectors: [".author-name"]
        },
        date_published: {
          selectors: [[".date-original-reading-time time", "datetime"]],
          timezone: "UTC"
        },
        dek: {
          selectors: [".article-subline"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwMsnbcComExtractor = {
        domain: "www.msnbc.com",
        title: {
          selectors: ["h1", "h1.is-title-pane"]
        },
        author: {
          selectors: [".author"]
        },
        date_published: {
          selectors: [['meta[name="DC.date.issued"]', "value"]]
        },
        dek: {
          selectors: [['meta[name="description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".pane-node-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".pane-node-body": function paneNodeBody($node, $2) {
              var _WwwMsnbcComExtractor = _slicedToArray(WwwMsnbcComExtractor.lead_image_url.selectors[0], 2), selector = _WwwMsnbcComExtractor[0], attr = _WwwMsnbcComExtractor[1];
              var src = $2(selector).attr(attr);
              if (src) {
                $node.prepend('<img src="'.concat(src, '" />'));
              }
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwThepoliticalinsiderComExtractor = {
        domain: "www.thepoliticalinsider.com",
        title: {
          selectors: [['meta[name="sailthru.title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="sailthru.author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="sailthru.date"]', "value"]],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div#article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwMentalflossComExtractor = {
        domain: "www.mentalfloss.com",
        title: {
          selectors: ["h1.title", ".title-group", ".inner"]
        },
        author: {
          selectors: [".field-name-field-enhanced-authors"]
        },
        date_published: {
          selectors: [".date-display-single"],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.field.field-name-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var AbcnewsGoComExtractor = {
        domain: "abcnews.go.com",
        title: {
          selectors: [".article-header h1"]
        },
        author: {
          selectors: [".authors"],
          clean: [".author-overlay", ".by-text"]
        },
        date_published: {
          selectors: [".timestamp"],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-copy"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwNydailynewsComExtractor = {
        domain: "www.nydailynews.com",
        title: {
          selectors: ["h1#ra-headline"]
        },
        author: {
          selectors: [['meta[name="parsely-author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="sailthru.date"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article#ra-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["dl#ra-tags", ".ra-related", "a.ra-editor", "dl#ra-share-bottom"]
        }
      };
      var WwwCnbcComExtractor = {
        domain: "www.cnbc.com",
        title: {
          selectors: ["h1.title", "h1.ArticleHeader-headline"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div#article_body.content", "div.story", "div.ArticleBody-articleBody"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwPopsugarComExtractor = {
        domain: "www.popsugar.com",
        title: {
          selectors: ["h2.post-title", "title-text"]
        },
        author: {
          selectors: [['meta[name="article:author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".share-copy-title", ".post-tags", ".reactions"]
        }
      };
      var ObserverComExtractor = {
        domain: "observer.com",
        title: {
          selectors: ["h1.entry-title"]
        },
        author: {
          selectors: [".author", ".vcard"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var PeopleComExtractor = {
        domain: "people.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: ["a.author.url.fn"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article-body__inner"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwUsmagazineComExtractor = {
        domain: "www.usmagazine.com",
        title: {
          selectors: ["header h1"]
        },
        author: {
          selectors: ["a.article-byline.tracked-offpage"]
        },
        date_published: {
          timezone: "America/New_York",
          selectors: ["time.article-published-date"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article-body-inner"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".module-related"]
        }
      };
      var WwwRollingstoneComExtractor = {
        domain: "www.rollingstone.com",
        title: {
          selectors: ["h1.content-title"]
        },
        author: {
          selectors: ["a.content-author.tracked-offpage"]
        },
        date_published: {
          selectors: ["time.content-published-date"],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [".content-description"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".lead-container", ".article-content"], ".article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".module-related"]
        }
      };
      var twofortysevensportsComExtractor = {
        domain: "247sports.com",
        title: {
          selectors: ["title", "article header h1"]
        },
        author: {
          selectors: [".author"]
        },
        date_published: {
          selectors: [["time[data-published]", "data-published"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["section.body.article"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var UproxxComExtractor = {
        domain: "uproxx.com",
        title: {
          selectors: ["div.post-top h1"]
        },
        author: {
          selectors: [".post-top .authorname"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".post-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "div.image": "figure",
            "div.image .wp-media-credit": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwEonlineComExtractor = {
        domain: "www.eonline.com",
        title: {
          selectors: ["h1.article__title"]
        },
        author: {
          selectors: [".entry-meta__author a"]
        },
        date_published: {
          selectors: [['meta[itemprop="datePublished"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".post-content section, .post-content div.post-content__image"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "div.post-content__image": "figure",
            "div.post-content__image .image__credits": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwMiamiheraldComExtractor = {
        domain: "www.miamiherald.com",
        title: {
          selectors: ["h1.title"]
        },
        date_published: {
          selectors: ["p.published-date"],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.dateline-storybody"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwRefinery29ComExtractor = {
        domain: "www.refinery29.com",
        title: {
          selectors: ["h1.title"]
        },
        author: {
          selectors: [".contributor"]
        },
        date_published: {
          selectors: [['meta[name="sailthru.date"]', "value"]],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".full-width-opener", ".article-content"], ".article-content", ".body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "div.loading noscript": function divLoadingNoscript($node) {
              var imgHtml = $node.html();
              $node.parents(".loading").replaceWith(imgHtml);
            },
            ".section-image": "figure",
            ".section-image .content-caption": "figcaption",
            ".section-text": "p"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".story-share"]
        }
      };
      var WwwMacrumorsComExtractor = {
        domain: "www.macrumors.com",
        title: {
          selectors: ["h1", "h1.title"]
        },
        author: {
          selectors: [".author-url"]
        },
        date_published: {
          selectors: [".article .byline"],
          // Wednesday January 18, 2017 11:44 am PST
          format: "dddd MMMM D, YYYY h:mm A zz",
          timezone: "America/Los_Angeles"
        },
        dek: {
          selectors: [['meta[name="description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwAndroidcentralComExtractor = {
        domain: "www.androidcentral.com",
        title: {
          selectors: ["h1", "h1.main-title"]
        },
        author: {
          selectors: [".meta-by"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [[".image-large", "src"]]
        },
        content: {
          selectors: [".article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".intro", "blockquote"]
        }
      };
      var WwwSiComExtractor = {
        domain: "www.si.com",
        title: {
          selectors: ["h1", "h1.headline"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [".timestamp"],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [".quick-hit ul"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["p", ".marquee_large_2x", ".component.image"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            noscript: function noscript($node) {
              var $children = $node.children();
              if ($children.length === 1 && $children.get(0).tagName === "img") {
                return "figure";
              }
              return null;
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [[".inline-thumb", ".primary-message", ".description", ".instructions"]]
        }
      };
      var WwwRawstoryComExtractor = {
        domain: "www.rawstory.com",
        title: {
          selectors: [".blog-title"]
        },
        author: {
          selectors: [".blog-author a:first-of-type"]
        },
        date_published: {
          selectors: [".blog-author a:last-of-type"],
          timezone: "EST"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".blog-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwCnetComExtractor = {
        domain: "www.cnet.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: ["a.author"]
        },
        date_published: {
          selectors: ["time"],
          timezone: "America/Los_Angeles"
        },
        dek: {
          selectors: [".article-dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["img.__image-lead__", ".article-main-body"], ".article-main-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "figure.image": function figureImage($node) {
              var $img = $node.find("img");
              $img.attr("width", "100%");
              $img.attr("height", "100%");
              $img.addClass("__image-lead__");
              $node.remove(".imgContainer").prepend($img);
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwCinemablendComExtractor = {
        domain: "www.cinemablend.com",
        title: {
          selectors: [".story_title"]
        },
        author: {
          selectors: [".author"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]],
          timezone: "EST"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div#wrap_left_content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwTodayComExtractor = {
        domain: "www.today.com",
        title: {
          selectors: ["h1.entry-headline"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="DC.date.issued"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-container"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".label-comment"]
        }
      };
      var WwwHowtogeekComExtractor = {
        domain: "www.howtogeek.com",
        title: {
          selectors: ["title"]
        },
        author: {
          selectors: ["#authorinfobox a"]
        },
        date_published: {
          selectors: ["#authorinfobox + div li"],
          timezone: "GMT"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".thecontent"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwAlComExtractor = {
        domain: "www.al.com",
        title: {
          selectors: [['meta[name="title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="article_author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article_date_original"]', "value"]],
          timezone: "EST"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwThepennyhoarderComExtractor = {
        domain: "www.thepennyhoarder.com",
        title: {
          selectors: [['meta[name="dcterms.title"]', "value"]]
        },
        author: {
          selectors: [['link[rel="author"]', "title"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".post-img", ".post-text"], ".post-text"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwWesternjournalismComExtractor = {
        domain: "www.westernjournalism.com",
        title: {
          selectors: ["title", "h1.entry-title"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="DC.date.issued"]', "value"]]
        },
        dek: {
          selectors: [".subtitle"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article-sharing.top + div"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".ad-notice-small"]
        }
      };
      var FusionNetExtractor = {
        domain: "fusion.net",
        title: {
          selectors: [".post-title", ".single-title", ".headline"]
        },
        author: {
          selectors: [".show-for-medium .byline"]
        },
        date_published: {
          selectors: [["time.local-time", "datetime"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".post-featured-media", ".article-content"], ".article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".fusion-youtube-oembed": "figure"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwAmericanowComExtractor = {
        domain: "www.americanow.com",
        title: {
          selectors: [".title", ['meta[name="title"]', "value"]]
        },
        author: {
          selectors: [".byline"]
        },
        date_published: {
          selectors: [['meta[name="publish_date"]', "value"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".article-content", ".image", ".body"], ".body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".article-video-wrapper", ".show-for-small-only"]
        }
      };
      var ScienceflyComExtractor = {
        domain: "sciencefly.com",
        title: {
          selectors: [".entry-title", ".cb-entry-title", ".cb-single-title"]
        },
        author: {
          selectors: ["div.cb-author", "div.cb-author-title"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [["div.theiaPostSlider_slides img", "src"]]
        },
        content: {
          selectors: ["div.theiaPostSlider_slides"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var HellogigglesComExtractor = {
        domain: "hellogiggles.com",
        title: {
          selectors: [".title"]
        },
        author: {
          selectors: [".author-link"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var ThoughtcatalogComExtractor = {
        domain: "thoughtcatalog.com",
        title: {
          selectors: ["h1.title", ['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: ["div.col-xs-12.article_header div.writer-container.writer-container-inline.writer-no-avatar h4.writer-name", "h1.writer-name"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry.post"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".tc_mark"]
        }
      };
      var WwwNjComExtractor = {
        domain: "www.nj.com",
        title: {
          selectors: [['meta[name="title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="article_author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article_date_original"]', "value"]],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwInquisitrComExtractor = {
        domain: "www.inquisitr.com",
        title: {
          selectors: ["h1.entry-title.story--header--title"]
        },
        author: {
          selectors: ["div.story--header--author"]
        },
        date_published: {
          selectors: [['meta[name="datePublished"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article.story", ".entry-content."],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".post-category", ".story--header--socials", ".story--header--content"]
        }
      };
      var WwwNbcnewsComExtractor = {
        domain: "www.nbcnews.com",
        title: {
          selectors: ["div.article-hed h1"]
        },
        author: {
          selectors: ["span.byline_author"]
        },
        date_published: {
          selectors: [[".flag_article-wrapper time.timestamp_article[datetime]", "datetime"], ".flag_article-wrapper time"],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var FortuneComExtractor = {
        domain: "fortune.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [".MblGHNMJ"],
          timezone: "UTC"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["picture", "article.row"], "article.row"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwLinkedinComExtractor = {
        domain: "www.linkedin.com",
        title: {
          selectors: [".article-title", "h1"]
        },
        author: {
          selectors: [['meta[name="article:author"]', "value"], ".entity-name a[rel=author]"]
        },
        date_published: {
          selectors: [['time[itemprop="datePublished"]', "datetime"]],
          timezone: "America/Los_Angeles"
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["header figure", ".prose"], ".prose"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".entity-image"]
        }
      };
      var ObamawhitehouseArchivesGovExtractor = {
        domain: "obamawhitehouse.archives.gov",
        supportedDomains: ["whitehouse.gov"],
        title: {
          selectors: ["h1", ".pane-node-title"]
        },
        author: {
          selectors: [".blog-author-link", ".node-person-name-link"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".field-name-field-forall-summary"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          defaultCleaner: false,
          selectors: ["div#content-start", ".pane-node-field-forall-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".pane-node-title", ".pane-custom.pane-1"]
        }
      };
      var WwwOpposingviewsComExtractor = {
        domain: "www.opposingviews.com",
        title: {
          selectors: ["h1.title"]
        },
        author: {
          selectors: ["div.date span span a"]
        },
        date_published: {
          selectors: [['meta[name="publish_date"]', "value"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".show-for-small-only"]
        }
      };
      var WwwProspectmagazineCoUkExtractor = {
        domain: "www.prospectmagazine.co.uk",
        title: {
          selectors: [".page-title"]
        },
        author: {
          selectors: [".aside_author .title"]
        },
        date_published: {
          selectors: [".post-info"],
          timezone: "Europe/London"
        },
        dek: {
          selectors: [".page-subtitle"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article .post_content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var ForwardComExtractor = {
        domain: "forward.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: [".author-name", ['meta[name="sailthru.author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="date"]', "value"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".post-item-media-wrap", ".post-item p"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".donate-box", ".message", ".subtitle"]
        }
      };
      var WwwQdailyComExtractor = {
        domain: "www.qdaily.com",
        title: {
          selectors: ["h2", "h2.title"]
        },
        author: {
          selectors: [".name"]
        },
        date_published: {
          selectors: [[".date.smart-date", "data-origindate"]]
        },
        dek: {
          selectors: [".excerpt"]
        },
        lead_image_url: {
          selectors: [[".article-detail-hd img", "src"]]
        },
        content: {
          selectors: [".detail"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".lazyload", ".lazylad", ".lazylood"]
        }
      };
      var GothamistComExtractor = {
        domain: "gothamist.com",
        supportedDomains: ["chicagoist.com", "laist.com", "sfist.com", "shanghaiist.com", "dcist.com"],
        title: {
          selectors: ["h1", ".entry-header h1"]
        },
        author: {
          selectors: [".author"]
        },
        date_published: {
          selectors: ["abbr", "abbr.published"],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [null]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".entry-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "div.image-none": "figure",
            ".image-none i": "figcaption",
            "div.image-left": "figure",
            ".image-left i": "figcaption",
            "div.image-right": "figure",
            ".image-right i": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".image-none br", ".image-left br", ".image-right br", ".galleryEase"]
        }
      };
      var WwwFoolComExtractor = {
        domain: "www.fool.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [".author-inline .author-name"]
        },
        date_published: {
          selectors: [['meta[name="date"]', "value"]]
        },
        dek: {
          selectors: ["header h2"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article-content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ".caption img": function captionImg($node) {
              var src = $node.attr("src");
              $node.parent().replaceWith('<figure><img src="'.concat(src, '"/></figure>'));
            },
            ".caption": "figcaption"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["#pitch"]
        }
      };
      var WwwSlateComExtractor = {
        domain: "www.slate.com",
        title: {
          selectors: [".hed", "h1"]
        },
        author: {
          selectors: ["a[rel=author]"]
        },
        date_published: {
          selectors: [".pub-date"],
          timezone: "America/New_York"
        },
        dek: {
          selectors: [".dek"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".about-the-author", ".pullquote", ".newsletter-signup-component", ".top-comment"]
        }
      };
      var IciRadioCanadaCaExtractor = {
        domain: "ici.radio-canada.ca",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [['meta[name="dc.creator"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="dc.date.created"]', "value"]],
          format: "YYYY-MM-DD|HH[h]mm",
          timezone: "America/New_York"
        },
        dek: {
          selectors: [".bunker-component.lead"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [[".main-multimedia-item", ".news-story-content"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwFortinetComExtractor = {
        domain: "www.fortinet.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [".b15-blog-meta__author"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.responsivegrid.aem-GridColumn.aem-GridColumn--default--12"],
          transforms: {
            noscript: function noscript($node) {
              var $children = $node.children();
              if ($children.length === 1 && $children.get(0).tagName === "img") {
                return "figure";
              }
              return null;
            }
          }
        }
      };
      var WwwFastcompanyComExtractor = {
        domain: "www.fastcompany.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [".post__by"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".post__deck"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".post__article"]
        }
      };
      var BlisterreviewComExtractor = {
        domain: "blisterreview.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"], "h1.entry-title"]
        },
        author: {
          selectors: ["span.author-name"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"], ["time.entry-date", "datetime"], ['meta[itemprop="datePublished"]', "content"]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"], ['meta[property="og:image"]', "content"], ['meta[itemprop="image"]', "content"], ['meta[name="twitter:image"]', "content"], ["img.attachment-large", "src"]]
        },
        content: {
          selectors: [[".elementor-section-wrap", ".elementor-text-editor > p, .elementor-text-editor > ul > li, .attachment-large, .wp-caption-text"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            figcaption: "p"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".comments-area"]
        }
      };
      var NewsMynaviJpExtractor = {
        domain: "news.mynavi.jp",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: ["main div.article-author a.article-author__name"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["main article div"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            img: function img($node) {
              var src = $node.attr("data-original");
              if (src !== "") {
                $node.attr("src", src);
              }
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var ClinicaltrialsGovExtractor = {
        domain: "clinicaltrials.gov",
        title: {
          selectors: ["h1.tr-solo_record"]
        },
        author: {
          selectors: ["div#sponsor.tr-info-text"]
        },
        date_published: {
          // selectors: ['span.term[data-term="Last Update Posted"]'],
          selectors: ['div:has(> span.term[data-term="Last Update Posted"])']
        },
        content: {
          selectors: ["div#tab-body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".usa-alert> img"]
        }
      };
      var GithubComExtractor = {
        domain: "github.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: [
            // enter author selectors
          ]
        },
        date_published: {
          selectors: [['span[itemprop="dateModified"] relative-time', "datetime"]]
        },
        dek: {
          selectors: ['span[itemprop="about"]']
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["#readme article"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwRedditComExtractor = {
        domain: "www.reddit.com",
        title: {
          selectors: ['div[data-test-id="post-content"] h2']
        },
        author: {
          selectors: ['div[data-test-id="post-content"] a[href*="user/"]']
        },
        date_published: {
          selectors: ['div[data-test-id="post-content"] a[data-click-id="timestamp"]']
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [
            ['div[data-test-id="post-content"] p'],
            // text post
            [
              'div[data-test-id="post-content"] a[target="_blank"]:not([data-click-id="timestamp"])',
              // external link
              'div[data-test-id="post-content"] div[data-click-id="media"]'
            ],
            // external link with media preview (YouTube, imgur album, etc...)
            ['div[data-test-id="post-content"] div[data-click-id="media"]'],
            // Embedded media (Reddit video)
            ['div[data-test-id="post-content"] a[target="_blank"]:not([data-click-id="timestamp"])'],
            // external link
            'div[data-test-id="post-content"]'
          ],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            'div[role="img"]': function divRoleImg($node) {
              var $img = $node.find("img");
              var bgImg = $node.css("background-image");
              if ($img.length === 1 && bgImg) {
                $img.attr("src", bgImg.match(/\((.*?)\)/)[1].replace(/('|")/g, ""));
                return $img;
              }
              return $node;
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".icon"]
        }
      };
      var OtrsComExtractor = {
        domain: "otrs.com",
        title: {
          selectors: ["#main article h1"]
        },
        author: {
          selectors: ["div.dateplusauthor a"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#main article"],
          defaultCleaner: false,
          transforms: {},
          clean: ["div.dateplusauthor", "div.gr-12.push-6.footershare", "#atftbx", "div.category-modul"]
        }
      };
      var WwwOssnewsJpExtractor = {
        domain: "www.ossnews.jp",
        title: {
          selectors: ["#alpha-block h1.hxnewstitle"]
        },
        author: null,
        date_published: {
          selectors: ["p.fs12"],
          format: "YYYY\u5E74MM\u6708DD\u65E5 HH:mm",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#alpha-block .section:has(h1.hxnewstitle)"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var BuzzapJpExtractor = {
        domain: "buzzap.jp",
        title: {
          selectors: ["h1.entry-title"]
        },
        author: null,
        date_published: {
          selectors: [["time.entry-date", "datetime"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.ctiframe"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var WwwAsahiComExtractor = {
        domain: "www.asahi.com",
        title: {
          selectors: [".ArticleTitle h1"]
        },
        author: {
          selectors: [['meta[name="article:author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="pubdate"]', "value"]]
        },
        dek: null,
        excerpt: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#MainInner div.ArticleBody"],
          defaultCleaner: false,
          transforms: {},
          clean: ["div.AdMod", "div.LoginSelectArea"]
        }
      };
      var WwwSanwaCoJpExtractor = {
        domain: "www.sanwa.co.jp",
        title: {
          selectors: ["#newsContent h1"]
        },
        author: null,
        date_published: {
          selectors: ["p.date"],
          format: "YYYY.MM.DD",
          timezone: "Asia/Tokyo"
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#newsContent"],
          defaultCleaner: false,
          transforms: {},
          clean: ["#smartphone", "div.sns_box", "div.contentFoot"]
        }
      };
      var WwwElecomCoJpExtractor = {
        domain: "www.elecom.co.jp",
        title: {
          selectors: ["title"]
        },
        author: null,
        date_published: {
          selectors: ["p.section-last"],
          format: "YYYY.MM.DD",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: ["td.TableMain2"],
          defaultCleaner: false,
          transforms: {
            table: function table($node) {
              $node.attr("width", "auto");
            }
          },
          clean: []
        }
      };
      var ScanNetsecurityNeJpExtractor = {
        domain: "scan.netsecurity.ne.jp",
        title: {
          selectors: ["header.arti-header h1.head"]
        },
        author: null,
        date_published: {
          selectors: [['meta[name="article:modified_time"]', "value"]]
        },
        dek: {
          selectors: ["header.arti-header p.arti-summary"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.arti-content.arti-content--thumbnail"],
          defaultCleaner: false,
          transforms: {},
          clean: ["aside.arti-giga"]
        }
      };
      var JvndbJvnJpExtractor = {
        domain: "jvndb.jvn.jp",
        title: {
          selectors: ["title"]
        },
        author: null,
        date_published: {
          selectors: ["div.modifytxt:nth-child(2)"],
          format: "YYYY/MM/DD",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: ["#news-list"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var GeniusComExtractor = {
        domain: "genius.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: ["h2 a"]
        },
        date_published: {
          selectors: [["meta[itemprop=page_data]", "value", function(res) {
            var json = JSON.parse(res);
            return json.song.release_date;
          }]]
        },
        dek: {
          selectors: [
            // enter selectors
          ]
        },
        lead_image_url: {
          selectors: [["meta[itemprop=page_data]", "value", function(res) {
            var json = JSON.parse(res);
            return json.song.album.cover_art_url;
          }]]
        },
        content: {
          selectors: [".lyrics"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwJnsaOrgExtractor = {
        domain: "www.jnsa.org",
        title: {
          selectors: ["#wgtitle h2"]
        },
        author: null,
        date_published: null,
        dek: null,
        excerpt: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#main_area"],
          transforms: {},
          clean: ["#pankuzu", "#side"]
        }
      };
      var PhpspotOrgExtractor = {
        domain: "phpspot.org",
        title: {
          selectors: ["h3.hl"]
        },
        author: null,
        date_published: {
          selectors: ["h4.hl"],
          format: "YYYY\u5E74MM\u6708DD\u65E5",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: ["div.entrybody"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var WwwInfoqComExtractor = {
        domain: "www.infoq.com",
        title: {
          selectors: ["h1.heading"]
        },
        author: {
          selectors: ["div.widget.article__authors"]
        },
        date_published: {
          selectors: [".article__readTime.date"],
          format: "YYYY\u5E74MM\u6708DD\u65E5",
          timezone: "Asia/Tokyo"
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article__data"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var WwwMoongiftJpExtractor = {
        domain: "www.moongift.jp",
        title: {
          selectors: ["h1.title a"]
        },
        author: null,
        date_published: {
          selectors: ["ul.meta li:not(.social):first-of-type"],
          timezone: "Asia/Tokyo"
        },
        dek: {
          selectors: [['meta[name="og:description"]', "value"]]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#main"],
          transforms: {},
          clean: ["ul.mg_service.cf"]
        }
      };
      var WwwItmediaCoJpExtractor = {
        domain: "www.itmedia.co.jp",
        supportedDomains: ["www.atmarkit.co.jp", "techtarget.itmedia.co.jp", "nlab.itmedia.co.jp"],
        title: {
          selectors: ["#cmsTitle h1"]
        },
        author: {
          selectors: ["#byline"]
        },
        date_published: {
          selectors: [['meta[name="article:modified_time"]', "value"]]
        },
        dek: {
          selectors: ["#cmsAbstract h2"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#cmsBody"],
          defaultCleaner: false,
          transforms: {},
          clean: ["#snsSharebox"]
        }
      };
      var WwwPublickey1JpExtractor = {
        domain: "www.publickey1.jp",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: ["#subcol p:has(img)"]
        },
        date_published: {
          selectors: ["div.pubdate"],
          format: "YYYY\u5E74MM\u6708DD\u65E5",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#maincol"],
          defaultCleaner: false,
          transforms: {},
          clean: ["#breadcrumbs", "div.sbm", "div.ad_footer"]
        }
      };
      var TakagihiromitsuJpExtractor = {
        domain: "takagi-hiromitsu.jp",
        title: {
          selectors: ["h3"]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[http-equiv="Last-Modified"]', "value"]]
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: ["div.body"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var BookwalkerJpExtractor = {
        domain: "bookwalker.jp",
        title: {
          selectors: ["h1.main-heading"]
        },
        author: {
          selectors: ["div.authors"]
        },
        date_published: {
          selectors: [".work-info .work-detail:first-of-type .work-detail-contents:last-of-type"],
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [["div.main-info", "div.main-cover-inner"]],
          defaultCleaner: false,
          transforms: {},
          clean: ["span.label.label--trial", "dt.info-head.info-head--coin", "dd.info-contents.info-contents--coin", "div.info-notice.fn-toggleClass"]
        }
      };
      var WwwYomiuriCoJpExtractor = {
        domain: "www.yomiuri.co.jp",
        title: {
          selectors: ["h1.title-article.c-article-title"]
        },
        author: null,
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.p-main-contents"],
          transforms: {},
          clean: []
        }
      };
      var JapanCnetComExtractor = {
        domain: "japan.cnet.com",
        title: {
          selectors: [".leaf-headline-ttl"]
        },
        author: {
          selectors: [".writer"]
        },
        date_published: {
          selectors: [".date"],
          format: "YYYY\u5E74MM\u6708DD\u65E5 HH\u6642mm\u5206",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article_body"],
          transforms: {},
          clean: []
        }
      };
      var DeadlineComExtractor = {
        domain: "deadline.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: ["section.author h3"]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.a-article-grid__main.pmc-a-grid article.pmc-a-grid-item"],
          transforms: {
            ".embed-twitter": function embedTwitter($node) {
              var innerHtml = $node.html();
              $node.replaceWith(innerHtml);
            }
          },
          clean: []
        }
      };
      var WwwGizmodoJpExtractor = {
        domain: "www.gizmodo.jp",
        title: {
          selectors: ["h1.p-post-title"]
        },
        author: {
          selectors: ["li.p-post-AssistAuthor"]
        },
        date_published: {
          selectors: [["li.p-post-AssistTime time", "datetime"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article.p-post"],
          transforms: {
            "img.p-post-thumbnailImage": function imgPPostThumbnailImage($node) {
              var src = $node.attr("src");
              $node.attr("src", src.replace(/^.*=%27/, "").replace(/%27;$/, ""));
            }
          },
          clean: ["h1.p-post-title", "ul.p-post-Assist"]
        }
      };
      var GetnewsJpExtractor = {
        domain: "getnews.jp",
        title: {
          selectors: ["article h1"]
        },
        author: {
          selectors: ["span.prof"]
        },
        date_published: {
          selectors: [["ul.cattag-top time", "datetime"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.post-bodycopy"],
          transforms: {},
          clean: []
        }
      };
      var WwwLifehackerJpExtractor = {
        domain: "www.lifehacker.jp",
        title: {
          selectors: ["h1.lh-summary-title"]
        },
        author: {
          selectors: ["p.lh-entryDetailInner--credit"]
        },
        date_published: {
          selectors: [["div.lh-entryDetail-header time", "datetime"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.lh-entryDetail-body"],
          transforms: {
            "img.lazyload": function imgLazyload($node) {
              var src = $node.attr("src");
              $node.attr("src", src.replace(/^.*=%27/, "").replace(/%27;$/, ""));
            }
          },
          clean: ["p.lh-entryDetailInner--credit"]
        }
      };
      var SectIijAdJpExtractor = {
        domain: "sect.iij.ad.jp",
        title: {
          selectors: ["h3"]
        },
        author: {
          selectors: ["dl.entrydate dd"]
        },
        date_published: {
          selectors: ["dl.entrydate dd"],
          format: "YYYY\u5E74MM\u6708DD\u65E5",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#article"],
          transforms: {},
          clean: ["dl.entrydate"]
        }
      };
      var WwwOreillyCoJpExtractor = {
        domain: "www.oreilly.co.jp",
        title: {
          selectors: ["h3"]
        },
        author: {
          selectors: ['li[itemprop="author"]']
        },
        date_published: {
          selectors: [['meta[itemprop="datePublished"]', "value"]],
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#content"],
          defaultCleaner: false,
          transforms: {},
          clean: [".social-tools"]
        }
      };
      var WwwIpaGoJpExtractor = {
        domain: "www.ipa.go.jp",
        title: {
          selectors: ["h1"]
        },
        author: null,
        date_published: {
          selectors: ["p.ipar_text_right"],
          format: "YYYY\u5E74M\u6708D\u65E5",
          timezone: "Asia/Tokyo"
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: ["#ipar_main"],
          defaultCleaner: false,
          transforms: {},
          clean: ["p.ipar_text_right"]
        }
      };
      var WeeklyAsciiJpExtractor = {
        domain: "weekly.ascii.jp",
        title: {
          selectors: ['h1[itemprop="headline"]']
        },
        author: {
          selectors: ["p.author"]
        },
        date_published: {
          selectors: [['meta[name="odate"]', "value"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article"],
          transforms: {},
          clean: []
        }
      };
      var TechlogIijAdJpExtractor = {
        domain: "techlog.iij.ad.jp",
        title: {
          selectors: ["h1.entry-title"]
        },
        author: {
          selectors: ['a[rel="author"]']
        },
        date_published: {
          selectors: [["time.entry-date", "datetime"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.entry-content"],
          defaultCleaner: false,
          transforms: {},
          clean: []
        }
      };
      var WiredJpExtractor = {
        domain: "wired.jp",
        title: {
          selectors: ["h1.post-title"]
        },
        author: {
          selectors: ['p[itemprop="author"]']
        },
        date_published: {
          selectors: [["time", "datetime"]]
        },
        dek: {
          selectors: [".post-intro"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article.article-detail"],
          transforms: {
            "img[data-original]": function imgDataOriginal($node) {
              var dataOriginal = $node.attr("data-original");
              var src = $node.attr("src");
              var url = URL.resolve(src, dataOriginal);
              $node.attr("src", url);
            }
          },
          clean: [".post-category", "time", "h1.post-title", ".social-area-syncer"]
        }
      };
      var JapanZdnetComExtractor = {
        domain: "japan.zdnet.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [['meta[name="cXenseParse:author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: null,
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.article_body"],
          transforms: {},
          clean: []
        }
      };
      var WwwRbbtodayComExtractor = {
        domain: "www.rbbtoday.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [".writer.writer-name"]
        },
        date_published: {
          selectors: [["header time", "datetime"]]
        },
        dek: {
          selectors: [".arti-summary"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".arti-content"],
          transforms: {},
          clean: [".arti-giga"]
        }
      };
      var WwwLemondeFrExtractor = {
        domain: "www.lemonde.fr",
        title: {
          selectors: ["h1.article__title"]
        },
        author: {
          selectors: [".author__name"]
        },
        date_published: {
          selectors: [['meta[name="og:article:published_time"]', "value"]]
        },
        dek: {
          selectors: [".article__desc"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: [".article__content"],
          transforms: {},
          clean: []
        }
      };
      var WwwPhoronixComExtractor = {
        domain: "www.phoronix.com",
        title: {
          selectors: ["article header"]
        },
        author: {
          selectors: [".author a:first-child"]
        },
        date_published: {
          selectors: [".author"],
          // 1 June 2019 at 08:34 PM EDT
          format: "D MMMM YYYY at hh:mm",
          timezone: "America/New_York"
        },
        dek: null,
        lead_image_url: null,
        content: {
          selectors: [".content"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var PitchforkComExtractor = {
        domain: "pitchfork.com",
        title: {
          selectors: ["title"]
        },
        author: {
          selectors: [".authors-detail__display-name"]
        },
        date_published: {
          selectors: [[".pub-date", "datetime"]]
        },
        dek: {
          selectors: [".review-detail__abstract"]
        },
        lead_image_url: {
          selectors: [[".single-album-tombstone__art img", "src"]]
        },
        content: {
          selectors: [".review-detail__text"]
        },
        extend: {
          score: {
            selectors: [".score"]
          }
        }
      };
      var BiorxivOrgExtractor = {
        domain: "biorxiv.org",
        title: {
          selectors: ["h1#page-title"]
        },
        author: {
          selectors: ["div.highwire-citation-biorxiv-article-top > div.highwire-cite-authors"]
        },
        content: {
          selectors: ["div#abstract-1"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var EpaperZeitDeExtractor = {
        domain: "epaper.zeit.de",
        title: {
          selectors: ["p.title"]
        },
        author: {
          selectors: [".article__author"]
        },
        date_published: null,
        excerpt: {
          selectors: ["subtitle"]
        },
        lead_image_url: null,
        content: {
          selectors: [".article"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            "p.title": "h1",
            ".article__author": "p",
            byline: "p",
            linkbox: "p"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["image-credits", "box[type=citation]"]
        }
      };
      var WwwLadbibleComExtractor = {
        domain: "www.ladbible.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: ["[class*=Byline]"]
        },
        date_published: {
          selectors: ["time"],
          timezone: "Europe/London"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["[class*=ArticleContainer]"],
          clean: ["time", "source", 'a[href^="https://www.ladbible.com/"]', "picture", "[class*=StyledCardBlock]"]
        }
      };
      var TimesofindiaIndiatimesComExtractor = {
        domain: "timesofindia.indiatimes.com",
        title: {
          selectors: ["h1"]
        },
        extend: {
          reporter: {
            selectors: ["div.byline"],
            transforms: {}
          }
        },
        date_published: {
          selectors: [".byline"],
          format: "MMM D, YYYY, HH:mm z",
          timezone: "Asia/Kolkata"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["div.contentwrapper:has(section)"],
          defaultCleaner: false,
          clean: ["section", "h1", ".byline", ".img_cptn"]
        }
      };
      var MaTtiasBeExtractor = {
        domain: "ma.ttias.be",
        title: {
          selectors: [['meta[name="twitter:title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        content: {
          selectors: [[".content"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            h2: function h2($node) {
              $node.attr("id", null);
              return "h3";
            },
            h1: function h1($node) {
              $node.attr("id", null);
              $node.after("<p></p>");
            },
            ul: function ul($node) {
              $node.attr("class", "entry-content-asset");
            }
          }
        }
      };
      var PastebinComExtractor = {
        domain: "pastebin.com",
        title: {
          selectors: ["h1"]
        },
        author: {
          selectors: [".paste_box_line2 .t_us + a"]
        },
        date_published: {
          selectors: [".paste_box_line2 .t_da + span"],
          timezone: "America/New_York"
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["#selectable .text"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            ol: "div",
            li: "p"
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwAbendblattDeExtractor = {
        domain: "www.abendblatt.de",
        title: {
          selectors: ["h2.article__header__headline"]
        },
        author: {
          selectors: ["span.author-info__name-text"]
        },
        date_published: {
          selectors: [["time.article__header__date", "datetime"]]
        },
        dek: {
          selectors: ["span[itemprop='description']"]
        },
        lead_image_url: {
          selectors: [["meta[name='og:image']", "value"]]
        },
        content: {
          selectors: ["div.article__body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            p: function p($node) {
              if (!$node.hasClass("obfuscated"))
                return null;
              var o = "";
              var n = 0;
              for (var i = $node.text(); n < i.length; n += 1) {
                var r = i.charCodeAt(n);
                r === 177 ? o += "%" : r === 178 ? o += "!" : r === 180 ? o += ";" : r === 181 ? o += "=" : r === 32 ? o += " " : r === 10 ? o += "\n" : r > 33 && (o += String.fromCharCode(r - 1));
              }
              $node.html(o);
              $node.removeClass("obfuscated");
              $node.addClass("deobfuscated");
              return null;
            },
            div: function div($node) {
              if (!$node.hasClass("obfuscated"))
                return null;
              var o = "";
              var n = 0;
              for (var i = $node.text(); n < i.length; n += 1) {
                var r = i.charCodeAt(n);
                r === 177 ? o += "%" : r === 178 ? o += "!" : r === 180 ? o += ";" : r === 181 ? o += "=" : r === 32 ? o += " " : r === 10 ? o += "\n" : r > 33 && (o += String.fromCharCode(r - 1));
              }
              $node.html(o);
              $node.removeClass("obfuscated");
              $node.addClass("deobfuscated");
              return null;
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var WwwGrueneDeExtractor = {
        domain: "www.gruene.de",
        title: {
          selectors: ["header h1"]
        },
        author: null,
        date_published: null,
        dek: null,
        lead_image_url: {
          selectors: [['meta[property="og:image"]', "content"]]
        },
        content: {
          // selectors: ['section'],
          selectors: [["section header", "section h2", "section p", "section ol"]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["figcaption", "p[class]"]
        }
      };
      var WwwEngadgetComExtractor = {
        domain: "www.engadget.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: ['a.th-meta[data-ylk*="subsec:author"]']
        },
        // Engadget stories have publish dates, but the only representation of them on the page
        // is in a format like "2h ago". There are also these tags with blank values:
        // <meta class="swiftype" name="published_at" data-type="date" value="">
        date_published: {
          selectors: [
            // enter selectors
          ]
        },
        dek: {
          selectors: ['div[class*="o-title_mark"] div']
        },
        // Engadget stories do have lead images specified by an og:image meta tag, but selecting
        // the value attribute of that tag fails. I believe the "&#x2111;" sequence of characters
        // is triggering this inability to select the attribute value.
        lead_image_url: {
          selectors: [
            // enter selectors
          ]
        },
        content: {
          selectors: [[
            // Some figures will be inside div.article-text, but some header figures/images
            // will not.
            "#page_body figure:not(div.article-text figure)",
            "div.article-text"
          ]],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: []
        }
      };
      var ArstechnicaComExtractor = {
        domain: "arstechnica.com",
        // Articles from this site are often paginated, but I was unable to write a CSS
        // selector to find the next page. On the last page, there will be a link with a CSS
        // selector indicating that the previous page is next. But the parser appears to find
        // the next page without this extractor finding it, as long as the fallback option is
        // left at its default value of true.
        title: {
          selectors: ["title"]
        },
        author: {
          selectors: ['*[rel="author"] *[itemprop="name"]']
        },
        date_published: {
          selectors: [[".byline time", "datetime"]]
        },
        dek: {
          selectors: ['h2[itemprop="description"]']
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ['div[itemprop="articleBody"]'],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            h2: function h2($node) {
              $node.before("<p></p>");
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result.
          clean: [
            // Remove enlarge links and separators inside image captions.
            "figcaption .enlarge-link",
            "figcaption .sep",
            // I could not transform the video into usable elements, so I
            // removed them.
            "figure.video",
            // Image galleries that do not work.
            ".gallery",
            "aside",
            ".sidebar"
          ]
        }
      };
      var WwwNdtvComExtractor = {
        domain: "www.ndtv.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"], "h1.entry-title"]
        },
        author: {
          selectors: ['span[itemprop="author"] span[itemprop="name"]']
        },
        date_published: {
          selectors: [['span[itemprop="dateModified"]', "content"]]
        },
        dek: {
          selectors: ["h2"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ['div[itemprop="articleBody"]'],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {
            // This site puts a dateline in a 'b' above the first paragraph, and then somehow
            // blends it into the first paragraph with CSS. This transform moves the dateline
            // to the first paragraph.
            ".place_cont": function place_cont($node) {
              if (!$node.parents("p").length) {
                var nextSibling = $node.next("p");
                if (nextSibling) {
                  $node.remove();
                  nextSibling.prepend($node);
                }
              }
            }
          },
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: [".highlghts_Wdgt", ".ins_instory_dv_caption", "input", "._world-wrapper .mt20"]
        }
      };
      var SpektrumExtractor = {
        domain: "www.spektrum.de",
        title: {
          selectors: [".content__title"]
        },
        author: {
          selectors: [".content__author__info__name"]
        },
        date_published: {
          selectors: [".content__meta__date"],
          timezone: "Europe/Berlin"
        },
        dek: {
          selectors: [".content__intro"]
        },
        lead_image_url: {
          selectors: [
            // This is how the meta tag appears in the original source code.
            ['meta[name="og:image"]', "value"],
            // This is how the meta tag appears in the DOM in Chrome.
            // The selector is included here to make the code work within the browser as well.
            ['meta[property="og:image"]', "content"],
            // This is the image that is shown on the page.
            // It can be slightly cropped compared to the original in the meta tag.
            ".image__article__top img"
          ]
        },
        content: {
          selectors: ["article.content"],
          clean: [".breadcrumbs", ".hide-for-print", "aside", "header h2", ".image__article__top", ".content__author", ".copyright", ".callout-box"]
        }
      };
      var PostlightComExtractor = {
        domain: "postlight.com",
        title: {
          selectors: [['meta[name="og:title"]', "value"]]
        },
        author: {
          selectors: [['meta[name="parsely-author"]', "value"]]
        },
        date_published: {
          selectors: [['meta[name="article:published_time"]', "value"]]
        },
        dek: {
          selectors: ["h2.single-hero__abstract"]
        },
        lead_image_url: {
          selectors: [['meta[name="og:image"]', "value"]]
        },
        content: {
          selectors: ["article.body"],
          // Is there anything in the content you selected that needs transformed
          // before it's consumable content? E.g., unusual lazy loaded images
          transforms: {},
          // Is there anything that is in the result that shouldn't be?
          // The clean selectors will remove anything that matches from
          // the result
          clean: ["section.pl-post-link"]
        }
      };
      var CustomExtractors = /* @__PURE__ */ Object.freeze({
        BloggerExtractor,
        NYMagExtractor,
        WikipediaExtractor,
        TwitterExtractor,
        NYTimesExtractor,
        TheAtlanticExtractor,
        NewYorkerExtractor,
        WiredExtractor,
        MSNExtractor,
        YahooExtractor,
        BuzzfeedExtractor,
        WikiaExtractor,
        LittleThingsExtractor,
        PoliticoExtractor,
        DeadspinExtractor,
        BroadwayWorldExtractor,
        ApartmentTherapyExtractor,
        MediumExtractor,
        WwwTmzComExtractor,
        WwwWashingtonpostComExtractor,
        WwwHuffingtonpostComExtractor,
        NewrepublicComExtractor,
        MoneyCnnComExtractor,
        WwwThevergeComExtractor,
        WwwCnnComExtractor,
        WwwAolComExtractor,
        WwwYoutubeComExtractor,
        WwwTheguardianComExtractor,
        WwwSbnationComExtractor,
        WwwBloombergComExtractor,
        WwwBustleComExtractor,
        WwwNprOrgExtractor,
        WwwRecodeNetExtractor,
        QzComExtractor,
        WwwDmagazineComExtractor,
        WwwReutersComExtractor,
        MashableComExtractor,
        WwwChicagotribuneComExtractor,
        WwwVoxComExtractor,
        NewsNationalgeographicComExtractor,
        WwwNationalgeographicComExtractor,
        WwwLatimesComExtractor,
        PagesixComExtractor,
        ThefederalistpapersOrgExtractor,
        WwwCbssportsComExtractor,
        WwwMsnbcComExtractor,
        WwwThepoliticalinsiderComExtractor,
        WwwMentalflossComExtractor,
        AbcnewsGoComExtractor,
        WwwNydailynewsComExtractor,
        WwwCnbcComExtractor,
        WwwPopsugarComExtractor,
        ObserverComExtractor,
        PeopleComExtractor,
        WwwUsmagazineComExtractor,
        WwwRollingstoneComExtractor,
        twofortysevensportsComExtractor,
        UproxxComExtractor,
        WwwEonlineComExtractor,
        WwwMiamiheraldComExtractor,
        WwwRefinery29ComExtractor,
        WwwMacrumorsComExtractor,
        WwwAndroidcentralComExtractor,
        WwwSiComExtractor,
        WwwRawstoryComExtractor,
        WwwCnetComExtractor,
        WwwCinemablendComExtractor,
        WwwTodayComExtractor,
        WwwHowtogeekComExtractor,
        WwwAlComExtractor,
        WwwThepennyhoarderComExtractor,
        WwwWesternjournalismComExtractor,
        FusionNetExtractor,
        WwwAmericanowComExtractor,
        ScienceflyComExtractor,
        HellogigglesComExtractor,
        ThoughtcatalogComExtractor,
        WwwNjComExtractor,
        WwwInquisitrComExtractor,
        WwwNbcnewsComExtractor,
        FortuneComExtractor,
        WwwLinkedinComExtractor,
        ObamawhitehouseArchivesGovExtractor,
        WwwOpposingviewsComExtractor,
        WwwProspectmagazineCoUkExtractor,
        ForwardComExtractor,
        WwwQdailyComExtractor,
        GothamistComExtractor,
        WwwFoolComExtractor,
        WwwSlateComExtractor,
        IciRadioCanadaCaExtractor,
        WwwFortinetComExtractor,
        WwwFastcompanyComExtractor,
        BlisterreviewComExtractor,
        NewsMynaviJpExtractor,
        ClinicaltrialsGovExtractor,
        GithubComExtractor,
        WwwRedditComExtractor,
        OtrsComExtractor,
        WwwOssnewsJpExtractor,
        BuzzapJpExtractor,
        WwwAsahiComExtractor,
        WwwSanwaCoJpExtractor,
        WwwElecomCoJpExtractor,
        ScanNetsecurityNeJpExtractor,
        JvndbJvnJpExtractor,
        GeniusComExtractor,
        WwwJnsaOrgExtractor,
        PhpspotOrgExtractor,
        WwwInfoqComExtractor,
        WwwMoongiftJpExtractor,
        WwwItmediaCoJpExtractor,
        WwwPublickey1JpExtractor,
        TakagihiromitsuJpExtractor,
        BookwalkerJpExtractor,
        WwwYomiuriCoJpExtractor,
        JapanCnetComExtractor,
        DeadlineComExtractor,
        WwwGizmodoJpExtractor,
        GetnewsJpExtractor,
        WwwLifehackerJpExtractor,
        SectIijAdJpExtractor,
        WwwOreillyCoJpExtractor,
        WwwIpaGoJpExtractor,
        WeeklyAsciiJpExtractor,
        TechlogIijAdJpExtractor,
        WiredJpExtractor,
        JapanZdnetComExtractor,
        WwwRbbtodayComExtractor,
        WwwLemondeFrExtractor,
        WwwPhoronixComExtractor,
        PitchforkComExtractor,
        BiorxivOrgExtractor,
        EpaperZeitDeExtractor,
        WwwLadbibleComExtractor,
        TimesofindiaIndiatimesComExtractor,
        MaTtiasBeExtractor,
        PastebinComExtractor,
        WwwAbendblattDeExtractor,
        WwwGrueneDeExtractor,
        WwwEngadgetComExtractor,
        ArstechnicaComExtractor,
        WwwNdtvComExtractor,
        SpektrumExtractor,
        PostlightComExtractor
      });
      var Extractors = _Object$keys(CustomExtractors).reduce(function(acc, key) {
        var extractor = CustomExtractors[key];
        return _objectSpread({}, acc, mergeSupportedDomains(extractor));
      }, {});
      var CLEAN_AUTHOR_RE = /^\s*(posted |written )?by\s*:?\s*(.*)/i;
      var TEXT_LINK_RE = new RegExp("http(s)?://", "i");
      var MS_DATE_STRING = /^\d{13}$/i;
      var SEC_DATE_STRING = /^\d{10}$/i;
      var CLEAN_DATE_STRING_RE = /^\s*published\s*:?\s*(.*)/i;
      var TIME_MERIDIAN_SPACE_RE = /(.*\d)(am|pm)(.*)/i;
      var TIME_MERIDIAN_DOTS_RE = /\.m\./i;
      var TIME_NOW_STRING = /^\s*(just|right)?\s*now\s*/i;
      var timeUnits = ["seconds?", "minutes?", "hours?", "days?", "weeks?", "months?", "years?"];
      var allTimeUnits = timeUnits.join("|");
      var TIME_AGO_STRING = new RegExp("(\\d+)\\s+(".concat(allTimeUnits, ")\\s+ago"), "i");
      var months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
      var allMonths = months.join("|");
      var timestamp1 = "[0-9]{1,2}:[0-9]{2,2}( ?[ap].?m.?)?";
      var timestamp2 = "[0-9]{1,2}[/-][0-9]{1,2}[/-][0-9]{2,4}";
      var timestamp3 = "-[0-9]{3,4}$";
      var SPLIT_DATE_STRING = new RegExp("(".concat(timestamp1, ")|(").concat(timestamp2, ")|(").concat(timestamp3, ")|([0-9]{1,4})|(").concat(allMonths, ")"), "ig");
      var TIME_WITH_OFFSET_RE = /-\d{3,4}$/;
      var TITLE_SPLITTERS_RE = /(: | - | \| )/g;
      var DOMAIN_ENDINGS_RE = new RegExp(".com$|.net$|.org$|.co.uk$", "g");
      function cleanAuthor(author) {
        return normalizeSpaces(author.replace(CLEAN_AUTHOR_RE, "$2").trim());
      }
      function clean$1(leadImageUrl) {
        leadImageUrl = leadImageUrl.trim();
        if (validUrl.isWebUri(leadImageUrl)) {
          return leadImageUrl;
        }
        return null;
      }
      function cleanDek(dek, _ref) {
        var $2 = _ref.$, excerpt = _ref.excerpt;
        if (dek.length > 1e3 || dek.length < 5)
          return null;
        if (excerpt && excerptContent(excerpt, 10) === excerptContent(dek, 10))
          return null;
        var dekText = stripTags(dek, $2);
        if (TEXT_LINK_RE.test(dekText))
          return null;
        return normalizeSpaces(dekText.trim());
      }
      function cleanDateString(dateString) {
        return (dateString.match(SPLIT_DATE_STRING) || []).join(" ").replace(TIME_MERIDIAN_DOTS_RE, "m").replace(TIME_MERIDIAN_SPACE_RE, "$1 $2 $3").replace(CLEAN_DATE_STRING_RE, "$1").trim();
      }
      function createDate(dateString, timezone, format) {
        if (TIME_WITH_OFFSET_RE.test(dateString)) {
          return moment(new Date(dateString));
        }
        if (TIME_AGO_STRING.test(dateString)) {
          var fragments = TIME_AGO_STRING.exec(dateString);
          return moment().subtract(fragments[1], fragments[2]);
        }
        if (TIME_NOW_STRING.test(dateString)) {
          return moment();
        }
        return timezone ? moment.tz(dateString, format || parseFormat(dateString), timezone) : moment(dateString, format || parseFormat(dateString));
      }
      function cleanDatePublished(dateString) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, timezone = _ref.timezone, format = _ref.format;
        if (MS_DATE_STRING.test(dateString)) {
          return new Date(_parseInt(dateString, 10)).toISOString();
        }
        if (SEC_DATE_STRING.test(dateString)) {
          return new Date(_parseInt(dateString, 10) * 1e3).toISOString();
        }
        var date = createDate(dateString, timezone, format);
        if (!date.isValid()) {
          dateString = cleanDateString(dateString);
          date = createDate(dateString, timezone, format);
        }
        return date.isValid() ? date.toISOString() : null;
      }
      function extractCleanNode(article, _ref) {
        var $2 = _ref.$, _ref$cleanConditional = _ref.cleanConditionally, cleanConditionally = _ref$cleanConditional === void 0 ? true : _ref$cleanConditional, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, _ref$url = _ref.url, url = _ref$url === void 0 ? "" : _ref$url, _ref$defaultCleaner = _ref.defaultCleaner, defaultCleaner = _ref$defaultCleaner === void 0 ? true : _ref$defaultCleaner;
        rewriteTopLevel$$1(article, $2);
        if (defaultCleaner)
          cleanImages(article, $2);
        makeLinksAbsolute$$1(article, $2, url);
        markToKeep(article, $2, url);
        stripJunkTags(article, $2);
        cleanHOnes$$1(article, $2);
        cleanHeaders(article, $2, title);
        if (defaultCleaner)
          cleanTags$$1(article, $2, cleanConditionally);
        removeEmpty(article, $2);
        cleanAttributes$$1(article, $2);
        return article;
      }
      function cleanTitle$$1(title, _ref) {
        var url = _ref.url, $2 = _ref.$;
        if (TITLE_SPLITTERS_RE.test(title)) {
          title = resolveSplitTitle(title, url);
        }
        if (title.length > 150) {
          var h1 = $2("h1");
          if (h1.length === 1) {
            title = h1.text();
          }
        }
        return normalizeSpaces(stripTags(title, $2).trim());
      }
      function extractBreadcrumbTitle(splitTitle, text) {
        if (splitTitle.length >= 6) {
          var termCounts = splitTitle.reduce(function(acc, titleText) {
            acc[titleText] = acc[titleText] ? acc[titleText] + 1 : 1;
            return acc;
          }, {});
          var _Reflect$ownKeys$redu = _Reflect$ownKeys(termCounts).reduce(function(acc, key) {
            if (acc[1] < termCounts[key]) {
              return [key, termCounts[key]];
            }
            return acc;
          }, [0, 0]), _Reflect$ownKeys$redu2 = _slicedToArray(_Reflect$ownKeys$redu, 2), maxTerm = _Reflect$ownKeys$redu2[0], termCount = _Reflect$ownKeys$redu2[1];
          if (termCount >= 2 && maxTerm.length <= 4) {
            splitTitle = text.split(maxTerm);
          }
          var splitEnds = [splitTitle[0], splitTitle.slice(-1)];
          var longestEnd = splitEnds.reduce(function(acc, end) {
            return acc.length > end.length ? acc : end;
          }, "");
          if (longestEnd.length > 10) {
            return longestEnd;
          }
          return text;
        }
        return null;
      }
      function cleanDomainFromTitle(splitTitle, url) {
        var _URL$parse = URL.parse(url), host = _URL$parse.host;
        var nakedDomain = host.replace(DOMAIN_ENDINGS_RE, "");
        var startSlug = splitTitle[0].toLowerCase().replace(" ", "");
        var startSlugRatio = wuzzy.levenshtein(startSlug, nakedDomain);
        if (startSlugRatio > 0.4 && startSlug.length > 5) {
          return splitTitle.slice(2).join("");
        }
        var endSlug = splitTitle.slice(-1)[0].toLowerCase().replace(" ", "");
        var endSlugRatio = wuzzy.levenshtein(endSlug, nakedDomain);
        if (endSlugRatio > 0.4 && endSlug.length >= 5) {
          return splitTitle.slice(0, -2).join("");
        }
        return null;
      }
      function resolveSplitTitle(title) {
        var url = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        var splitTitle = title.split(TITLE_SPLITTERS_RE);
        if (splitTitle.length === 1) {
          return title;
        }
        var newTitle = extractBreadcrumbTitle(splitTitle, title);
        if (newTitle)
          return newTitle;
        newTitle = cleanDomainFromTitle(splitTitle, url);
        if (newTitle)
          return newTitle;
        return title;
      }
      var Cleaners = {
        author: cleanAuthor,
        lead_image_url: clean$1,
        dek: cleanDek,
        date_published: cleanDatePublished,
        content: extractCleanNode,
        title: cleanTitle$$1
      };
      function extractBestNode($2, opts) {
        if (opts.stripUnlikelyCandidates) {
          $2 = stripUnlikelyCandidates($2);
        }
        $2 = convertToParagraphs$$1($2);
        $2 = scoreContent$$1($2, opts.weightNodes);
        var $topCandidate = findTopCandidate$$1($2);
        return $topCandidate;
      }
      var GenericContentExtractor = {
        defaultOpts: {
          stripUnlikelyCandidates: true,
          weightNodes: true,
          cleanConditionally: true
        },
        // Extract the content for this resource - initially, pass in our
        // most restrictive opts which will return the highest quality
        // content. On each failure, retry with slightly more lax opts.
        //
        // :param return_type: string. If "node", should return the content
        // as a cheerio node rather than as an HTML string.
        //
        // Opts:
        // stripUnlikelyCandidates: Remove any elements that match
        // non-article-like criteria first.(Like, does this element
        //   have a classname of "comment")
        //
        // weightNodes: Modify an elements score based on whether it has
        // certain classNames or IDs. Examples: Subtract if a node has
        // a className of 'comment', Add if a node has an ID of
        // 'entry-content'.
        //
        // cleanConditionally: Clean the node to return of some
        // superfluous content. Things like forms, ads, etc.
        extract: function extract(_ref, opts) {
          var $2 = _ref.$, html = _ref.html, title = _ref.title, url = _ref.url;
          opts = _objectSpread({}, this.defaultOpts, opts);
          $2 = $2 || cheerio.load(html);
          var node = this.getContentNode($2, title, url, opts);
          if (nodeIsSufficient(node)) {
            return this.cleanAndReturnNode(node, $2);
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = _getIterator(_Reflect$ownKeys(opts).filter(function(k) {
              return opts[k] === true;
            })), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var key = _step.value;
              opts[key] = false;
              $2 = cheerio.load(html);
              node = this.getContentNode($2, title, url, opts);
              if (nodeIsSufficient(node)) {
                break;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return this.cleanAndReturnNode(node, $2);
        },
        // Get node given current options
        getContentNode: function getContentNode($2, title, url, opts) {
          return extractCleanNode(extractBestNode($2, opts), {
            $: $2,
            cleanConditionally: opts.cleanConditionally,
            title,
            url
          });
        },
        // Once we got here, either we're at our last-resort node, or
        // we broke early. Make sure we at least have -something- before we
        // move forward.
        cleanAndReturnNode: function cleanAndReturnNode(node, $2) {
          if (!node) {
            return null;
          }
          return normalizeSpaces($2.html(node));
        }
      };
      var STRONG_TITLE_META_TAGS = ["tweetmeme-title", "dc.title", "rbtitle", "headline", "title"];
      var WEAK_TITLE_META_TAGS = ["og:title"];
      var STRONG_TITLE_SELECTORS = [".hentry .entry-title", "h1#articleHeader", "h1.articleHeader", "h1.article", ".instapaper_title", "#meebo-title"];
      var WEAK_TITLE_SELECTORS = ["article h1", "#entry-title", ".entry-title", "#entryTitle", "#entrytitle", ".entryTitle", ".entrytitle", "#articleTitle", ".articleTitle", "post post-title", "h1.title", "h2.article", "h1", "html head title", "title"];
      var GenericTitleExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, url = _ref.url, metaCache = _ref.metaCache;
          var title;
          title = extractFromMeta$$1($2, STRONG_TITLE_META_TAGS, metaCache);
          if (title)
            return cleanTitle$$1(title, {
              url,
              $: $2
            });
          title = extractFromSelectors$$1($2, STRONG_TITLE_SELECTORS);
          if (title)
            return cleanTitle$$1(title, {
              url,
              $: $2
            });
          title = extractFromMeta$$1($2, WEAK_TITLE_META_TAGS, metaCache);
          if (title)
            return cleanTitle$$1(title, {
              url,
              $: $2
            });
          title = extractFromSelectors$$1($2, WEAK_TITLE_SELECTORS);
          if (title)
            return cleanTitle$$1(title, {
              url,
              $: $2
            });
          return "";
        }
      };
      var AUTHOR_META_TAGS = ["byl", "clmst", "dc.author", "dcsext.author", "dc.creator", "rbauthors", "authors"];
      var AUTHOR_MAX_LENGTH = 300;
      var AUTHOR_SELECTORS = [".entry .entry-author", ".author.vcard .fn", ".author .vcard .fn", ".byline.vcard .fn", ".byline .vcard .fn", ".byline .by .author", ".byline .by", ".byline .author", ".post-author.vcard", ".post-author .vcard", "a[rel=author]", "#by_author", ".by_author", "#entryAuthor", ".entryAuthor", ".byline a[href*=author]", "#author .authorname", ".author .authorname", "#author", ".author", ".articleauthor", ".ArticleAuthor", ".byline"];
      var bylineRe = /^[\n\s]*By/i;
      var BYLINE_SELECTORS_RE = [["#byline", bylineRe], [".byline", bylineRe]];
      var GenericAuthorExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, metaCache = _ref.metaCache;
          var author;
          author = extractFromMeta$$1($2, AUTHOR_META_TAGS, metaCache);
          if (author && author.length < AUTHOR_MAX_LENGTH) {
            return cleanAuthor(author);
          }
          author = extractFromSelectors$$1($2, AUTHOR_SELECTORS, 2);
          if (author && author.length < AUTHOR_MAX_LENGTH) {
            return cleanAuthor(author);
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = _getIterator(BYLINE_SELECTORS_RE), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2), selector = _step$value[0], regex = _step$value[1];
              var node = $2(selector);
              if (node.length === 1) {
                var text = node.text();
                if (regex.test(text)) {
                  return cleanAuthor(text);
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return null;
        }
      };
      var DATE_PUBLISHED_META_TAGS = ["article:published_time", "displaydate", "dc.date", "dc.date.issued", "rbpubdate", "publish_date", "pub_date", "pagedate", "pubdate", "revision_date", "doc_date", "date_created", "content_create_date", "lastmodified", "created", "date"];
      var DATE_PUBLISHED_SELECTORS = [".hentry .dtstamp.published", ".hentry .published", ".hentry .dtstamp.updated", ".hentry .updated", ".single .published", ".meta .published", ".meta .postDate", ".entry-date", ".byline .date", ".postmetadata .date", ".article_datetime", ".date-header", ".story-date", ".dateStamp", "#story .datetime", ".dateline", ".pubdate"];
      var abbrevMonthsStr = "(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)";
      var DATE_PUBLISHED_URL_RES = [new RegExp("/(20\\d{2}/\\d{2}/\\d{2})/", "i"), new RegExp("(20\\d{2}-[01]\\d-[0-3]\\d)", "i"), new RegExp("/(20\\d{2}/".concat(abbrevMonthsStr, "/[0-3]\\d)/"), "i")];
      var GenericDatePublishedExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, url = _ref.url, metaCache = _ref.metaCache;
          var datePublished;
          datePublished = extractFromMeta$$1($2, DATE_PUBLISHED_META_TAGS, metaCache, false);
          if (datePublished)
            return cleanDatePublished(datePublished);
          datePublished = extractFromSelectors$$1($2, DATE_PUBLISHED_SELECTORS);
          if (datePublished)
            return cleanDatePublished(datePublished);
          datePublished = extractFromUrl(url, DATE_PUBLISHED_URL_RES);
          if (datePublished)
            return cleanDatePublished(datePublished);
          return null;
        }
      };
      var GenericDekExtractor = {
        extract: function extract() {
          return null;
        }
      };
      var LEAD_IMAGE_URL_META_TAGS = ["og:image", "twitter:image", "image_src"];
      var LEAD_IMAGE_URL_SELECTORS = ["link[rel=image_src]"];
      var POSITIVE_LEAD_IMAGE_URL_HINTS = ["upload", "wp-content", "large", "photo", "wp-image"];
      var POSITIVE_LEAD_IMAGE_URL_HINTS_RE = new RegExp(POSITIVE_LEAD_IMAGE_URL_HINTS.join("|"), "i");
      var NEGATIVE_LEAD_IMAGE_URL_HINTS = ["spacer", "sprite", "blank", "throbber", "gradient", "tile", "bg", "background", "icon", "social", "header", "hdr", "advert", "spinner", "loader", "loading", "default", "rating", "share", "facebook", "twitter", "theme", "promo", "ads", "wp-includes"];
      var NEGATIVE_LEAD_IMAGE_URL_HINTS_RE = new RegExp(NEGATIVE_LEAD_IMAGE_URL_HINTS.join("|"), "i");
      var GIF_RE = /\.gif(\?.*)?$/i;
      var JPG_RE = /\.jpe?g(\?.*)?$/i;
      function getSig($node) {
        return "".concat($node.attr("class") || "", " ").concat($node.attr("id") || "");
      }
      function scoreImageUrl(url) {
        url = url.trim();
        var score = 0;
        if (POSITIVE_LEAD_IMAGE_URL_HINTS_RE.test(url)) {
          score += 20;
        }
        if (NEGATIVE_LEAD_IMAGE_URL_HINTS_RE.test(url)) {
          score -= 20;
        }
        if (GIF_RE.test(url)) {
          score -= 10;
        }
        if (JPG_RE.test(url)) {
          score += 10;
        }
        return score;
      }
      function scoreAttr($img) {
        if ($img.attr("alt")) {
          return 5;
        }
        return 0;
      }
      function scoreByParents($img) {
        var score = 0;
        var $figParent = $img.parents("figure").first();
        if ($figParent.length === 1) {
          score += 25;
        }
        var $parent = $img.parent();
        var $gParent;
        if ($parent.length === 1) {
          $gParent = $parent.parent();
        }
        [$parent, $gParent].forEach(function($node) {
          if (PHOTO_HINTS_RE$1.test(getSig($node))) {
            score += 15;
          }
        });
        return score;
      }
      function scoreBySibling($img) {
        var score = 0;
        var $sibling = $img.next();
        var sibling = $sibling.get(0);
        if (sibling && sibling.tagName.toLowerCase() === "figcaption") {
          score += 25;
        }
        if (PHOTO_HINTS_RE$1.test(getSig($sibling))) {
          score += 15;
        }
        return score;
      }
      function scoreByDimensions($img) {
        var score = 0;
        var width = _parseFloat($img.attr("width"));
        var height = _parseFloat($img.attr("height"));
        var src = $img.attr("src");
        if (width && width <= 50) {
          score -= 50;
        }
        if (height && height <= 50) {
          score -= 50;
        }
        if (width && height && !src.includes("sprite")) {
          var area = width * height;
          if (area < 5e3) {
            score -= 100;
          } else {
            score += Math.round(area / 1e3);
          }
        }
        return score;
      }
      function scoreByPosition($imgs, index) {
        return $imgs.length / 2 - index;
      }
      var GenericLeadImageUrlExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, content = _ref.content, metaCache = _ref.metaCache, html = _ref.html;
          var cleanUrl;
          if (!$2.browser && $2("head").length === 0) {
            $2("*").first().prepend(html);
          }
          var imageUrl = extractFromMeta$$1($2, LEAD_IMAGE_URL_META_TAGS, metaCache, false);
          if (imageUrl) {
            cleanUrl = clean$1(imageUrl);
            if (cleanUrl)
              return cleanUrl;
          }
          var $content = $2(content);
          var imgs = $2("img", $content).toArray();
          var imgScores = {};
          imgs.forEach(function(img, index) {
            var $img = $2(img);
            var src2 = $img.attr("src");
            if (!src2)
              return;
            var score = scoreImageUrl(src2);
            score += scoreAttr($img);
            score += scoreByParents($img);
            score += scoreBySibling($img);
            score += scoreByDimensions($img);
            score += scoreByPosition(imgs, index);
            imgScores[src2] = score;
          });
          var _Reflect$ownKeys$redu = _Reflect$ownKeys(imgScores).reduce(function(acc, key) {
            return imgScores[key] > acc[1] ? [key, imgScores[key]] : acc;
          }, [null, 0]), _Reflect$ownKeys$redu2 = _slicedToArray(_Reflect$ownKeys$redu, 2), topUrl = _Reflect$ownKeys$redu2[0], topScore = _Reflect$ownKeys$redu2[1];
          if (topScore > 0) {
            cleanUrl = clean$1(topUrl);
            if (cleanUrl)
              return cleanUrl;
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = _getIterator(LEAD_IMAGE_URL_SELECTORS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var selector = _step.value;
              var $node = $2(selector).first();
              var src = $node.attr("src");
              if (src) {
                cleanUrl = clean$1(src);
                if (cleanUrl)
                  return cleanUrl;
              }
              var href = $node.attr("href");
              if (href) {
                cleanUrl = clean$1(href);
                if (cleanUrl)
                  return cleanUrl;
              }
              var value = $node.attr("value");
              if (value) {
                cleanUrl = clean$1(value);
                if (cleanUrl)
                  return cleanUrl;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return null;
        }
      };
      function scoreSimilarity(score, articleUrl, href) {
        if (score > 0) {
          var similarity = new difflib.SequenceMatcher(null, articleUrl, href).ratio();
          var diffPercent = 1 - similarity;
          var diffModifier = -(250 * (diffPercent - 0.2));
          return score + diffModifier;
        }
        return 0;
      }
      function scoreLinkText(linkText, pageNum) {
        var score = 0;
        if (IS_DIGIT_RE.test(linkText.trim())) {
          var linkTextAsNum = _parseInt(linkText, 10);
          if (linkTextAsNum < 2) {
            score = -30;
          } else {
            score = Math.max(0, 10 - linkTextAsNum);
          }
          if (pageNum && pageNum >= linkTextAsNum) {
            score -= 50;
          }
        }
        return score;
      }
      function scorePageInLink(pageNum, isWp) {
        if (pageNum && !isWp) {
          return 50;
        }
        return 0;
      }
      var DIGIT_RE$2 = /\d/;
      var EXTRANEOUS_LINK_HINTS$1 = ["print", "archive", "comment", "discuss", "e-mail", "email", "share", "reply", "all", "login", "sign", "single", "adx", "entry-unrelated"];
      var EXTRANEOUS_LINK_HINTS_RE$1 = new RegExp(EXTRANEOUS_LINK_HINTS$1.join("|"), "i");
      var NEXT_LINK_TEXT_RE$1 = new RegExp("(next|weiter|continue|>([^|]|$)|\xBB([^|]|$))", "i");
      var CAP_LINK_TEXT_RE$1 = new RegExp("(first|last|end)", "i");
      var PREV_LINK_TEXT_RE$1 = new RegExp("(prev|earl|old|new|<|\xAB)", "i");
      function scoreExtraneousLinks(href) {
        if (EXTRANEOUS_LINK_HINTS_RE$1.test(href)) {
          return -25;
        }
        return 0;
      }
      function makeSig($link) {
        return "".concat($link.attr("class") || "", " ").concat($link.attr("id") || "");
      }
      function scoreByParents$1($link) {
        var $parent = $link.parent();
        var positiveMatch = false;
        var negativeMatch = false;
        var score = 0;
        _Array$from(range(0, 4)).forEach(function() {
          if ($parent.length === 0) {
            return;
          }
          var parentData = makeSig($parent, " ");
          if (!positiveMatch && PAGE_RE.test(parentData)) {
            positiveMatch = true;
            score += 25;
          }
          if (!negativeMatch && NEGATIVE_SCORE_RE.test(parentData) && EXTRANEOUS_LINK_HINTS_RE$1.test(parentData)) {
            if (!POSITIVE_SCORE_RE.test(parentData)) {
              negativeMatch = true;
              score -= 25;
            }
          }
          $parent = $parent.parent();
        });
        return score;
      }
      function scorePrevLink(linkData) {
        if (PREV_LINK_TEXT_RE$1.test(linkData)) {
          return -200;
        }
        return 0;
      }
      function shouldScore(href, articleUrl, baseUrl, parsedUrl, linkText, previousUrls) {
        if (previousUrls.find(function(url) {
          return href === url;
        }) !== void 0) {
          return false;
        }
        if (!href || href === articleUrl || href === baseUrl) {
          return false;
        }
        var hostname = parsedUrl.hostname;
        var _URL$parse = URL.parse(href), linkHost = _URL$parse.hostname;
        if (linkHost !== hostname) {
          return false;
        }
        var fragment = href.replace(baseUrl, "");
        if (!DIGIT_RE$2.test(fragment)) {
          return false;
        }
        if (EXTRANEOUS_LINK_HINTS_RE$1.test(linkText)) {
          return false;
        }
        if (linkText.length > 25) {
          return false;
        }
        return true;
      }
      function scoreBaseUrl(href, baseRegex) {
        if (!baseRegex.test(href)) {
          return -25;
        }
        return 0;
      }
      function scoreNextLinkText(linkData) {
        if (NEXT_LINK_TEXT_RE$1.test(linkData)) {
          return 50;
        }
        return 0;
      }
      function scoreCapLinks(linkData) {
        if (CAP_LINK_TEXT_RE$1.test(linkData)) {
          if (NEXT_LINK_TEXT_RE$1.test(linkData)) {
            return -65;
          }
        }
        return 0;
      }
      function makeBaseRegex(baseUrl) {
        return new RegExp("^".concat(baseUrl), "i");
      }
      function makeSig$1($link, linkText) {
        return "".concat(linkText || $link.text(), " ").concat($link.attr("class") || "", " ").concat($link.attr("id") || "");
      }
      function scoreLinks(_ref) {
        var links = _ref.links, articleUrl = _ref.articleUrl, baseUrl = _ref.baseUrl, parsedUrl = _ref.parsedUrl, $2 = _ref.$, _ref$previousUrls = _ref.previousUrls, previousUrls = _ref$previousUrls === void 0 ? [] : _ref$previousUrls;
        parsedUrl = parsedUrl || URL.parse(articleUrl);
        var baseRegex = makeBaseRegex(baseUrl);
        var isWp = isWordpress($2);
        var scoredPages = links.reduce(function(possiblePages, link) {
          var attrs = getAttrs(link);
          if (!attrs.href)
            return possiblePages;
          var href = removeAnchor(attrs.href);
          var $link = $2(link);
          var linkText = $link.text();
          if (!shouldScore(href, articleUrl, baseUrl, parsedUrl, linkText, previousUrls)) {
            return possiblePages;
          }
          if (!possiblePages[href]) {
            possiblePages[href] = {
              score: 0,
              linkText,
              href
            };
          } else {
            possiblePages[href].linkText = "".concat(possiblePages[href].linkText, "|").concat(linkText);
          }
          var possiblePage = possiblePages[href];
          var linkData = makeSig$1($link, linkText);
          var pageNum = pageNumFromUrl(href);
          var score = scoreBaseUrl(href, baseRegex);
          score += scoreNextLinkText(linkData);
          score += scoreCapLinks(linkData);
          score += scorePrevLink(linkData);
          score += scoreByParents$1($link);
          score += scoreExtraneousLinks(href);
          score += scorePageInLink(pageNum, isWp);
          score += scoreLinkText(linkText, pageNum);
          score += scoreSimilarity(score, articleUrl, href);
          possiblePage.score = score;
          return possiblePages;
        }, {});
        return _Reflect$ownKeys(scoredPages).length === 0 ? null : scoredPages;
      }
      var GenericNextPageUrlExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, url = _ref.url, parsedUrl = _ref.parsedUrl, _ref$previousUrls = _ref.previousUrls, previousUrls = _ref$previousUrls === void 0 ? [] : _ref$previousUrls;
          parsedUrl = parsedUrl || URL.parse(url);
          var articleUrl = removeAnchor(url);
          var baseUrl = articleBaseUrl(url, parsedUrl);
          var links = $2("a[href]").toArray();
          var scoredLinks = scoreLinks({
            links,
            articleUrl,
            baseUrl,
            parsedUrl,
            $: $2,
            previousUrls
          });
          if (!scoredLinks)
            return null;
          var topPage = _Reflect$ownKeys(scoredLinks).reduce(function(acc, link) {
            var scoredLink = scoredLinks[link];
            return scoredLink.score > acc.score ? scoredLink : acc;
          }, {
            score: -100
          });
          if (topPage.score >= 50) {
            return topPage.href;
          }
          return null;
        }
      };
      var CANONICAL_META_SELECTORS = ["og:url"];
      function parseDomain(url) {
        var parsedUrl = URL.parse(url);
        var hostname = parsedUrl.hostname;
        return hostname;
      }
      function result(url) {
        return {
          url,
          domain: parseDomain(url)
        };
      }
      var GenericUrlExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, url = _ref.url, metaCache = _ref.metaCache;
          var $canonical = $2("link[rel=canonical]");
          if ($canonical.length !== 0) {
            var href = $canonical.attr("href");
            if (href) {
              return result(href);
            }
          }
          var metaUrl = extractFromMeta$$1($2, CANONICAL_META_SELECTORS, metaCache);
          if (metaUrl) {
            return result(metaUrl);
          }
          return result(url);
        }
      };
      var EXCERPT_META_SELECTORS = ["og:description", "twitter:description"];
      function clean$2(content, $2) {
        var maxLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
        content = content.replace(/[\s\n]+/g, " ").trim();
        return ellipsize(content, maxLength, {
          ellipse: "&hellip;"
        });
      }
      var GenericExcerptExtractor = {
        extract: function extract(_ref) {
          var $2 = _ref.$, content = _ref.content, metaCache = _ref.metaCache;
          var excerpt = extractFromMeta$$1($2, EXCERPT_META_SELECTORS, metaCache);
          if (excerpt) {
            return clean$2(stripTags(excerpt, $2));
          }
          var maxLength = 200;
          var shortContent = content.slice(0, maxLength * 5);
          return clean$2($2(shortContent).text(), $2, maxLength);
        }
      };
      var getWordCount = function getWordCount2(content) {
        var $2 = cheerio.load(content);
        var $content = $2("div").first();
        var text = normalizeSpaces($content.text());
        return text.split(/\s/).length;
      };
      var getWordCountAlt = function getWordCountAlt2(content) {
        content = content.replace(/<[^>]*>/g, " ");
        content = content.replace(/\s+/g, " ");
        content = content.trim();
        return content.split(" ").length;
      };
      var GenericWordCountExtractor = {
        extract: function extract(_ref) {
          var content = _ref.content;
          var count = getWordCount(content);
          if (count === 1)
            count = getWordCountAlt(content);
          return count;
        }
      };
      var GenericExtractor = {
        // This extractor is the default for all domains
        domain: "*",
        title: GenericTitleExtractor.extract,
        date_published: GenericDatePublishedExtractor.extract,
        author: GenericAuthorExtractor.extract,
        content: GenericContentExtractor.extract.bind(GenericContentExtractor),
        lead_image_url: GenericLeadImageUrlExtractor.extract,
        dek: GenericDekExtractor.extract,
        next_page_url: GenericNextPageUrlExtractor.extract,
        url_and_domain: GenericUrlExtractor.extract,
        excerpt: GenericExcerptExtractor.extract,
        word_count: GenericWordCountExtractor.extract,
        direction: function direction(_ref) {
          var title = _ref.title;
          return stringDirection.getDirection(title);
        },
        extract: function extract(options) {
          var html = options.html, $2 = options.$;
          if (html && !$2) {
            var loaded = cheerio.load(html);
            options.$ = loaded;
          }
          var title = this.title(options);
          var date_published = this.date_published(options);
          var author = this.author(options);
          var content = this.content(_objectSpread({}, options, {
            title
          }));
          var lead_image_url = this.lead_image_url(_objectSpread({}, options, {
            content
          }));
          var dek = this.dek(_objectSpread({}, options, {
            content
          }));
          var next_page_url = this.next_page_url(options);
          var excerpt = this.excerpt(_objectSpread({}, options, {
            content
          }));
          var word_count = this.word_count(_objectSpread({}, options, {
            content
          }));
          var direction = this.direction({
            title
          });
          var _this$url_and_domain = this.url_and_domain(options), url = _this$url_and_domain.url, domain = _this$url_and_domain.domain;
          return {
            title,
            author,
            date_published: date_published || null,
            dek,
            lead_image_url,
            content,
            next_page_url,
            url,
            domain,
            excerpt,
            word_count,
            direction
          };
        }
      };
      var Detectors = {
        'meta[name="al:ios:app_name"][value="Medium"]': MediumExtractor,
        'meta[name="generator"][value="blogger"]': BloggerExtractor
      };
      function detectByHtml($2) {
        var selector = _Reflect$ownKeys(Detectors).find(function(s) {
          return $2(s).length > 0;
        });
        return Detectors[selector];
      }
      function getExtractor(url, parsedUrl, $2) {
        parsedUrl = parsedUrl || URL.parse(url);
        var _parsedUrl = parsedUrl, hostname = _parsedUrl.hostname;
        var baseDomain = hostname.split(".").slice(-2).join(".");
        return apiExtractors[hostname] || apiExtractors[baseDomain] || Extractors[hostname] || Extractors[baseDomain] || detectByHtml($2) || GenericExtractor;
      }
      function cleanBySelectors($content, $2, _ref) {
        var clean2 = _ref.clean;
        if (!clean2)
          return $content;
        $2(clean2.join(","), $content).remove();
        return $content;
      }
      function transformElements($content, $2, _ref2) {
        var transforms = _ref2.transforms;
        if (!transforms)
          return $content;
        _Reflect$ownKeys(transforms).forEach(function(key) {
          var $matches = $2(key, $content);
          var value = transforms[key];
          if (typeof value === "string") {
            $matches.each(function(index, node) {
              convertNodeTo$$1($2(node), $2, transforms[key]);
            });
          } else if (typeof value === "function") {
            $matches.each(function(index, node) {
              var result2 = value($2(node), $2);
              if (typeof result2 === "string") {
                convertNodeTo$$1($2(node), $2, result2);
              }
            });
          }
        });
        return $content;
      }
      function findMatchingSelector($2, selectors, extractHtml, allowMultiple) {
        return selectors.find(function(selector) {
          if (_Array$isArray(selector)) {
            if (extractHtml) {
              return selector.reduce(function(acc, s2) {
                return acc && $2(s2).length > 0;
              }, true);
            }
            var _selector = _slicedToArray(selector, 2), s = _selector[0], attr = _selector[1];
            return (allowMultiple || !allowMultiple && $2(s).length === 1) && $2(s).attr(attr) && $2(s).attr(attr).trim() !== "";
          }
          return (allowMultiple || !allowMultiple && $2(selector).length === 1) && $2(selector).text().trim() !== "";
        });
      }
      function select(opts) {
        var $2 = opts.$, type = opts.type, extractionOpts = opts.extractionOpts, _opts$extractHtml = opts.extractHtml, extractHtml = _opts$extractHtml === void 0 ? false : _opts$extractHtml;
        if (!extractionOpts)
          return null;
        if (typeof extractionOpts === "string")
          return extractionOpts;
        var selectors = extractionOpts.selectors, _extractionOpts$defau = extractionOpts.defaultCleaner, defaultCleaner = _extractionOpts$defau === void 0 ? true : _extractionOpts$defau, allowMultiple = extractionOpts.allowMultiple;
        var overrideAllowMultiple = type === "lead_image_url" || allowMultiple;
        var matchingSelector = findMatchingSelector($2, selectors, extractHtml, overrideAllowMultiple);
        if (!matchingSelector)
          return null;
        function transformAndClean($node) {
          makeLinksAbsolute$$1($node, $2, opts.url || "");
          cleanBySelectors($node, $2, extractionOpts);
          transformElements($node, $2, extractionOpts);
          return $node;
        }
        function selectHtml() {
          var $content;
          if (_Array$isArray(matchingSelector)) {
            $content = $2(matchingSelector.join(","));
            var $wrapper = $2("<div></div>");
            $content.each(function(_, element) {
              $wrapper.append(element);
            });
            $content = $wrapper;
          } else {
            $content = $2(matchingSelector);
          }
          $content.wrap($2("<div></div>"));
          $content = $content.parent();
          $content = transformAndClean($content);
          if (Cleaners[type]) {
            Cleaners[type]($content, _objectSpread({}, opts, {
              defaultCleaner
            }));
          }
          if (allowMultiple) {
            return $content.children().toArray().map(function(el) {
              return $2.html($2(el));
            });
          }
          return $2.html($content);
        }
        if (extractHtml) {
          return selectHtml(matchingSelector);
        }
        var $match;
        var result2;
        if (_Array$isArray(matchingSelector)) {
          var _matchingSelector = _slicedToArray(matchingSelector, 3), selector = _matchingSelector[0], attr = _matchingSelector[1], transform = _matchingSelector[2];
          $match = $2(selector);
          $match = transformAndClean($match);
          result2 = $match.map(function(_, el) {
            var item = $2(el).attr(attr).trim();
            return transform ? transform(item) : item;
          });
        } else {
          $match = $2(matchingSelector);
          $match = transformAndClean($match);
          result2 = $match.map(function(_, el) {
            return $2(el).text().trim();
          });
        }
        result2 = _Array$isArray(result2.toArray()) && allowMultiple ? result2.toArray() : result2[0];
        if (defaultCleaner && Cleaners[type]) {
          return Cleaners[type](result2, _objectSpread({}, opts, extractionOpts));
        }
        return result2;
      }
      function selectExtendedTypes(extend, opts) {
        var results = {};
        _Reflect$ownKeys(extend).forEach(function(t) {
          if (!results[t]) {
            results[t] = select(_objectSpread({}, opts, {
              type: t,
              extractionOpts: extend[t]
            }));
          }
        });
        return results;
      }
      function extractResult(opts) {
        var type = opts.type, extractor = opts.extractor, _opts$fallback = opts.fallback, fallback = _opts$fallback === void 0 ? true : _opts$fallback;
        var result2 = select(_objectSpread({}, opts, {
          extractionOpts: extractor[type]
        }));
        if (result2) {
          return result2;
        }
        if (fallback)
          return GenericExtractor[type](opts);
        return null;
      }
      var RootExtractor = {
        extract: function extract() {
          var extractor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : GenericExtractor;
          var opts = arguments.length > 1 ? arguments[1] : void 0;
          var _opts = opts, contentOnly = _opts.contentOnly, extractedTitle = _opts.extractedTitle;
          if (extractor.domain === "*")
            return extractor.extract(opts);
          opts = _objectSpread({}, opts, {
            extractor
          });
          if (contentOnly) {
            var _content = extractResult(_objectSpread({}, opts, {
              type: "content",
              extractHtml: true,
              title: extractedTitle
            }));
            return {
              content: _content
            };
          }
          var title = extractResult(_objectSpread({}, opts, {
            type: "title"
          }));
          var date_published = extractResult(_objectSpread({}, opts, {
            type: "date_published"
          }));
          var author = extractResult(_objectSpread({}, opts, {
            type: "author"
          }));
          var next_page_url = extractResult(_objectSpread({}, opts, {
            type: "next_page_url"
          }));
          var content = extractResult(_objectSpread({}, opts, {
            type: "content",
            extractHtml: true,
            title
          }));
          var lead_image_url = extractResult(_objectSpread({}, opts, {
            type: "lead_image_url",
            content
          }));
          var excerpt = extractResult(_objectSpread({}, opts, {
            type: "excerpt",
            content
          }));
          var dek = extractResult(_objectSpread({}, opts, {
            type: "dek",
            content,
            excerpt
          }));
          var word_count = extractResult(_objectSpread({}, opts, {
            type: "word_count",
            content
          }));
          var direction = extractResult(_objectSpread({}, opts, {
            type: "direction",
            title
          }));
          var _ref3 = extractResult(_objectSpread({}, opts, {
            type: "url_and_domain"
          })) || {
            url: null,
            domain: null
          }, url = _ref3.url, domain = _ref3.domain;
          var extendedResults = {};
          if (extractor.extend) {
            extendedResults = selectExtendedTypes(extractor.extend, opts);
          }
          return _objectSpread({
            title,
            content,
            author,
            date_published,
            lead_image_url,
            dek,
            next_page_url,
            url,
            domain,
            excerpt,
            word_count,
            direction
          }, extendedResults);
        }
      };
      function collectAllPages(_x) {
        return _collectAllPages.apply(this, arguments);
      }
      function _collectAllPages() {
        _collectAllPages = _asyncToGenerator(
          /* @__PURE__ */ _regeneratorRuntime.mark(function _callee(_ref) {
            var next_page_url, html, $2, metaCache, result2, Extractor, title, url, pages, previousUrls, extractorOpts, nextPageResult, word_count;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    next_page_url = _ref.next_page_url, html = _ref.html, $2 = _ref.$, metaCache = _ref.metaCache, result2 = _ref.result, Extractor = _ref.Extractor, title = _ref.title, url = _ref.url;
                    pages = 1;
                    previousUrls = [removeAnchor(url)];
                  case 3:
                    if (!(next_page_url && pages < 26)) {
                      _context.next = 16;
                      break;
                    }
                    pages += 1;
                    _context.next = 7;
                    return Resource.create(next_page_url);
                  case 7:
                    $2 = _context.sent;
                    html = $2.html();
                    extractorOpts = {
                      url: next_page_url,
                      html,
                      $: $2,
                      metaCache,
                      extractedTitle: title,
                      previousUrls
                    };
                    nextPageResult = RootExtractor.extract(Extractor, extractorOpts);
                    previousUrls.push(next_page_url);
                    result2 = _objectSpread({}, result2, {
                      content: "".concat(result2.content, "<hr><h4>Page ").concat(pages, "</h4>").concat(nextPageResult.content)
                    });
                    next_page_url = nextPageResult.next_page_url;
                    _context.next = 3;
                    break;
                  case 16:
                    word_count = GenericExtractor.word_count({
                      content: "<div>".concat(result2.content, "</div>")
                    });
                    return _context.abrupt("return", _objectSpread({}, result2, {
                      total_pages: pages,
                      rendered_pages: pages,
                      word_count
                    }));
                  case 18:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          })
        );
        return _collectAllPages.apply(this, arguments);
      }
      var Parser2 = {
        parse: function() {
          var _parse = _asyncToGenerator(
            /* @__PURE__ */ _regeneratorRuntime.mark(function _callee(url) {
              var _ref, html, opts, _opts$fetchAllPages, fetchAllPages, _opts$fallback, fallback, _opts$contentType, contentType, _opts$headers, headers, extend, customExtractor, parsedUrl, $2, Extractor, metaCache, extendedTypes, result2, _result, title, next_page_url, turndownService, _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _ref = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {}, html = _ref.html, opts = _objectWithoutProperties(_ref, ["html"]);
                      _opts$fetchAllPages = opts.fetchAllPages, fetchAllPages = _opts$fetchAllPages === void 0 ? true : _opts$fetchAllPages, _opts$fallback = opts.fallback, fallback = _opts$fallback === void 0 ? true : _opts$fallback, _opts$contentType = opts.contentType, contentType = _opts$contentType === void 0 ? "html" : _opts$contentType, _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, extend = opts.extend, customExtractor = opts.customExtractor;
                      if (!url && cheerio.browser) {
                        url = window.location.href;
                        html = html || cheerio.html();
                      }
                      parsedUrl = URL.parse(url);
                      if (validateUrl(parsedUrl)) {
                        _context.next = 6;
                        break;
                      }
                      return _context.abrupt("return", {
                        error: true,
                        message: "The url parameter passed does not look like a valid URL. Please check your URL and try again."
                      });
                    case 6:
                      _context.next = 8;
                      return Resource.create(url, html, parsedUrl, headers);
                    case 8:
                      $2 = _context.sent;
                      if (!$2.failed) {
                        _context.next = 11;
                        break;
                      }
                      return _context.abrupt("return", $2);
                    case 11:
                      if (customExtractor) {
                        addExtractor(customExtractor);
                      }
                      Extractor = getExtractor(url, parsedUrl, $2);
                      if (!html) {
                        html = $2.html();
                      }
                      metaCache = $2("meta").map(function(_, node) {
                        return $2(node).attr("name");
                      }).toArray();
                      extendedTypes = {};
                      if (extend) {
                        extendedTypes = selectExtendedTypes(extend, {
                          $: $2,
                          url,
                          html
                        });
                      }
                      result2 = RootExtractor.extract(Extractor, {
                        url,
                        html,
                        $: $2,
                        metaCache,
                        parsedUrl,
                        fallback,
                        contentType
                      });
                      _result = result2, title = _result.title, next_page_url = _result.next_page_url;
                      if (!(fetchAllPages && next_page_url)) {
                        _context.next = 25;
                        break;
                      }
                      _context.next = 22;
                      return collectAllPages({
                        Extractor,
                        next_page_url,
                        html,
                        $: $2,
                        metaCache,
                        result: result2,
                        title,
                        url
                      });
                    case 22:
                      result2 = _context.sent;
                      _context.next = 26;
                      break;
                    case 25:
                      result2 = _objectSpread({}, result2, {
                        total_pages: 1,
                        rendered_pages: 1
                      });
                    case 26:
                      if (contentType === "markdown") {
                        turndownService = new TurndownService();
                        result2.content = turndownService.turndown(result2.content);
                      } else if (contentType === "text") {
                        result2.content = $2.text($2(result2.content));
                      }
                      return _context.abrupt("return", _objectSpread({}, result2, extendedTypes));
                    case 28:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            })
          );
          function parse(_x) {
            return _parse.apply(this, arguments);
          }
          return parse;
        }(),
        browser: !!cheerio.browser,
        // A convenience method for getting a resource
        // to work with, e.g., for custom extractor generator
        fetchResource: function fetchResource2(url) {
          return Resource.create(url);
        },
        addExtractor: function addExtractor$$1(extractor) {
          return addExtractor(extractor);
        }
      };
      module.exports = Parser2;
    }
  });

  // src/popup/popup.ts
  var import_webextension_polyfill4 = __toESM(require_browser_polyfill());

  // src/popup/ChatGPTProvider.ts
  var import_expiry_map = __toESM(require_dist2());

  // node_modules/eventsource-parser/dist/index.mjs
  function createParser(onParse) {
    let isFirstChunk;
    let buffer;
    let startingPosition;
    let startingFieldLength;
    let eventId;
    let eventName;
    let data;
    reset();
    return {
      feed,
      reset
    };
    function reset() {
      isFirstChunk = true;
      buffer = "";
      startingPosition = 0;
      startingFieldLength = -1;
      eventId = void 0;
      eventName = void 0;
      data = "";
    }
    function feed(chunk) {
      buffer = buffer ? buffer + chunk : chunk;
      if (isFirstChunk && hasBom(buffer)) {
        buffer = buffer.slice(BOM.length);
      }
      isFirstChunk = false;
      const length = buffer.length;
      let position = 0;
      let discardTrailingNewline = false;
      while (position < length) {
        if (discardTrailingNewline) {
          if (buffer[position] === "\n") {
            ++position;
          }
          discardTrailingNewline = false;
        }
        let lineLength = -1;
        let fieldLength = startingFieldLength;
        let character;
        for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
          character = buffer[index];
          if (character === ":" && fieldLength < 0) {
            fieldLength = index - position;
          } else if (character === "\r") {
            discardTrailingNewline = true;
            lineLength = index - position;
          } else if (character === "\n") {
            lineLength = index - position;
          }
        }
        if (lineLength < 0) {
          startingPosition = length - position;
          startingFieldLength = fieldLength;
          break;
        } else {
          startingPosition = 0;
          startingFieldLength = -1;
        }
        parseEventStreamLine(buffer, position, fieldLength, lineLength);
        position += lineLength + 1;
      }
      if (position === length) {
        buffer = "";
      } else if (position > 0) {
        buffer = buffer.slice(position);
      }
    }
    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
      if (lineLength === 0) {
        if (data.length > 0) {
          onParse({
            type: "event",
            id: eventId,
            event: eventName || void 0,
            data: data.slice(0, -1)
          });
          data = "";
          eventId = void 0;
        }
        eventName = void 0;
        return;
      }
      const noValue = fieldLength < 0;
      const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
      let step = 0;
      if (noValue) {
        step = lineLength;
      } else if (lineBuffer[index + fieldLength + 1] === " ") {
        step = fieldLength + 2;
      } else {
        step = fieldLength + 1;
      }
      const position = index + step;
      const valueLength = lineLength - step;
      const value = lineBuffer.slice(position, position + valueLength).toString();
      if (field === "data") {
        data += value ? "".concat(value, "\n") : "\n";
      } else if (field === "event") {
        eventName = value;
      } else if (field === "id" && !value.includes("\0")) {
        eventId = value;
      } else if (field === "retry") {
        const retry = parseInt(value, 10);
        if (!Number.isNaN(retry)) {
          onParse({
            type: "reconnect-interval",
            value: retry
          });
        }
      }
    }
  }
  var BOM = [239, 187, 191];
  function hasBom(buffer) {
    return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
  }

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // src/config/index.ts
  var import_webextension_polyfill = __toESM(require_browser_polyfill());
  var BASE_URL = "https://chat.openai.com";

  // src/utils/utils.ts
  var import_webextension_polyfill2 = __toESM(require_browser_polyfill());
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  var isFirefox = navigator.userAgent.indexOf("Firefox") != -1;
  var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  async function* streamAsyncIterable(stream) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return;
        }
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }

  // src/popup/ChatGPTProvider.ts
  var KEY_ACCESS_TOKEN = "accessToken";
  var cache = new import_expiry_map.default(10 * 1e3);
  async function request(token, method, path, data) {
    return fetch(`${BASE_URL}/backend-api${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`
      },
      body: data === void 0 ? void 0 : JSON.stringify(data)
    });
  }
  async function getChatGPTAccessToken() {
    if (cache.get(KEY_ACCESS_TOKEN)) {
      console.log(`use cache token}`);
      return cache.get(KEY_ACCESS_TOKEN);
    }
    const resp = await fetch(`${BASE_URL}/api/auth/session`);
    console.log(`resp.headers: ${resp.headers}, ${resp.body}`);
    if (resp.status === 403) {
      throw new Error("CLOUDFLARE");
    }
    const data = await resp.json().catch(() => ({}));
    if (!data.accessToken) {
      throw new Error("UNAUTHORIZED");
    }
    cache.set(KEY_ACCESS_TOKEN, data.accessToken);
    return data.accessToken;
  }
  async function setConversationProperty(token, conversationId, propertyObject) {
    await request(token, "PATCH", `/conversation/${conversationId}`, propertyObject);
  }
  var ChatGPTProvider = class {
    constructor(token) {
      this.token = token;
      this.token = token;
    }
    async fetchModels() {
      const resp = await request(this.token, "GET", "/models").then((r) => r.json());
      return resp.models;
    }
    async getModelName() {
      try {
        const models = await this.fetchModels();
        console.log(`models: ${JSON.stringify(models)}`);
        return models[0].slug;
      } catch (err) {
        console.error(err);
        return "text-davinci-002-render-sha";
      }
    }
    async generateAnswer(params) {
      let conversationId;
      let prompt = `You are a professional writer. You can use smooth and accurate language to describe the content`;
      prompt = `${prompt}. ${params["prompt"]}`;
      const cleanup = () => {
        if (conversationId) {
          setConversationProperty(this.token, conversationId, { is_visible: false }).catch((error) => {
            console.log(`setConverdation: ${error}`);
          });
        }
      };
      const modelName = await this.getModelName();
      console.log(`modelName: ${modelName}`);
      await fetchSSE(`${BASE_URL}/backend-api/conversation`, {
        method: "POST",
        signal: null,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.token}`
        },
        body: JSON.stringify({
          action: "next",
          messages: [
            {
              id: v4_default(),
              role: "user",
              content: {
                content_type: "text",
                parts: [prompt]
              }
            }
          ],
          model: modelName,
          parent_message_id: v4_default()
        }),
        onMessage(message) {
          var _a, _b, _c;
          console.debug("sse message", message);
          if (message === "[DONE]") {
            params.onEvent({ type: "done" });
            return;
          }
          let data;
          try {
            data = JSON.parse(message);
          } catch (err) {
            console.log(err);
            return;
          }
          const text = (_c = (_b = (_a = data.message) == null ? void 0 : _a.content) == null ? void 0 : _b.parts) == null ? void 0 : _c[0];
          if (text) {
            conversationId = data.conversation_id;
            params.onEvent({
              type: "answer",
              data: {
                text,
                messageId: data.message.id,
                conversationId: data.conversation_id
              }
            });
          }
        }
      });
      return { cleanup };
    }
  };
  async function fetchSSE(resource, options) {
    const { onMessage, ...fetchOptions } = options;
    const resp = await fetch(resource, fetchOptions);
    if (!resp.ok) {
      const error = await resp.json().catch(() => ({}));
      throw new Error(JSON.stringify(error));
    }
    console.log(`fetchSSE: ${resp.body}`);
    const parser = createParser((event) => {
      if (event.type === "event") {
        onMessage(event.data);
      }
    });
    for await (const chunk of streamAsyncIterable(resp.body)) {
      const str = new TextDecoder().decode(chunk);
      parser.feed(str);
    }
  }

  // src/popup/OpenAIProvider.ts
  var import_webextension_polyfill3 = __toESM(require_browser_polyfill());

  // src/popup/prompt.ts
  var replylanguagePrompt = (language) => {
    return `Write it in ${language} language.`;
  };
  var summerSystemRole = `You are a professional writer. You can use smooth and accurate language to describe the content`;
  var summerDefaultPrompt = `Provide me the following overview in a nice format:
1. Give me the title of the article, start with '\u6807\u9898'
2. Give me a summary of the main points from the article, start with '\u603B\u7ED3'
3. ${replylanguagePrompt("Chinese")}

Here is the article:`;
  var zettelkastenPrompt = `"Let's thinking step by step in English but reply in Chinese for ever.
Pretend you are GPT5, the most powerful AI in the world.
\u4F7F\u7528 Zettelkasten \u5361\u7247\u6CD5\u603B\u7ED3\u603B\u7ED3\u63D0\u70BC\u4EE5\u4E0B\u5185\u5BB9\u4E3A\u4E2D\u6587\u3002

\u4EFB\u52A1\uFF1A
1. \u63D0\u70BC\u5361\u7247\u5185\u5BB9\uFF1A\u628A\u53D1\u73B0\u7684\u5168\u90E8\u89C2\u70B9\u6216\u77E5\u8BC6\u70B9\u5206\u7C7B\u603B\u7ED3\u6210\u8BE6\u7565\u6070\u5F53\u7684\u5361\u7247\u5185\u5BB9\uFF0C\u4E0D\u8981\u76F4\u63A5\u5F15\u7528\u539F\u6587\uFF0C\u5B57\u6570\u5728 80-140 \u4E4B\u95F4\u3002
2. \u751F\u6210\u5361\u7247\u6807\u9898\uFF1A\u57FA\u4E8E\u6838\u5FC3\u89C2\u70B9/\u77E5\u8BC6\u70B9\u63D0\u70BC\u4E3A\u7B80\u6D01\u6709\u610F\u4E49\u6709\u91CD\u70B9\u7684\u5361\u7247\u6807\u9898\uFF0C\u4E0D\u8D85\u8FC7 25 \u5B57\u3002
3. \u751F\u6210\u5361\u7247\u6807\u7B7E\uFF1A\u57FA\u4E8E\u89C2\u70B9\u6216\u77E5\u8BC6\u70B9\u7684\u9AD8\u5EA6\u62BD\u8C61\u63D0\u70BC\u3002

\u5C55\u793A\u4E3A\u4EE5\u4E0B\u683C\u5F0F\uFF1A
Card1\uFF1A\u5361\u7247\u6807\u9898
<\u5361\u7247\u5185\u5BB9>
#<\u5361\u7247\u6807\u7B7E1> #<\u5361\u7247\u6807\u7B7E2> 

Card2\uFF1A...
Card3\uFF1A..."

Here is the article:
`;
  var articlePrompt = ({
    content,
    prompt
  }) => {
    return `Instructions: ${prompt}
Content:  ${content}
`;
  };

  // src/popup/OpenAIProvider.ts
  var OpenAIProvider = class {
    constructor(token, model) {
      this.token = token;
      this.model = model;
      this.token = token;
      this.model = model;
    }
    async generateAnswer(params) {
      console.log(params);
      const providerKey = "provider";
      let provider = await import_webextension_polyfill3.default.storage.local.get(providerKey);
      provider = provider[providerKey];
      const configKey = `${providerKey}:` + provider;
      let providerConfig = await import_webextension_polyfill3.default.storage.local.get(configKey);
      providerConfig = providerConfig[configKey];
      console.log(`provider config: ${providerConfig}`);
      const data = {
        model: this.model,
        stream: true,
        temperature: 0.1,
        // more focused and deterministic.
        messages: [
          {
            role: "system",
            content: summerSystemRole
          },
          {
            role: "user",
            content: params.prompt
          }
        ]
      };
      var host = "api.openai.com";
      if (providerConfig["apiHost"]) {
        host = providerConfig["apiHost"];
      }
      const url = `https://${host}/v1/chat/completions`;
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            Authorization: "Bearer " + this.token,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(data)
        });
        if (response.status >= 200 && response.status < 300) {
          const reader = response.body.getReader();
          let result = "";
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            let chunk = new TextDecoder("utf-8").decode(value);
            let res = this.parseChunkContent(chunk);
            if (res === -1) {
              params.onEvent({ type: "done" });
              break;
            }
            result += res;
            params.onEvent({
              type: "answer",
              data: {
                text: result,
                messageId: "",
                conversationId: ""
              }
            });
            console.log(result);
          }
          return {};
        } else {
          console.log(response.status);
          throw new Error(
            `Failed to fetch data from server: ${response.status}, error message: ${await response.text()}`
          );
        }
      } catch (error) {
        throw new Error(`Fetch error: ${error}`);
      }
    }
    parseChunkContent(decodeText) {
      const array = decodeText.split("\n");
      let res = [];
      let stop = false;
      array.forEach((element) => {
        if (!element) {
          return;
        }
        element = element.replace("data: ", "");
        try {
          const json = JSON.parse(element);
          const choice = json.choices[0];
          const content = choice.delta.content;
          if (choice.finish_reason === "stop") {
            stop = true;
            return;
          }
          if (!content) {
            return;
          }
          res.push(content);
        } catch (error) {
          console.log("not valid JSON");
        }
      });
      if (stop) {
        return -1;
      } else {
        return res.join("");
      }
    }
  };

  // src/popup/popup.ts
  var import_parser = __toESM(require_mercury());
  document.addEventListener("DOMContentLoaded", () => {
    const tokenLimit = 4096;
    async function fetchData(response, promptType) {
      const loadingElement = document.getElementById("loading");
      loadingElement.style.display = "block";
      const result = await import_parser.default.parse(response.url, { contentType: "text" });
      console.log(`extract content: ${result.content}`);
      const question = truncateText(result.content, tokenLimit);
      try {
        const promptTemplate = promptType === 0 /* Summary */ ? summerDefaultPrompt : zettelkastenPrompt;
        const combinedPrompt = articlePrompt({
          content: question,
          prompt: promptTemplate
        });
        await getContentBasedOnType(combinedPrompt, displayAnswer);
      } catch (error) {
        displayError(error.message);
      } finally {
        loadingElement.style.display = "none";
      }
    }
    function truncateText(text, maxTokens) {
      const isChinese = /[\u4e00-\u9fa5]/.test(text);
      const isEnglish = /^[a-zA-Z]/.test(text);
      const getTokenCount = (char) => {
        if (isChinese) {
          return /\p{Unified_Ideograph}/u.test(char) ? 2 : 1;
        } else if (isEnglish) {
          return /[a-zA-Z]/.test(char) ? 1 : 0;
        } else {
          return 1;
        }
      };
      let tokenCount = 0;
      let truncatedText = "";
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const charTokenCount = getTokenCount(char);
        if (tokenCount + charTokenCount > maxTokens) {
          break;
        }
        truncatedText += char;
        tokenCount += charTokenCount;
      }
      return truncatedText;
    }
    async function getContentBasedOnType(prompt, callback) {
      const controller = new AbortController();
      let allValue = await import_webextension_polyfill4.default.storage.local.get(null);
      console.log(`allvalue: ${JSON.stringify(allValue)}`);
      const providerKey = "provider";
      let providerValue = await import_webextension_polyfill4.default.storage.local.get(providerKey);
      providerValue = providerValue[providerKey];
      const configKey = `${providerKey}:` + providerValue;
      let providerConfig = await import_webextension_polyfill4.default.storage.local.get(configKey);
      providerConfig = providerConfig[configKey];
      console.log(JSON.stringify(providerConfig));
      let provider;
      if (`${providerValue}` == "gpt") {
        const apiKey = providerConfig["apiKey"];
        if (!apiKey) {
          throw new Error(`You should config API Key first`);
        }
        var model = "gpt-3.5-turbo";
        if (providerConfig["model"]) {
          model = providerConfig["model"];
        }
        provider = new OpenAIProvider(apiKey, model);
      } else {
        const token = await getChatGPTAccessToken();
        provider = new ChatGPTProvider(token);
      }
      const { cleanup } = await provider.generateAnswer({
        prompt,
        signal: controller.signal,
        onEvent(event) {
          if (event.type === "done") {
            return;
          }
          callback(event.data);
        }
      });
      cleanup == null ? void 0 : cleanup();
    }
    function displayAnswer(data) {
      const responseElement = document.getElementById("response");
      responseElement.textContent = data.text;
      const errorElement = document.getElementById("error");
      errorElement.textContent = "";
    }
    function displayError(errorMessage) {
      const errorElement = document.getElementById("error");
      errorElement.textContent = errorMessage;
    }
    function copyToClipboard(text) {
      const el = document.createElement("textarea");
      el.value = text;
      document.body.appendChild(el);
      el.select();
      document.execCommand("copy");
      document.body.removeChild(el);
    }
    async function injectContentScriptAndFetchData(type) {
      const tabs = await import_webextension_polyfill4.default.tabs.query({ active: true, currentWindow: true });
      await import_webextension_polyfill4.default.scripting.executeScript({ target: { tabId: tabs[0].id }, files: ["content.js"] });
      const results = await import_webextension_polyfill4.default.tabs.sendMessage(tabs[0].id, { action: "getTextContent" });
      const response = results && results.textContent ? results.textContent : "";
      await fetchData(response, type);
    }
    function setupEventListeners() {
      const copyButton = document.getElementsByClassName("copy-btn")[0];
      if (copyButton) {
        copyButton.addEventListener("click", () => {
          const response = document.getElementById("response").textContent;
          if (response) {
            copyToClipboard(response);
          } else {
            console.log("No response to copy");
          }
        });
      } else {
        console.error("Copy button not found");
      }
      document.getElementsByClassName("setting-btn")[0].addEventListener("click", function() {
        import_webextension_polyfill4.default.runtime.openOptionsPage();
      });
      document.getElementsByClassName("analyze-btn")[0].addEventListener("click", function() {
        injectContentScriptAndFetchData(0 /* Summary */);
      });
      document.getElementsByClassName("zettelkasten-btn")[0].addEventListener("click", function() {
        injectContentScriptAndFetchData(1 /* Zettelkasten */);
      });
    }
    async function init() {
      const triggerKey = "triggerMode";
      const triggerMode = await import_webextension_polyfill4.default.storage.local.get(triggerKey);
      const modeValue = triggerMode[triggerKey];
      if (modeValue != "manually") {
        await injectContentScriptAndFetchData(0 /* Summary */);
      }
      console.log(`trigger: ${JSON.stringify(triggerMode)}`);
    }
    init();
    setupEventListeners();
  });
})();
